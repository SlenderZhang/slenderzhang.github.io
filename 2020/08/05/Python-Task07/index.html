<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Python-Task07 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Python编程基础-Task07Task 7:类、对象与魔法方法类与对象 1.对象&#x3D;属性+方法 对象是类的实例。 封装：我们可以使用关键字class定义Python类，关键字后面紧跟类的名称、分号和类的实现。 Python中的类名约定以大写字母开头。 继承：子类自动共享父类之间数据和方法的机制。 多态：不同对象对不同方法响应不同的行动。 2.Self   Python 的 self 相当于 C+">
<meta property="og:type" content="article">
<meta property="og:title" content="Python-Task07">
<meta property="og:url" content="http://yoursite.com/2020/08/05/Python-Task07/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Python编程基础-Task07Task 7:类、对象与魔法方法类与对象 1.对象&#x3D;属性+方法 对象是类的实例。 封装：我们可以使用关键字class定义Python类，关键字后面紧跟类的名称、分号和类的实现。 Python中的类名约定以大写字母开头。 继承：子类自动共享父类之间数据和方法的机制。 多态：不同对象对不同方法响应不同的行动。 2.Self   Python 的 self 相当于 C+">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-08-05T15:20:52.000Z">
<meta property="article:modified_time" content="2020-08-25T06:18:47.700Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Python-Task07" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/05/Python-Task07/" class="article-date">
  <time datetime="2020-08-05T15:20:52.000Z" itemprop="datePublished">2020-08-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Python-Task07
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Python编程基础-Task07"><a href="#Python编程基础-Task07" class="headerlink" title="Python编程基础-Task07"></a>Python编程基础-Task07</h1><h2 id="Task-7-类、对象与魔法方法"><a href="#Task-7-类、对象与魔法方法" class="headerlink" title="Task 7:类、对象与魔法方法"></a>Task 7:类、对象与魔法方法</h2><p><strong>类与对象</strong></p>
<p>1.对象=属性+方法</p>
<p>对象是类的实例。</p>
<p>封装：我们可以使用关键字class定义Python类，关键字后面紧跟类的名称、分号和类的实现。</p>
<p>Python中的类名约定以大写字母开头。</p>
<p>继承：子类自动共享父类之间数据和方法的机制。</p>
<p>多态：不同对象对不同方法响应不同的行动。</p>
<p>2.Self   Python 的 <code>self</code> 相当于 C++ 的 <code>this</code> 指针。</p>
<p>类的方法与普通的函数只有一个特别的区别 —— 它们必须有一个额外的第一个参数名称（对应于该实例，即该对象本身），按照惯例它的名称是 <code>self</code>。在调用方法时，我们无需明确提供与参数 <code>self</code> 相对应的参数。</p>
<p>3.Python的魔法方法</p>
<p>​    最基本的魔法方法就是<code>__init__</code>，我们可以用它来指明一个对象初始化的行为。然而，当我们调用 x = SomeClass() 的时候， <code>__init__</code> 并不是第一个被调用的方法。事实上，第一个被调用的是 <code>__new__</code>，这个 方法才真正地创建了实例。当这个对象的生命周期结束的时候， <code>__del__</code> 会被调用。让我们近一步理解这三个方法：</p>
<ul>
<li><p><code>__new__(cls,[...)</code> </p>
<p><code>__new__</code> 是对象实例化时第一个调用的方法，它只取下 cls 参数，并把其他参数传给<code>__init__</code>。 <code>__new__</code>很少使用，但是也有它适合的场景，尤其是当类继承自一个像元组或者字符串这样不经常改变的类型的时候。</p>
</li>
<li><p><code>__init__(self,[...])</code>        构造函数，在生成对象时调用</p>
<p>类的初始化方法。它获取任何传给构造器的参数（比如我们调用 x = SomeClass(10, ‘foo’) ， <code>__init__</code>就会接到参数 10 和 ‘foo’ 。 <code>__init__</code>在Python的类定义中用的最多。</p>
</li>
<li><p><code>__del__(self)</code>       析构函数，释放对象时使用</p>
<p><code>__new__</code>和 <code>__init__</code> 是对象的构造器， <code>__del__</code>是对象的销毁器。它并非实现了语句 del x (因此该语句不等同于 x.<strong>del</strong>())。而是定义了当对象被垃圾回收时的行为。 当对象需要在销毁时做一些处理的时候这个方法很有用，比如 socket 对象、文件对象。但是需要注意的是，当Python解释器退出但对象仍然存活的时候， <code>__del__</code> 并不会 执行。 所以养成一个手工清理的好习惯是很重要的，比如及时关闭连接。</p>
</li>
</ul>
<p><strong><strong>call</strong>(self[, args…])</strong>允许一个类的实例像函数一样被调用：x(a, b) 调用 x.<strong>call</strong>(a, b)</p>
<p><strong><strong>len</strong>(self)</strong>定义当被 len() 调用时的行为，获得长度。</p>
<p><strong>repr</strong>(self)定义当被 repr() 调用时的行为，打印，转换。</p>
<p><strong><strong>str</strong>(self)</strong>定义当被 str() 调用时的行为</p>
<p><strong>bytes</strong>(self)定义当被 bytes() 调用时的行为</p>
<p><strong><strong>hash</strong>(self)</strong>定义当被 hash() 调用时的行为</p>
<p><strong><strong>bool</strong>(self)</strong>定义当被 bool() 调用时的行为，应该返回 True 或 False</p>
<p><strong><strong>format</strong>(self, format_spec)</strong>定义当被 format() 调用时的行为</p>
<p><strong><strong>setitem</strong> :</strong> 按照索引赋值</p>
<p><strong><strong>getitem</strong>:</strong> 按照索引获取值</p>
<p><strong><strong>cmp</strong>:</strong> 比较运算</p>
<p><strong><strong>add</strong>:</strong> 加运算</p>
<p><strong><strong>sub</strong>:</strong> 减运算</p>
<p><strong><strong>mul</strong>:</strong> 乘运算</p>
<p><strong><strong>truediv</strong>:</strong> 除运算</p>
<p><strong><strong>mod</strong>:</strong> 求余运算</p>
<p><strong><strong>pow</strong>:</strong> 乘方</p>
<p>4.公有和私有</p>
<p>在 Python 中定义私有变量只需要在变量名或函数名前加上“__”两个下划线。</p>
<p>​    以这种格式定义的方法或变量一般来说应当是仅供类的内部调用。对于以这种格式定义的私有属性，python并没有强制性的访问限制，而是采用了所谓的<strong>名字改编(name mangling)</strong>。名字改编指的是Python会将类中定义的所有以至少两个下划线开头，至多一个下划线结尾的属性(包括方法和变量)的名称改编为<code>_类名__方法名</code>的格式。例如对于<code>__func()</code>，其会被改编为<code>_classname__func()</code>。_注意在改编的时候，类名中包含的所有前缀下划线都将被忽略。_只要在类中定义了符合上述格式的属性，不论该属性是方法还是变量，这一名字改编的过程总是会发生。另外，名字改编还可以使得子类在重载父类的方法时避免产生命名冲突。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__var = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bar</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'bar'</span>)</span><br><span class="line"></span><br><span class="line">f = foo()</span><br><span class="line"></span><br><span class="line">hasattr(f, <span class="string">'__bar'</span>)  <span class="comment"># False</span></span><br><span class="line">hasattr(f, <span class="string">'_foo__bar'</span>)  <span class="comment">#True</span></span><br><span class="line">hasattr(f, <span class="string">'__var'</span>)  <span class="comment"># False</span></span><br><span class="line">hasattr(f, <span class="string">'_foo__var'</span>)  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">f.__bar()  <span class="comment"># AttributeError: 'foo' object has no attribute '__bar'  不能直接访问</span></span><br><span class="line">f._foo__bar()  <span class="comment"># will print out 'bar'  换个名字就可以访问了</span></span><br><span class="line">f._foo_var  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<p>5.继承</p>
<p>继承父类时，如果重写了子类的<code>__init__</code>，也就是子类的构造方法把父类的构造方法覆盖了，此时如果还想用父类的<code>__init__</code>中定义的属性，有两种方式：</p>
<ul>
<li><p>调用未绑定的父类方法<code>Fish.__init__(self)</code>，传入self参数，通过父类.方法名调用，此时的self是作为子类的属性传入。</p>
</li>
<li><p>使用super函数<code>super().__init__()</code>，不传self参数。super() 函数是用于调用父类(超类)的一个方法。</p>
</li>
</ul>
<p>python对大小写是敏感的。</p>
<p>6.组合</p>
<p>类的组合，是指一个类的属性直接是另外一个类的实例。</p>
<p>一个类被定义后，目标就是把它当成一个模块来使用，并把这些对象嵌入到你的代码中去，同其他数据类型及逻辑执行流混合使用。<br>有两种方法可以在你的代码中利用类。<br>第一种是组合，就是让不同的类混合并加入到其他类中，来增强功能和代码重用性。你可以在一个大点的类中创建你自己的类的实例，实现一些其他属性和方法来增强原来的类对象。<br>另一种是派生，通过子类从基类继承核心属性，不断地派生扩展功能实现。</p>
<p><strong>关于类的组合与类的继承的选择问题</strong></p>
<ul>
<li>类的继承和组合都是将别的类的属性或者方法拿过来用</li>
<li>使用组合的情况:当类之间有显著不同，并且较小的类是较大类所需要的组件时候，就可以用组合</li>
<li>使用继承的情况:当类与类之间有相同的功能，提取这些共同的功能做成基类，用继承比较好</li>
</ul>
<p>7.类、类对象和实例对象</p>
<p>类对象：创建一个类，其实也是一个对象也在内存开辟了一块空间，称为类对象，类对象只有一个。</p>
<p>实例对象：就是通过实例化类创建的对象，称为实例对象，实例对象可以有多个。</p>
<p>类属性：类里面方法外面定义的变量称为类属性。类属性所属于类对象并且多个实例对象之间共享同一个类属性，说白了就是类属性所有的通过该类实例化的对象都能共享。</p>
<p>实例属性：实例属性和具体的某个实例对象有关系，并且一个实例对象和另外一个实例对象是不共享属性的，说白了实例属性只能在自己的对象里面使用，其他的对象不能直接使用，因为<code>self</code>是谁调用，它的值就属于该对象。</p>
<p>类属性和实例属性区别</p>
<ul>
<li>类属性：类外面，可以通过<code>实例对象.类属性</code>和<code>类名.类属性</code>进行调用。类里面，通过<code>self.类属性</code>和<code>类名.类属性</code>进行调用。</li>
<li>实例属性 ：类外面，可以通过<code>实例对象.实例属性</code>调用。类里面，通过<code>self.实例属性</code>调用。</li>
<li>实例属性就相当于局部变量。出了这个类或者这个类的实例对象，就没有作用了。</li>
<li>类属性就相当于类里面的全局变量，可以和这个类的所有实例对象共享。</li>
</ul>
<p>注意：属性与方法名相同时，属性会覆盖方法。</p>
<p>8.绑定</p>
<p>Python 严格要求方法需要有实例才能被调用。</p>
<p>self参数的作用是绑定方法，有了这个参数，Python 可以分清是哪个对象在调用方法和属性，可以认为方法中的 self 其实就是实例对象的唯一标志。</p>
<p>Python 对象的数据属性通常存储在名为<code>.__ dict__</code>的字典中，我们可以直接访问<code>__dict__</code>，或利用 Python 的内置函数<code>vars()</code>获取<code>.__ dict__</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CC</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setXY</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printXY</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.x, self.y)</span><br><span class="line"></span><br><span class="line">dd = CC()</span><br><span class="line">print(dd.__dict__)</span><br><span class="line"><span class="comment"># &#123;&#125;</span></span><br><span class="line">print(vars(dd))</span><br><span class="line"><span class="comment"># &#123;&#125;</span></span><br><span class="line">print(CC.__dict__)</span><br><span class="line"><span class="comment"># &#123;'__module__': '__main__', 'setXY': &lt;function CC.setXY at 0x000000C3473DA048&gt;, 'printXY': &lt;function CC.printXY at 0x000000C3473C4F28&gt;, '__dict__': &lt;attribute '__dict__' of 'CC' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'CC' objects&gt;, '__doc__': None&#125;</span></span><br><span class="line">dd.setXY(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">print(dd.__dict__)</span><br><span class="line"><span class="comment"># &#123;'x': 4, 'y': 5&#125;</span></span><br><span class="line">print(vars(CC))</span><br><span class="line"><span class="comment"># &#123;'__module__': '__main__', 'setXY': &lt;function CC.setXY at 0x000000632CA9B048&gt;, 'printXY': &lt;function CC.printXY at 0x000000632CA83048&gt;, '__dict__': &lt;attribute '__dict__' of 'CC' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'CC' objects&gt;, '__doc__': None&#125;</span></span><br><span class="line">print(CC.__dict__)</span><br><span class="line"><span class="comment"># &#123;'__module__': '__main__', 'setXY': &lt;function CC.setXY at 0x000000632CA9B048&gt;, 'printXY': &lt;function CC.printXY at 0x000000632CA83048&gt;, '__dict__': &lt;attribute '__dict__' of 'CC' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'CC' objects&gt;, '__doc__': None&#125;</span></span><br></pre></td></tr></table></figure>

<p>9.一些相关的内置函数（BIF）</p>
<p>1）<code>issubclass(class, classinfo)</code> 方法用于判断参数 class 是否是类型参数 classinfo 的子类。一个类被认为是其自身的子类。<code>classinfo</code>可以是类对象的元组，只要class是其中任何一个候选类的子类，则返回<code>True</code>。</p>
<p>2）<code>isinstance(object, classinfo)</code> 方法用于判断一个对象是否是一个已知的类型，类似<code>type()</code>。但是，<code>type()</code>不会认为子类是一种父类类型，不考虑继承关系；<code>isinstance()</code>会认为子类是一种父类类型，考虑继承关系。（如果第一个参数不是对象，则永远返回<code>False</code>。如果第二个参数不是类或者由类对象组成的元组，会抛出一个<code>TypeError</code>异常。）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line">print(isinstance(a, int))  <span class="comment"># True</span></span><br><span class="line">print(isinstance(a, str))  <span class="comment"># False</span></span><br><span class="line">print(isinstance(a, (str, int, list)))  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(isinstance(A(), A))  <span class="comment"># True</span></span><br><span class="line">print(type(A()) == A)  <span class="comment"># True</span></span><br><span class="line">print(isinstance(B(), A))  <span class="comment"># True</span></span><br><span class="line">print(type(B()) == A)  <span class="comment"># False</span></span><br></pre></td></tr></table></figure>

<p>3）<code>hasattr(object, name)</code>用于判断对象是否包含对应的属性。</p>
<p>4）<code>getattr(object, name[, default])</code>用于返回一个对象属性值。如果没有该属性，则返回default。name可以传 方法名，则返回的是方法。可以调用该方法。</p>
<p>5）<code>setattr(object, name, value)</code>对应函数 <code>getattr()</code>，用于设置属性值，该属性不一定是存在的。</p>
<p>6）<code>delattr(object, name)</code>用于删除属性。</p>
<p>7）<code>class property([fget[, fset[, fdel[, doc]]]])</code>用于在新式类中返回属性值。<code>fget</code> – 获取属性值的函数；<code>fset</code> – 设置属性值的函数；<code>fdel</code> – 删除属性值函数；<code>doc</code> – 属性描述信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__x = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getx</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setx</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.__x = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delx</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">del</span> self.__x</span><br><span class="line"></span><br><span class="line">    x = property(getx, setx, delx, <span class="string">"I'm the 'x' property."</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cc = C()</span><br><span class="line">cc.x = <span class="number">2</span></span><br><span class="line">print(cc.x)  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> cc.x</span><br><span class="line">print(cc.x)</span><br><span class="line"><span class="comment"># AttributeError: 'C' object has no attribute '_C__x'</span></span><br></pre></td></tr></table></figure>



<p>10.练习题</p>
<p>1）以下类定义中哪些是类属性，哪些是实例属性？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.x = <span class="number">4</span></span><br><span class="line">        self.y = <span class="number">5</span></span><br><span class="line">        C.count = <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>num、count是类属性；x、y是实例属性。</p>
<p>2）怎么定义私有⽅法？</p>
<p>前面加两个下划线。</p>
<p>3）执行以下代码，并解释错误原因：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myFun</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'Hello!'</span>)</span><br><span class="line">    c = C()</span><br><span class="line">    c.myFun()</span><br></pre></td></tr></table></figure>

<p>定义方法时，没有self参数；类内写了创建类实例和调用实例的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myFun</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Hello!'</span>)</span><br><span class="line">c = C()</span><br><span class="line">c.myFun()</span><br></pre></td></tr></table></figure>

<p>4）按照以下要求定义一个游乐园门票的类，并尝试计算2个成人+1个小孩平日票价。</p>
<p>要求:</p>
<ul>
<li>平日票价100元</li>
<li>周末票价为平日的120%</li>
<li>儿童票半价</li>
</ul>
<p>实现1：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># your code here</span></span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.price = <span class="number">100</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weekendPrice</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.price *= <span class="number">1.2</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kidsPrice</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.price *= <span class="number">0.5</span></span><br><span class="line">adult = Ticket()</span><br><span class="line">kid = Ticket()</span><br><span class="line">kid.kidsPrice()</span><br><span class="line">print(adult.price * <span class="number">2</span>+kid.price)</span><br></pre></td></tr></table></figure>

<p>250.0</p>
<p>实现2：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, weekend=False, child=False)</span>:</span></span><br><span class="line">        self.price = <span class="number">100</span></span><br><span class="line">        <span class="keyword">if</span> weekend:</span><br><span class="line">            self.w = <span class="number">1.2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.w = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> child:</span><br><span class="line">            self.discount = <span class="number">0.5</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.discount = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clacPrice</span><span class="params">(self,num)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.price * self.w * self.discount * num</span><br><span class="line"></span><br><span class="line">adult = Ticket()</span><br><span class="line">child = Ticket(child=<span class="literal">True</span>)</span><br><span class="line">print(<span class="string">"2个成人+1个小孩平日票价为：%.2f"</span>% (adult.clacPrice(<span class="number">2</span>) + child.clacPrice(<span class="number">1</span>)))</span><br></pre></td></tr></table></figure>

<p>2个成人+1个小孩平日票价为：250.00</p>
<p>实现3：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span>:</span></span><br><span class="line">    price = <span class="number">100</span></span><br><span class="line">    weekend = price*<span class="number">1.2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">(self, adultcount, childcount, isweekend)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isweekend == <span class="string">'no'</span>:</span><br><span class="line">            total = int(adultcount) * self.price + int(childcount)*self.price/<span class="number">2</span></span><br><span class="line">            print(<span class="string">"应该支付金额："</span>, str(total))</span><br><span class="line">        <span class="keyword">elif</span> isweekend ==<span class="string">'yes'</span>:</span><br><span class="line">            total = int(adultcount) * self.weekend + int(childcount)*self.weekend/<span class="number">2</span></span><br><span class="line">            print(<span class="string">"应该支付金额："</span>, str(total))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"输入有误！"</span>)</span><br><span class="line"></span><br><span class="line">adult = input(<span class="string">"请输入成年人数量"</span>)</span><br><span class="line">child = input(<span class="string">"请输入小孩数量"</span>)</span><br><span class="line">isweekend = input(<span class="string">"是否是周末？yes/no"</span>)</span><br><span class="line">t = Ticket()</span><br><span class="line">t.compute(adult, child, isweekend)</span><br></pre></td></tr></table></figure>

<p>请输入成年人数量2<br>请输入小孩数量1<br>是否是周末？yes/nono<br>应该支付金额： 250.0</p>
<p><strong>魔法方法</strong></p>
<p>​    魔法方法总是被双下划线包围，例如<code>__init__</code>。魔法方法的“魔力”体现在它们总能够在适当的时候被自动调用。</p>
<p>​    魔法方法的第一个参数应为<code>cls</code>（类方法） 或者<code>self</code>（实例方法）。</p>
<ul>
<li><code>cls</code>：代表一个类的名称</li>
<li><code>self</code>：代表一个实例对象的名称</li>
</ul>
<p>1.基本的魔法方法</p>
<p>1）<code>__init__(self[, ...])</code> 构造器，当一个实例被创建的时候调用的初始化方法</p>
<p>2）<code>__new__(cls[, ...])</code> 在一个对象实例化的时候所调用的第一个方法，在调用<code>__init__</code>初始化前，先调用<code>__new__</code>。</p>
<ul>
<li><code>__new__</code>至少要有一个参数<code>cls</code>，代表要实例化的类，此参数在实例化时由 Python 解释器自动提供，后面的参数直接传递给<code>__init__</code>。</li>
<li><code>__new__</code>对当前类进行了实例化，并将实例返回，传给<code>__init__</code>的<code>self</code>。但是，执行了<code>__new__</code>，并不一定会进入<code>__init__</code>，只有<code>__new__</code>返回的是当前类<code>cls</code>的实例，当前类的<code>__init__</code>才会进入。也就是说，在init()调用之前，new()决定是否要使用该init()方法，因为new()可以调用其他类的构造方法或者直接返回别的对象来作为本类 的实例。 </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,value)</span>:</span></span><br><span class="line">        print(<span class="string">"into A __init__"</span>)</span><br><span class="line">        self.value = value</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"into A __new__"</span>)</span><br><span class="line">        print(cls)</span><br><span class="line">        <span class="keyword">return</span> object.__new__(cls)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        print(<span class="string">"into B __init__"</span>)</span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls,*args,**kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"into B __new__"</span>)</span><br><span class="line">        print(cls)</span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls,*args,**kwargs)    <span class="comment"># __new__返回了当前类cls的实例，当前类的__init__才会进入。</span></span><br><span class="line"></span><br><span class="line">b = B(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">into B __new__</span><br><span class="line">&lt;class &#39;__main__.B&#39;&gt;</span><br><span class="line">into A __new__</span><br><span class="line">&lt;class &#39;__main__.B&#39;&gt;</span><br><span class="line">into B __init__</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,value)</span>:</span></span><br><span class="line">        print(<span class="string">"into A __init__"</span>)</span><br><span class="line">        self.value = value</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"into A __new__"</span>)</span><br><span class="line">        print(cls)</span><br><span class="line">        <span class="keyword">return</span> object.__new__(cls)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        print(<span class="string">"into B __init__"</span>)</span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls,*args,**kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"into B __new__"</span>)</span><br><span class="line">        print(cls)</span><br><span class="line">        <span class="keyword">return</span> super().__new__(A,*args,**kwargs)  <span class="comment"># 若__new__没有正确返回当前类cls的实例，那__init__是不会被调用的，即使是父类的实例也不行，将没有__init__被调用。</span></span><br><span class="line"></span><br><span class="line">b = B(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">into B __new__</span><br><span class="line">&lt;class &#39;__main__.B&#39;&gt;</span><br><span class="line">into A __new__</span><br><span class="line">&lt;class &#39;__main__.A&#39;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,value)</span>:</span></span><br><span class="line">        print(<span class="string">"into A __init__"</span>)</span><br><span class="line">        self.value = value</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"into A __new__"</span>)</span><br><span class="line">        print(cls)</span><br><span class="line">        <span class="keyword">return</span> object.__new__(cls)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        print(<span class="string">"into B __init__"</span>)</span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls,*args,**kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"into B __new__"</span>)</span><br><span class="line">        print(cls)</span><br><span class="line">        <span class="keyword">return</span> super().__new__(B,*args,**kwargs)   <span class="comment"># 再改__new__返回当前类B的实例，那B的__init__会被调用。与传入'cls'结果一样。</span></span><br><span class="line"></span><br><span class="line">b = B(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">into B __new__</span><br><span class="line">&lt;class &#39;__main__.B&#39;&gt;</span><br><span class="line">into A __new__</span><br><span class="line">&lt;class &#39;__main__.B&#39;&gt;</span><br><span class="line">into B __init__</span><br></pre></td></tr></table></figure>

<p>new()方法的特性：</p>
<p>new()方法是在类准备将自身实例化时调用。 </p>
<p>new()方法始终都是类的静态方法，即使没有被加上静态方法装饰器。</p>
<p>什么情况下使用 <strong>new</strong>() 呢？答案很简单，在 <strong>init</strong>() 不够用的时候。例如，对 Python 不可变的内置类型（如 int、str、float 等）进行子类化，这是因为一旦创建了这样不可变的对象实例，就无法在 <strong>init</strong>() 方法中对其进行修改。</p>
<p><code>__new__</code>方法主要是当你继承一些不可变的 class 时（比如<code>int, str, tuple</code>）， 提供给你一个自定义这些类的实例化过程的途径：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CapStr</span><span class="params">(str)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls,string)</span>:</span></span><br><span class="line">        string = string.upper()</span><br><span class="line">        <span class="keyword">return</span> str.__new__(cls,string)</span><br><span class="line">    </span><br><span class="line">a = CapStr(<span class="string">"i love lsgogroup"</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>

<p>结果： I LOVE LSGOGROUP</p>
<p>可以利用<code>__new__</code>实现单例模式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Earth</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">a = Earth()</span><br><span class="line">print(id(a))</span><br><span class="line">b = Earth()</span><br><span class="line">print(id(b))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Earth</span>:</span></span><br><span class="line">    __instance = <span class="literal">None</span>   <span class="comment"># 定义一个类属性做判断</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls.__instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls.__instance = object.__new__(cls)</span><br><span class="line">            <span class="keyword">return</span> cls.__instance</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> cls.__instance</span><br><span class="line"></span><br><span class="line">a = Earth()</span><br><span class="line">print(id(a))</span><br><span class="line">b = Earth()</span><br><span class="line">print(id(b))</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1737562503208</span><br><span class="line">1737562503264</span><br><span class="line">1737562493112</span><br><span class="line">1737562493112</span><br></pre></td></tr></table></figure>

<p>3）<code>__del__(self)</code> 析构器，当一个对象将要被系统回收之时调用的方法。</p>
<p>Python 采用自动引用计数（简称 ARC）的方式实现垃圾回收GC机制。该方法的核心思想是：每个 Python 对象都会配置一个计数器，初始 Python 实例对象的计数器值都为 0，如果有变量引用该实例对象，其计数器的值会加 1，依次类推；反之，每当一个变量取消对该实例对象的引用，计数器会减 1。如果一个 Python 对象的的计数器值为 0，则表明没有变量引用该 Python 对象，即证明程序不再需要它，此时 Python 就会自动调用 <code>__del__</code>() 方法将其回收。</p>
<p>4）<code>__str__(self)</code>：当你打印一个对象的时候；当你使用%s格式化的时候；str强转数据类型的时候，都会触发<code>__str__</code>。</p>
<p>5）<code>__repr__(self)</code>：</p>
<ul>
<li><p><code>repr</code>是<code>str</code>的备胎</p>
</li>
<li><p>有<code>__str__</code>的时候执行<code>__str__</code>,没有实现<code>__str__</code>的时候，执行<code>__repr__</code></p>
</li>
<li><p><code>repr(obj)</code>内置函数对应的结果是<code>__repr__</code>的返回值</p>
</li>
<li><p>当你使用<code>%r</code>格式化的时候 触发<code>__repr__</code></p>
</li>
</ul>
<p>  <code>__str__(self)</code> 和<code>__repr__(self)</code> 对比：</p>
<p>  1 <code>__str__(self)</code> 的返回结果可读性强。<code>__str__</code> 的意义是得到便于人们阅读的信息，就像下面的 ‘2019-10-11’ 一样。</p>
<p>  2 <code>__repr__(self)</code> 的返回结果应更准确。<code>__repr__</code> 存在的目的在于调试，便于开发者使用。</p>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">today = datetime.date.today()</span><br><span class="line">print(str(today))  <span class="comment"># 2019-10-11</span></span><br><span class="line">print(repr(today))  <span class="comment"># datetime.date(2019, 10, 11)</span></span><br><span class="line">print(<span class="string">'%s'</span> %today)  <span class="comment"># 2019-10-11</span></span><br><span class="line">print(<span class="string">'%r'</span> %today)  <span class="comment"># datetime.date(2019, 10, 11)</span></span><br></pre></td></tr></table></figure>

<p>2.算术运算符</p>
<p>类型工厂函数，指的是“不通过类而是通过函数来创建对象”。</p>
<p>1）<strong>add</strong>(self, other)<code>定义加法的行为：</code>+</p>
<p>2）<strong>sub</strong>(self, other)<code>定义减法的行为：</code>-</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,height,weight)</span>:</span></span><br><span class="line">        self.height = height</span><br><span class="line">        self.weight = weight</span><br><span class="line">    <span class="comment"># 两个对象的长相加，宽不变，返回一个新的类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self,others)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> MyClass(self.height + others.height, self.weight)</span><br><span class="line">    <span class="comment"># 两个对象的宽相减，长不变，返回一个新的类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__sub__</span><span class="params">(self,others)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> MyClass(self.height, self.weight-others.weight)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intro</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"高为"</span>, self.height, <span class="string">"重为"</span>, self.weight)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    a = MyClass(<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line">    a.intro()</span><br><span class="line">    b = MyClass(<span class="number">20</span>,<span class="number">10</span>)</span><br><span class="line">    b.intro()</span><br><span class="line">    c = b-a</span><br><span class="line">    c.intro()</span><br><span class="line">    d = a+b</span><br><span class="line">    d.intro()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>高为 10 重为 5<br>高为 20 重为 10<br>高为 20 重为 5<br>高为 30 重为 5</p>
<p>3）<code>__mul__(self, other)</code>定义乘法的行为：<code>*</code></p>
<p>4）<code>__truediv__(self, other)</code>定义真除法的行为：<code>/</code></p>
<p>5）<strong>floordiv</strong>(self, other)<code>定义整数除法的行为：</code>//</p>
<p>6）<strong>mod</strong>(self, other)<code>定义取模算法的行为：</code>%</p>
<p>7）<code>__divmod__(self, other)</code>定义当被 <code>divmod()</code> 调用时的行为</p>
<p>8）<code>divmod(a, b)</code>把除数和余数运算结果结合起来，返回一个包含商和余数的元组<code>(a // b, a % b)</code>。</p>
<p>9）<code>__pow__(self, other[, module])</code>定义当被 <code>power()</code> 调用或 <code>**</code> 运算时的行为</p>
<p>10）<code>__lshift__(self, other)</code>定义按位左移位的行为：<code>&lt;&lt;</code></p>
<p>11）<code>__rshift__(self, other)</code>定义按位右移位的行为：<code>&gt;&gt;</code></p>
<p>12）<code>__and__(self, other)</code>定义按位与操作的行为：<code>&amp;</code></p>
<p>13）<code>__xor__(self, other)</code>定义按位异或操作的行为：<code>^</code></p>
<p>14）<code>__or__(self, other)</code>定义按位或操作的行为：<code>|</code></p>
<p>3.反算术运算符</p>
<p>反运算魔方方法，与算术运算符保持一一对应，不同之处就是反运算的魔法方法多了一个“r”。当文件左操作不支持相应的操作时被调用。</p>
<ul>
<li><code>__radd__(self, other)</code>定义加法的行为：<code>+</code></li>
<li><code>__rsub__(self, other)</code>定义减法的行为：<code>-</code></li>
<li><code>__rmul__(self, other)</code>定义乘法的行为：<code>*</code></li>
<li><code>__rtruediv__(self, other)</code>定义真除法的行为：<code>/</code></li>
<li><code>__rfloordiv__(self, other)</code>定义整数除法的行为：<code>//</code></li>
<li><code>__rmod__(self, other)</code> 定义取模算法的行为：<code>%</code></li>
<li><code>__rdivmod__(self, other)</code>定义当被 divmod() 调用时的行为</li>
<li><code>__rpow__(self, other[, module])</code>定义当被 power() 调用或 <code>**</code> 运算时的行为</li>
<li><code>__rlshift__(self, other)</code>定义按位左移位的行为：<code>&lt;&lt;</code></li>
<li><code>__rrshift__(self, other)</code>定义按位右移位的行为：<code>&gt;&gt;</code></li>
<li><code>__rand__(self, other)</code>定义按位与操作的行为：<code>&amp;</code></li>
<li><code>__rxor__(self, other)</code>定义按位异或操作的行为：<code>^</code></li>
<li><code>__ror__(self, other)</code>定义按位或操作的行为：<code>|</code></li>
<li></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a + b</span><br></pre></td></tr></table></figure>

<p>这里加数是<code>a</code>，被加数是<code>b</code>，因此是<code>a</code>主动，反运算就是如果<code>a</code>对象的<code>__add__()</code>方法没有实现或者不支持相应的操作，那么 Python 就会调用<code>b</code>的<code>__radd__()</code>方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nint</span><span class="params">(int)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__radd__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> int.__sub__(other, self) <span class="comment"># 注意 self 在后面，1-3=-2</span></span><br><span class="line">a = Nint(<span class="number">5</span>)</span><br><span class="line">b = Nint(<span class="number">3</span>)</span><br><span class="line">print(a + b)  <span class="comment"># 8</span></span><br><span class="line">print(<span class="number">1</span> + b)  <span class="comment"># -2</span></span><br></pre></td></tr></table></figure>

<p>4.增量赋值运算符</p>
<ul>
<li><code>__iadd__(self, other)</code>定义赋值加法的行为：<code>+=</code></li>
<li><code>__isub__(self, other)</code>定义赋值减法的行为：<code>-=</code></li>
<li><code>__imul__(self, other)</code>定义赋值乘法的行为：<code>*=</code></li>
<li><code>__itruediv__(self, other)</code>定义赋值真除法的行为：<code>/=</code></li>
<li><code>__ifloordiv__(self, other)</code>定义赋值整数除法的行为：<code>//=</code></li>
<li><code>__imod__(self, other)</code>定义赋值取模算法的行为：<code>%=</code></li>
<li><code>__ipow__(self, other[, modulo])</code>定义赋值幂运算的行为：<code>**=</code></li>
<li><code>__ilshift__(self, other)</code>定义赋值按位左移位的行为：<code>&lt;&lt;=</code></li>
<li><code>__irshift__(self, other)</code>定义赋值按位右移位的行为：<code>&gt;&gt;=</code></li>
<li><code>__iand__(self, other)</code>定义赋值按位与操作的行为：<code>&amp;=</code></li>
<li><code>__ixor__(self, other)</code>定义赋值按位异或操作的行为：<code>^=</code></li>
<li><code>__ior__(self, other)</code>定义赋值按位或操作的行为：<code>|=</code></li>
</ul>
<p>5.一元运算符</p>
<ul>
<li><code>__neg__(self)</code>定义正号的行为：<code>+x</code></li>
<li><code>__pos__(self)</code>定义负号的行为：<code>-x</code></li>
<li><code>__abs__(self)</code>定义当被<code>abs()</code>调用时的行为</li>
<li><code>__invert__(self)</code>定义按位求反的行为：<code>~x</code></li>
</ul>
<p>6.属性访问</p>
<ul>
<li><code>__getattr__(self, name)</code>: 定义当用户试图获取一个不存在的属性时的行为。</li>
<li><code>__getattribute__(self, name)</code>：定义当该类的属性被访问时的行为（先调用该方法，查看是否存在该属性，若不存在，接着去调用<code>__getattr__</code>）。</li>
<li><code>__setattr__(self, name, value)</code>：定义当一个属性被设置时的行为。</li>
<li><code>__delattr__(self, name)</code>：定义当一个属性被删除时的行为。</li>
</ul>
<p>7.描述符</p>
<p>描述符就是将某种特殊类型的类的实例指派给另一个类的属性。</p>
<ul>
<li><code>__get__(self, instance, owner)</code>用于访问属性，它返回属性的值。</li>
<li><code>__set__(self, instance, value)</code>将在属性分配操作中调用，不返回任何内容。</li>
<li><code>__del__(self, instance)</code>控制删除操作，不返回任何内容。</li>
</ul>
<p>扩展参考：公众号-LSGO软件技术团队</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzIyNDA1NjA1NQ==&mid=2651011392&idx=1&sn=8dc65617504e909862113d4d1f36c2cb&chksm=f3e35ed8c494d7ce55cab936a1477998ccdf6eb865553a7174da44dcfb63b3807d3c4beb9104&token=523711417&lang=zh_CN#rd" target="_blank" rel="noopener">技术图文：什么是Python的描述符？</a></li>
</ul>
<p>属性查询优先级：</p>
<p>① <code>__getattribute__()</code>， 无条件调用<br>② 数据描述符<br>③ 实例对象的字典<br>④ 类的字典<br>⑤ 非数据描述符<br>⑥ 父类的字典<br>⑦ <code>__getattr__()</code>方法</p>
<p>8.定制序列</p>
<p>协议（Protocols）与其它编程语言中的接口很相似，它规定你哪些方法必须要定义。然而，在 Python 中的协议就显得不那么正式。事实上，在 Python 中，协议更像是一种指南。</p>
<p><strong>容器类型的协议</strong></p>
<ul>
<li>如果说你希望定制的容器是不可变的话，你只需要定义<code>__len__()</code>和<code>__getitem__()</code>方法。</li>
<li>如果你希望定制的容器是可变的话，除了<code>__len__()</code>和<code>__getitem__()</code>方法，你还需要定义<code>__setitem__()</code>和<code>__delitem__()</code>两个方法。</li>
</ul>
<p>1）<code>__len__(self)</code>定义当被<code>len()</code>调用时的行为（返回容器中元素的个数）。</p>
<p>2）<code>__getitem__(self, key)</code>定义获取容器中元素的行为，相当于<code>self[key]</code>。</p>
<p>3）<code>__setitem__(self, key, value)</code>定义设置容器中指定元素的行为，相当于<code>self[key] = value</code>。</p>
<p>4）<code>__delitem__(self, key)</code>定义删除容器中指定元素的行为，相当于<code>del self[key]</code>。</p>
<p>9.迭代器</p>
<ul>
<li>迭代是 Python 最强大的功能之一，是访问集合元素的一种方式。</li>
<li>迭代器是一个可以记住遍历的位置的对象。</li>
<li>迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。</li>
<li>迭代器只能往前不会后退。</li>
<li>字符串，列表或元组对象都可用于创建迭代器。</li>
</ul>
<p>可以直接作用于<code>for</code>循环的数据类型有以下几种：</p>
<p>一类是集合数据类型，如<code>list</code>、<code>tuple</code>、<code>dict</code>、<code>set</code>、<code>str</code>等；一类是<code>generator</code>，包括生成器和带<code>yield</code>的generator function。</p>
<p>这些可以直接作用于<code>for</code>循环的对象统称为可迭代对象：<code>Iterable</code>。</p>
<p>可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterable</code>对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([], Iterable)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(&#123;&#125;, Iterable)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">'abc'</span>, Iterable)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)), Iterable)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="number">100</span>, Iterable)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>而生成器不但可以作用于<code>for</code>循环，还可以被<code>next()</code>函数不断调用并返回下一个值，直到最后抛出<code>StopIteration</code>错误表示无法继续返回下一个值了。可以被<code>next()</code>函数调用并不断返回下一个值的对象称为迭代器：<code>Iterator</code>。</p>
<p>可以使用<code>isinstance()</code>判断一个对象是否是<code>Iterator</code>对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance((x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)), Iterator)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance([], Iterator)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(&#123;&#125;, Iterator)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(<span class="string">'abc'</span>, Iterator)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>生成器都是<code>Iterator</code>对象，但<code>list</code>、<code>dict</code>、<code>str</code>虽然是<code>Iterable</code>，却不是<code>Iterator</code>。</p>
<p>把<code>list</code>、<code>dict</code>、<code>str</code>等<code>Iterable</code>变成<code>Iterator</code>可以使用<code>iter()</code>函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(iter([]), Iterator)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(iter(<span class="string">'abc'</span>), Iterator)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>为什么<code>list</code>、<code>dict</code>、<code>str</code>等数据类型不是<code>Iterator</code>？这是因为Python的<code>Iterator</code>对象表示的是一个数据流，Iterator对象可以被<code>next()</code>函数调用并不断返回下一个数据，直到没有数据时抛出<code>StopIteration</code>错误。可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过<code>next()</code>函数实现按需计算下一个数据，所以<code>Iterator</code>的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p>
<p><code>Iterator</code>甚至可以表示一个无限大的数据流，例如全体自然数。而使用list是永远不可能存储全体自然数的。</p>
<p>小结：</p>
<p>1）凡是可作用于<code>for</code>循环的对象都是<code>Iterable</code>类型；</p>
<p>2）凡是可作用于<code>next()</code>函数的对象都是<code>Iterator</code>类型，它们表示一个惰性计算的序列；</p>
<p>3）集合数据类型如<code>list</code>、<code>dict</code>、<code>str</code>等是<code>Iterable</code>但不是<code>Iterator</code>，不过可以通过<code>iter()</code>函数获得一个<code>Iterator</code>对象。</p>
<p>4）Python的<code>for</code>循环本质上就是通过不断调用<code>next()</code>函数实现的。</p>
<p>迭代器有两个基本的方法：<code>iter()</code> 和 <code>next()</code>。</p>
<ul>
<li><code>iter(object)</code> 函数用来生成迭代器。</li>
<li><code>next(iterator[, default])</code> 返回迭代器的下一个项目。</li>
<li><code>iterator</code> – 可迭代对象</li>
<li><code>default</code> – 可选，用于设置在没有下一个元素时返回该默认值，如果不设置，又没有下一个元素则会触发 <code>StopIteration</code> 异常。</li>
</ul>
<p>把一个类作为一个迭代器使用需要在类中实现两个魔法方法 <code>__iter__()</code> 与 <code>__next__()</code> 。</p>
<ul>
<li><code>__iter__(self)</code>定义当迭代容器中的元素的行为，返回一个特殊的迭代器对象， 这个迭代器对象实现了 <code>__next__()</code> 方法并通过 <code>StopIteration</code> 异常标识迭代的完成。</li>
<li><code>__next__()</code> 返回下一个迭代器对象。</li>
<li><code>StopIteration</code> 异常用于标识迭代的完成，防止出现无限循环的情况，在 <code>__next__()</code> 方法中我们可以设置在完成指定循环次数后触发 <code>StopIteration</code> 异常来结束迭代。</li>
</ul>
<p>10.生成器</p>
<ul>
<li>在 Python 中，使用了 <code>yield</code> 的函数被称为生成器（generator）。</li>
<li>跟普通函数不同的是，生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</li>
<li>在调用生成器运行的过程中，每次遇到 <code>yield</code> 时函数会暂停并保存当前所有的运行信息，返回 <code>yield</code> 的值, 并在下一次执行 <code>next()</code> 方法时从当前位置继续运行。</li>
<li>调用一个生成器函数，返回的是一个迭代器对象。</li>
</ul>
<p>要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的<code>[]</code>改成<code>()</code>，就创建了一个generator：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>L = [x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>L</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>, <span class="number">36</span>, <span class="number">49</span>, <span class="number">64</span>, <span class="number">81</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x1022ef630</span>&gt;</span><br></pre></td></tr></table></figure>

<p>创建<code>L</code>和<code>g</code>的区别仅在于最外层的<code>[]</code>和<code>()</code>，<code>L</code>是一个list，而<code>g</code>是一个generator。</p>
<p>我们创建一个generator后，基本上永远不会调用<code>next()</code>，而是通过<code>for</code>循环来迭代它，并且不需要关心<code>StopIteration</code>的错误。generator也是可迭代对象，可以用for循环。</p>
<p>11.练习题</p>
<p>1）上面提到了许多魔法方法，如<code>__new__</code>,<code>__init__</code>, <code>__str__</code>,<code>__rstr__</code>,<code>__getitem__</code>,  <code>__setitem__</code>等等，请总结它们各自的使用方法。</p>
<p><code>__new__</code> 在一个对象实例化的时候所调用的第一个方法，在调用<code>__init__</code>初始化前，先调用<code>__new__</code>。</p>
<p><code>__init__</code>构造器，当一个实例被创建的时候调用的初始化方法。 </p>
<p><code>__str__</code> 当你打印一个对象的时候；当你使用%s格式化的时候；str强转数据类型的时候。返回结果可读性强。</p>
<p><code>__repr__</code>有str的时候执行str，没有实现str的时候，执行repr。返回结果应更准确。</p>
<p><code>__getitem__</code>定义获取容器中元素的行为，相当于<code>self[key]</code>。</p>
<p><code>__setitem__</code> 定义设置容器中指定元素的行为，相当于<code>self[key] = value</code>。</p>
<p>2）利用python做一个简单的定时器类</p>
<p>要求:</p>
<ul>
<li>定制一个计时器的类。</li>
<li><code>start</code>和<code>stop</code>方法代表启动计时和停止计时。</li>
<li>假设计时器对象<code>t1</code>，<code>print(t1)</code>和直接调用<code>t1</code>均显示结果。</li>
<li>当计时器未启动或已经停止计时时，调用<code>stop</code>方法会给予温馨的提示。</li>
<li>两个计时器对象可以进行相加：<code>t1+t2</code>。</li>
<li>只能使用提供的有限资源完成。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeTest</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.starttime = <span class="number">0</span></span><br><span class="line">        self.endtime = <span class="number">0</span></span><br><span class="line">        self.total = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""返回一个对象的描述信息"""</span></span><br><span class="line"><span class="comment">#         return "计时结果：%s" % (self.endtime - self.starttime).seconds</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"计时结果：%s"</span> % (self.total)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self,other)</span>:</span></span><br><span class="line">        together = self.total+other.total</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"两次计时共：%s 秒"</span>% together</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.starttime = datetime.now()</span><br><span class="line">        print(self.starttime)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.starttime==<span class="number">0</span>:</span><br><span class="line">            print(<span class="string">'请先调用 start() 开始计时！'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.endtime = datetime.now()</span><br><span class="line">            print(self.endtime)</span><br><span class="line">            self.total = (self.endtime - self.starttime).total_seconds()</span><br><span class="line">            <span class="comment"># 结束后立马重新初始化变量，可以实现，重复计时</span></span><br><span class="line">            self.starttime = <span class="number">0</span></span><br><span class="line">            self.endtime = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">t1 = TimeTest()</span><br><span class="line">print(t1)</span><br><span class="line">t1.stop()</span><br><span class="line">t1.start()</span><br><span class="line"></span><br><span class="line">t2 = TimeTest()</span><br><span class="line">print(t2)</span><br><span class="line">t2.start()</span><br><span class="line"></span><br><span class="line">t1.stop()</span><br><span class="line">print(t1)</span><br><span class="line"></span><br><span class="line">t2.stop()</span><br><span class="line">print(t2)</span><br><span class="line"></span><br><span class="line">t1+t2</span><br></pre></td></tr></table></figure>

<p>借鉴优化改进版本，参考：<a href="https://www.zybuluo.com/kingwhite/note/136684" target="_blank" rel="noopener">https://www.zybuluo.com/kingwhite/note/136684</a></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time <span class="keyword">as</span> t</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimeCount</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.unit = [<span class="string">'年'</span>,  <span class="string">'月'</span>,  <span class="string">'天'</span>,  <span class="string">'小时'</span>,  <span class="string">'分钟'</span>,  <span class="string">'秒'</span>]</span><br><span class="line">        self.begin = <span class="number">0</span></span><br><span class="line">        self.end = <span class="number">0</span></span><br><span class="line">        self.ret = <span class="string">'未开始计时'</span></span><br><span class="line">        self.temp = <span class="number">0</span></span><br><span class="line">        self.time = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.ret</span><br><span class="line">    __repr__ = __str__</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self,  other)</span>:</span></span><br><span class="line">        tem = self.temp + other.temp</span><br><span class="line">        ret = <span class="string">'总共运行了'</span></span><br><span class="line">        secs = tem % <span class="number">60</span></span><br><span class="line">        minites = int((tem - secs) // <span class="number">60</span>) % <span class="number">60</span></span><br><span class="line">        hours = int((tem - minites * <span class="number">60</span> - secs) // <span class="number">3600</span>) % <span class="number">24</span> </span><br><span class="line">        days = int((tem - hours * <span class="number">3600</span> - minites * <span class="number">60</span> - secs) // <span class="number">86400</span>) % <span class="number">30</span></span><br><span class="line">        months = int((tem - days * <span class="number">86400</span> - hours * <span class="number">3600</span> - minites * <span class="number">60</span> - secs) // <span class="number">2592000</span>) % <span class="number">12</span></span><br><span class="line">        years = int((tem - months * <span class="number">2592000</span> - days * <span class="number">86400</span> - hours * <span class="number">3600</span> - minites * <span class="number">60</span> - secs) // <span class="number">31104000</span>)</span><br><span class="line">        temp = [years,  months,  days,  hours,  minites,  secs]</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">            <span class="keyword">if</span> temp[index]:</span><br><span class="line">                ret += (str(temp[index]) + self.unit[index])</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.begin = t.time()</span><br><span class="line">        self.ret = <span class="string">'请先调用 stop() 停止计时！'</span></span><br><span class="line">        print(<span class="string">'计时开始！'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">stop</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.begin:</span><br><span class="line">            print(<span class="string">'请先调用 start() 开始计时！'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.end = t.time()</span><br><span class="line">            self.__calc()</span><br><span class="line">            print(<span class="string">'计时停止！'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__calc</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.time = []</span><br><span class="line">        self.ret = <span class="string">'总共运行了'</span></span><br><span class="line">        self.temp = self.end - self.begin</span><br><span class="line">        secs = self.temp % <span class="number">60</span></span><br><span class="line">        minites = int((self.temp - secs) // <span class="number">60</span>) % <span class="number">60</span></span><br><span class="line">        hours = int((self.temp - minites * <span class="number">60</span> - secs) // <span class="number">3600</span>) % <span class="number">24</span> </span><br><span class="line">        days = int((self.temp - hours * <span class="number">3600</span> - minites * <span class="number">60</span> - secs) // <span class="number">86400</span>) % <span class="number">30</span></span><br><span class="line">        months = int((self.temp - days * <span class="number">86400</span> - hours * <span class="number">3600</span> - minites * <span class="number">60</span> - secs) // <span class="number">2592000</span>) % <span class="number">12</span></span><br><span class="line">        years = int((self.temp - months * <span class="number">2592000</span> - days * <span class="number">86400</span> - hours * <span class="number">3600</span> - minites * <span class="number">60</span> - secs) // <span class="number">31104000</span>)</span><br><span class="line">        tem = [years,  months,  days,  hours,  minites,  secs]</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">            self.time.append(tem[index])</span><br><span class="line">            <span class="keyword">if</span> self.time[index]:</span><br><span class="line">                self.ret += (str(self.time[index]) + self.unit[index])</span><br><span class="line">        self.begin = <span class="number">0</span></span><br><span class="line">        self.end = <span class="number">0</span></span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/05/Python-Task07/" data-id="ckdhise3o0000h4wc0n7l0fdg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/08/07/Python-Task08/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Python-Task08
        
      </div>
    </a>
  
  
    <a href="/2020/08/04/NLP-Task06/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">NLP-Task06</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/08/25/Leetcode-Task03/">Leetcode-Task03</a>
          </li>
        
          <li>
            <a href="/2020/08/23/Leetcode-Task02/">Leetcode-Task02</a>
          </li>
        
          <li>
            <a href="/2020/08/19/Leetcode-Task01/">Leetcode-Task01</a>
          </li>
        
          <li>
            <a href="/2020/08/07/Python-Task09/">Python-Task09</a>
          </li>
        
          <li>
            <a href="/2020/08/07/Python-Task08/">Python-Task08</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>