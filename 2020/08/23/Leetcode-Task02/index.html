<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Leetcode-Task02 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Leetcode编程-Task02Task 2:动态规划动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解 法。 1.主要思想 若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。动 态规划往往用于优化递归问题，例如斐波那契数列，如果运用递归的方式来求解会重复计算很多相同的 子问题，利用动态规划的思想可以减少计算量。 动态">
<meta property="og:type" content="article">
<meta property="og:title" content="Leetcode-Task02">
<meta property="og:url" content="http://yoursite.com/2020/08/23/Leetcode-Task02/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Leetcode编程-Task02Task 2:动态规划动态规划常常适用于有重叠子问题和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解 法。 1.主要思想 若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。动 态规划往往用于优化递归问题，例如斐波那契数列，如果运用递归的方式来求解会重复计算很多相同的 子问题，利用动态规划的思想可以减少计算量。 动态">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/8/15/16c95abdd02f2886?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/8/15/16c95abdd0316e49?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/8/15/16c95abdd13d8a9e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F6b54539705dc61842749cf10bfa80e367c912664.png?alt=media">
<meta property="og:image" content="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F5381a5e30482682c1c6f111e882991113b8661f7.png?alt=media">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/8/15/16c95abdd4d29a1a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="og:image" content="https://user-gold-cdn.xitu.io/2019/8/15/16c95abdfb407337?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
<meta property="article:published_time" content="2020-08-23T08:34:54.000Z">
<meta property="article:modified_time" content="2020-08-24T14:48:32.039Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://user-gold-cdn.xitu.io/2019/8/15/16c95abdd02f2886?imageView2/0/w/1280/h/960/format/webp/ignore-error/1">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Leetcode-Task02" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/23/Leetcode-Task02/" class="article-date">
  <time datetime="2020-08-23T08:34:54.000Z" itemprop="datePublished">2020-08-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Leetcode-Task02
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Leetcode编程-Task02"><a href="#Leetcode编程-Task02" class="headerlink" title="Leetcode编程-Task02"></a>Leetcode编程-Task02</h1><h2 id="Task-2-动态规划"><a href="#Task-2-动态规划" class="headerlink" title="Task 2:动态规划"></a>Task 2:动态规划</h2><p>动态规划常常适用于<strong>有重叠子问题</strong>和<strong>最优子结构</strong>性质的问题，动态规划方法<strong>所耗时间往往远少于朴素解</strong></p>
<p><strong>法</strong>。</p>
<p><strong>1.主要思想</strong></p>
<p>若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。动</p>
<p>态规划往往用于优化递归问题，例如斐波那契数列，如果运用递归的方式来求解会重复计算很多相同的</p>
<p>子问题，利用动态规划的思想可以减少计算量。</p>
<p>动态规划法仅仅解决每个子问题一次，具有天然剪枝的功能，从而减少计算量，</p>
<p>一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。</p>
<p><strong>2.动态规划模板步骤：</strong></p>
<p>确定动态规划状态</p>
<p>写出状态转移方程（画出状态转移表）</p>
<p>考虑初始化条件</p>
<p>考虑输出状态</p>
<p>考虑对时间，空间复杂度的优化（Bonus）</p>
<p>3.具体来说，动态规划的一般流程就是三步：<strong>暴力的递归解法 -&gt; 带备忘录的递归解法 -&gt; 迭代的动态规划解法</strong>。</p>
<p>就思考流程来说，就分为一下几步：<strong>找到状态和选择 -&gt; 明确 dp 数组/函数的定义 -&gt; 寻找状态之间的关系</strong>。</p>
<p>4.动态规划法与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。</p>
<p>能采用动态规划求解的问题的一般要具有3个性质：</p>
<p>  (1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</p>
<p>  (2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p>
<p>  （3）有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</p>
<p>5.动态规划解题套路框架</p>
<p><strong>首先，动态规划问题的一般形式就是求最值</strong>。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求<strong>最长</strong>递增子序列呀，<strong>最小</strong>编辑距离呀等等。</p>
<p><strong>求解动态规划的核心问题是穷举</strong>。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。</p>
<p>首先，动态规划的穷举有点特别，因为这类问题<strong>存在「重叠子问题」</strong>，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。</p>
<p>而且，动态规划问题一定会<strong>具备「最优子结构」</strong>，才能通过子问题的最值得到原问题的最值。</p>
<p>另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出<strong>正确的「状态转移方程」</strong>才能正确地穷举。</p>
<p>以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。但是在实际的算法问题中，<strong>写出状态转移方程是最困难的</strong>，这也就是为什么很多朋友觉得动态规划问题困难的原因，这里提供一个思维框架，辅助你思考状态转移方程：</p>
<p><strong>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组/函数的含义</strong>。</p>
<p>按上面的套路走，最后的结果就可以套这个框架：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 初始化 base case</span><br><span class="line">dp[0][0][...] &#x3D; base</span><br><span class="line"># 进行状态转移</span><br><span class="line">for 状态1 in 状态1的所有取值：</span><br><span class="line">    for 状态2 in 状态2的所有取值：</span><br><span class="line">        for ...</span><br><span class="line">            dp[状态1][状态2][...] &#x3D; 求最值(选择1，选择2...)</span><br></pre></td></tr></table></figure>

<p>下面通过斐波那契数列问题和凑零钱问题来详解动态规划的基本原理。前者主要是让你明白什么是重叠子问题（斐波那契数列没有求最值，所以严格来说不是动态规划问题），后者主要集中于如何列出状态转移方程。</p>
<p>（1）斐波那契数列</p>
<p><strong>1、暴力递归</strong></p>
<p>斐波那契数列的数学形式就是递归的，写成代码就是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int fib(int N) &#123;</span><br><span class="line">    if (N &#x3D;&#x3D; 1 || N &#x3D;&#x3D; 2) return 1;</span><br><span class="line">    return fib(N - 1) + fib(N - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归法       O(2^n)</span></span><br><span class="line"><span class="comment"># T(n) = T(n-2) + T(n-1)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-2</span>)+fib(n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>

<p>假设 n = 20，画出递归树：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/15/16c95abdd02f2886?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="递归树"></p>
<p>这个递归树怎么理解？就是说想要计算原问题 <code>f(20)</code>，我就得先计算出子问题 <code>f(19)</code> 和 <code>f(18)</code>，然后要计算 <code>f(19)</code>，我就要先算出子问题 <code>f(18)</code> 和 <code>f(17)</code>，以此类推。最后遇到 <code>f(1)</code> 或者 <code>f(2)</code> 的时候，结果已知，就能直接返回结果，递归树不再向下生长了。</p>
<p><strong>递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间。</strong></p>
<p>首先计算子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。</p>
<p>然后计算解决一个子问题的时间，在本算法中，没有循环，只有 <code>f(n - 1) + f(n - 2)</code> 一个加法操作，时间为 O(1)。</p>
<p>所以，这个算法的时间复杂度为二者相乘，即 O(2^n)，指数级别。</p>
<p>观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 <code>f(18)</code> 被计算了两次，而且你可以看到，以 <code>f(18)</code> 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 <code>f(18)</code> 这一个节点被重复计算，所以这个算法及其低效。</p>
<p>这就是动态规划问题的第一个性质：<strong>重叠子问题</strong>。下面，我们想办法解决这个问题。</p>
<p><strong>2、带备忘录的递归解法</strong></p>
<p>既然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。</p>
<p>一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int fib(int N) &#123;</span><br><span class="line">    if (N &lt; 1) return 0;</span><br><span class="line">    &#x2F;&#x2F; 备忘录全初始化为 0</span><br><span class="line">    vector&lt;int&gt; memo(N + 1, 0);</span><br><span class="line">    &#x2F;&#x2F; 进行带备忘录的递归</span><br><span class="line">    return helper(memo, N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int helper(vector&lt;int&gt;&amp; memo, int n) &#123;</span><br><span class="line">    &#x2F;&#x2F; base case </span><br><span class="line">    if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) return 1;</span><br><span class="line">    &#x2F;&#x2F; 已经计算过</span><br><span class="line">    if (memo[n] !&#x3D; 0) return memo[n];</span><br><span class="line">    memo[n] &#x3D; helper(memo, n - 1) + helper(memo, n - 2);</span><br><span class="line">    return memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，画出递归树，你就知道「备忘录」到底做了什么。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/15/16c95abdd0316e49?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="备忘录">实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。</p>
<p><strong>递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间。</strong></p>
<p>子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 <code>f(1)</code>, <code>f(2)</code>, <code>f(3)</code> … <code>f(20)</code>，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。</p>
<p>解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。</p>
<p>所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。</p>
<p>至此，带备忘录的递归解法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和迭代的动态规划已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。</p>
<p>啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 <code>f(20)</code>，向下逐渐分解规模，直到 <code>f(1)</code> 和 <code>f(2)</code> 这两个 base case，然后逐层返回答案，这就叫「自顶向下」。</p>
<p>啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 <code>f(1)</code> 和 <code>f(2)</code> 开始往上推，直到推到我们想要的答案 <code>f(20)</code>，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。</p>
<p><strong>3、dp 数组的迭代解法</strong></p>
<p>有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，就叫做 DP table 吧，在这张表上完成「自底向上」的推算岂不美哉！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int fib(int N) &#123;</span><br><span class="line">    vector&lt;int&gt; dp(N + 1, 0);</span><br><span class="line">    &#x2F;&#x2F; base case</span><br><span class="line">    dp[1] &#x3D; dp[2] &#x3D; 1;</span><br><span class="line">    for (int i &#x3D; 3; i &lt;&#x3D; N; i++)</span><br><span class="line">        dp[i] &#x3D; dp[i - 1] + dp[i - 2];</span><br><span class="line">    return dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 改进版本  存一个数组,循环得到      O(n)</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    tmp = np.zeros(n)</span><br><span class="line">    tmp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    tmp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">        tmp[i] = tmp[i<span class="number">-2</span>] + tmp[i<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> tmp[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2019/8/15/16c95abdd13d8a9e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img">画个图就很好理解了，而且你发现这个 DP table 特别像之前那个「剪枝」后的结果，只是反过来算而已。实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。</p>
<p>这里，引出「状态转移方程」这个名词，实际上就是描述问题结构的数学形式：</p>
<p><img src="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F6b54539705dc61842749cf10bfa80e367c912664.png?alt=media" alt="img"></p>
<p>为啥叫「状态转移方程」？其实就是为了听起来高端。你把 <code>f(n)</code> 想做一个状态 <code>n</code>，这个状态 <code>n</code> 是由状态 <code>n - 1</code> 和状态 <code>n - 2</code> 相加转移而来，这就叫状态转移，仅此而已。</p>
<p>你会发现，上面的几种解法中的所有操作，例如 <code>return f(n - 1) + f(n - 2)</code>，<code>dp[i] = dp[i - 1] + dp[i - 2]</code>，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。可见列出「状态转移方程」的重要性，它是解决问题的核心。而且很容易发现，其实状态转移方程直接代表着暴力解法。</p>
<p><strong>千万不要看不起暴力解，动态规划问题最困难的就是写出这个暴力解，即状态转移方程</strong>。只要写出暴力解，优化方法无非是用备忘录或者 DP table，再无奥妙可言。</p>
<p>这个例子的最后，讲一个细节优化。根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int fib(int n) &#123;</span><br><span class="line">    if (n &#x3D;&#x3D; 2 || n &#x3D;&#x3D; 1) </span><br><span class="line">        return 1;</span><br><span class="line">    int prev &#x3D; 1, curr &#x3D; 1;</span><br><span class="line">    for (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        int sum &#x3D; prev + curr;</span><br><span class="line">        prev &#x3D; curr;</span><br><span class="line">        curr &#x3D; sum;</span><br><span class="line">    &#125;</span><br><span class="line">    return curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进一步改进版本</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    a,b = <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">        c = a+b</span><br><span class="line">        a = b</span><br><span class="line">        b = c</span><br><span class="line">    <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure>

<p>这个技巧就是所谓的「<strong>状态压缩</strong>」，如果我们发现每次状态转移只需要 DP table 中的一部分，那么可以尝试用状态压缩来缩小 DP table 的大小，只记录必要的数据，上述例子就相当于把DP table 的大小从 <code>n</code> 缩小到 2。一般来说是把一个二维的 DP table 压缩成一维，即把空间复杂度从 O(n^2) 压缩到 O(n)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 还有更简便的方法，怎么在O(1)的时间复杂度下计算fib(n)?    套公式</span></span><br><span class="line"><span class="comment"># 通项公式求解</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    denominator = math.sqrt(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> int((np.power((<span class="number">1</span>+denominator)/<span class="number">2</span>, n) - np.power((<span class="number">1</span>-denominator)/<span class="number">2</span>, n)) / denominator)</span><br><span class="line"></span><br><span class="line">print(fib(<span class="number">7</span>))</span><br></pre></td></tr></table></figure>

<p>斐波那契数列的例子严格来说不算动态规划，因为没有涉及求最值，所以没有「最优子结构」，以上旨在说明重叠子问题的消除方法，演示得到最优解法逐步求精的过程。下面，看第二个例子，凑零钱问题。</p>
<p>（2）凑零钱问题</p>
<p>先看下题目：给你 <code>k</code> 种面值的硬币，面值分别为 <code>c1, c2 ... ck</code>，每种硬币的数量无限，再给一个总金额 <code>amount</code>，问你<strong>最少</strong>需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。算法的函数签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; coins 中是可选硬币面值，amount 是目标金额</span><br><span class="line">int coinChange(int[] coins, int amount);</span><br></pre></td></tr></table></figure>

<p>比如说 <code>k = 3</code>，面值分别为 1，2，5，总金额 <code>amount = 11</code>。那么最少需要 3 枚硬币凑出，即 11 = 5 + 5 + 1。</p>
<p>最先能想到的方法，就是把所有可能的凑硬币方法都穷举出来，然后找找看最少需要多少枚硬币。</p>
<p><strong>1、暴力递归</strong></p>
<p>首先，这个问题是动态规划问题，因为它具有「最优子结构」的。<strong>要符合「最优子结构」，子问题间必须互相独立</strong>。啥叫相互独立？就是子问题是互相独立，互不干扰的。</p>
<p>但是，如果加一个条件：一个子问题和另一个子问题会互相制约，这样的话，因为子问题并不独立，两个子问题无法同时最优，所以最优子结构被破坏。</p>
<p>回到凑零钱问题，为什么说它符合最优子结构呢？比如你想求 <code>amount = 11</code> 时的最少硬币数（原问题），如果你知道凑出 <code>amount = 10</code> 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。</p>
<p>那么，既然知道了这是个动态规划问题，就要思考<strong>如何列出正确的状态转移方程</strong>？</p>
<p>1、<strong>确定 base case</strong>，这个很简单，显然目标金额 <code>amount</code> 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。</p>
<p>2、<strong>确定「状态」，也就是原问题和子问题中会变化的变量</strong>。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 <code>amount</code>。</p>
<p>3、<strong>确定「选择」，也就是导致「状态」产生变化的行为</strong>。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。</p>
<p>4、<strong>明确</strong> <strong><code>dp</code></strong> <strong>函数/数组的定义</strong>。我们这里讲的是自顶向下的解法，所以会有一个递归的 <code>dp</code> 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。所以我们可以这样定义 <code>dp</code> 函数：</p>
<p><code>dp(n)</code> 的定义：输入一个目标金额 <code>n</code>，返回凑出目标金额 <code>n</code> 的最少硬币数量。</p>
<p>搞清楚上面这几个关键点，解法的伪码就可以写出来了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 伪码框架</span><br><span class="line">def coinChange(coins: List[int], amount: int):</span><br><span class="line"></span><br><span class="line">    # 定义：要凑出金额 n，至少要 dp(n) 个硬币</span><br><span class="line">    def dp(n):</span><br><span class="line">        # 做选择，选择需要硬币最少的那个结果</span><br><span class="line">        for coin in coins:</span><br><span class="line">            res &#x3D; min(res, 1 + dp(n - coin))</span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line">    # 题目要求的最终结果是 dp(amount)</span><br><span class="line">    return dp(amount)</span><br></pre></td></tr></table></figure>

<p>根据伪码，我们加上 base case 即可得到最终的答案。显然目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回 -1：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ncount = <span class="number">0</span>   <span class="comment"># 记录进入求min的次数</span></span><br><span class="line">ncount1 = <span class="number">0</span>   <span class="comment"># 记录实际处理的子问题数量</span></span><br><span class="line"><span class="comment"># def coinChange(coins, amount):</span></span><br><span class="line">coins = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">amount = <span class="number">18</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> ncount</span><br><span class="line">    ncount += <span class="number">1</span>   <span class="comment"># 实际进入求min，但是如果n为0或1，能直接返回结果，就不会再进入下一级子问题了。</span></span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="comment"># 求最小值，所以初始化为正无穷</span></span><br><span class="line">    res = float(<span class="string">'INF'</span>)</span><br><span class="line">    <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">        subproblem = dp(n - coin)</span><br><span class="line">        <span class="comment"># 子问题无解，跳过</span></span><br><span class="line">        <span class="keyword">if</span> subproblem == <span class="number">-1</span>: <span class="keyword">continue</span></span><br><span class="line">        res = min(res, <span class="number">1</span> + subproblem)</span><br><span class="line">    <span class="keyword">global</span> ncount1</span><br><span class="line">    ncount1 += <span class="number">1</span>       <span class="comment"># 上面没有return，就代表实际进入子问题的求解了。</span></span><br><span class="line">    <span class="keyword">return</span> res <span class="keyword">if</span> res != float(<span class="string">'INF'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">print(dp(amount))</span><br><span class="line">print(ncount)</span><br><span class="line">print(ncount1)</span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># 38869  # 子问题个数</span></span><br><span class="line"><span class="comment"># 12956</span></span><br></pre></td></tr></table></figure>

<p>至此，状态转移方程其实已经完成了，以上算法已经是暴力解法了，以上代码的数学形式就是状态转移方程：</p>
<p><img src="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F5381a5e30482682c1c6f111e882991113b8661f7.png?alt=media" alt="img"></p>
<p>至此，这个问题其实就解决了，只不过需要消除一下重叠子问题，比如 <code>amount = 11, coins = {1,2,5}</code> 时画出递归树看看：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/15/16c95abdd4d29a1a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><strong>递归算法的时间复杂度分析：子问题总数 x 每个子问题的时间</strong>。</p>
<p><strong>时间复杂度:</strong></p>
<ul>
<li><p>子问题总数为递归树节点个数</p>
<p>这里不止涉及到了递归，还涉及到了遍历size为<strong>k</strong>数组的， 就这个问题而言,按照最坏的情况来算，假设每一个子问题都会分裂<strong>k份</strong>，那么所有子问题的个数就是<strong>O(k^n)</strong>，指数级别。由以上代码可知，所有子节点(子问题)个数是38869个，走到计算 求和+比较min 的部分有12956次，其他是n=0或n=-1的节点。</p>
</li>
<li><p>解决一个子问题所需的时间</p>
<p>size为<strong>k</strong>的循环中，存在<strong>一次加法</strong>，和<strong>一次min对比</strong>计算，所以最多有<strong>2*k=2k</strong>次运算.</p>
</li>
</ul>
<p>所以，时间复杂度就是<strong>O(k^n)</strong>x<strong>2k</strong> = <strong>O(2*k^(n+1)）。指数级别的时间复杂度。</strong></p>
<p><strong>空间复杂度：</strong></p>
<p>由于没有数据保存，一律认为空间复杂度是<strong>O(1)</strong></p>
<p><strong>2、带备忘录的递归</strong></p>
<p>类似之前斐波那契数列的例子，只需要稍加修改，就可以通过备忘录消除子问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ncount = <span class="number">0</span>   <span class="comment"># 记录进入求min的次数</span></span><br><span class="line">ncount1 = <span class="number">0</span>   <span class="comment"># 记录实际处理的子问题数量</span></span><br><span class="line"><span class="comment"># def coinChange(coins, amount):</span></span><br><span class="line">coins = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">amount = <span class="number">18</span></span><br><span class="line">memo = dict()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> ncount   </span><br><span class="line">    ncount += <span class="number">1</span>   <span class="comment"># 实际进入求min，但是如果能直接找到结果，就不会再进入下一级子问题了。</span></span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> memo:<span class="keyword">return</span> memo[n]</span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="comment"># 求最小值，所以初始化为正无穷</span></span><br><span class="line">    res = float(<span class="string">'INF'</span>)</span><br><span class="line">    <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">        <span class="comment"># 实际进入求min</span></span><br><span class="line">        subproblem = dp(n - coin)</span><br><span class="line">        <span class="comment"># 子问题无解，跳过</span></span><br><span class="line">        <span class="keyword">if</span> subproblem == <span class="number">-1</span>: <span class="keyword">continue</span></span><br><span class="line">        res = min(res, <span class="number">1</span> + subproblem)</span><br><span class="line">    memo[n] = res <span class="keyword">if</span> res != float(<span class="string">'INF'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">global</span> ncount1</span><br><span class="line">    ncount1 += <span class="number">1</span>    <span class="comment"># 上面没有return，就代表实际进入子问题的求解了。</span></span><br><span class="line">    <span class="keyword">return</span> memo[n]</span><br><span class="line"></span><br><span class="line">print(<span class="string">"凑出目标金额 %d 的最少硬币数量:%d"</span> %(amount,dp(amount)))</span><br><span class="line">print(<span class="string">"实际处理的子问题数量:"</span>, ncount1)</span><br><span class="line">print(<span class="string">"因为每个实际计算的子问题需要遍历k次，实际处理的子问题循环的数量:"</span>, ncount)</span><br><span class="line"><span class="comment"># 凑出目标金额18的最少硬币数量:5</span></span><br><span class="line"><span class="comment"># 实际处理的子问题数量: 18</span></span><br><span class="line"><span class="comment"># 因为每个实际计算的子问题需要遍历k次，实际处理的子问题循环的数量：55</span></span><br></pre></td></tr></table></figure>

<p>很显然「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 <code>n</code>，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 2k，所以总的时间复杂度是 O(kn)。</p>
<p><strong>3、dp 数组的迭代解法</strong></p>
<p>当然，我们也可以自底向上使用 dp table 来消除重叠子问题，关于「状态」「选择」和 base case 与之前没有区别，<code>dp</code> 数组的定义和刚才 <code>dp</code> 函数类似，也是把「状态」，也就是目标金额作为变量。不过 <code>dp</code> 函数体现在函数参数，而 <code>dp</code> 数组体现在数组索引：</p>
<p><strong><code>dp</code></strong> <strong>数组的定义：当目标金额为</strong> <strong><code>i</code></strong> <strong>时，至少需要</strong> <strong><code>dp[i]</code></strong> <strong>枚硬币凑出</strong>。</p>
<p>根据我们文章开头给出的动态规划代码框架可以写出如下解法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(coins, amount)</span>:</span></span><br><span class="line">    <span class="comment"># 数组大小为 amount + 1，初始值也为 amount + 1</span></span><br><span class="line">    dp = [amount+<span class="number">1</span>]*(amount+<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 外层 for 循环在遍历所有状态的所有取值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(amount+<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 内层 for 循环在求所有选择的最小值</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="comment"># 子问题无解，跳过</span></span><br><span class="line">            <span class="keyword">if</span> i-coin &lt; <span class="number">0</span>: </span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            dp[i] = min(dp[i], dp[i-coin]+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != (amount+<span class="number">1</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">print(coinChange([<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>],<span class="number">18</span>))</span><br><span class="line"><span class="comment"># 5</span></span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2019/8/15/16c95abdfb407337?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img">PS：为啥 <code>dp</code> 数组初始化为 <code>amount + 1</code> 呢，因为凑成 <code>amount</code> 金额的硬币数最多只可能等于 <code>amount</code>（全用 1 元面值的硬币），所以初始化为 <code>amount + 1</code> 就相当于初始化为正无穷，便于后续取最小值。</p>
<p>（3）最后总结</p>
<p>第一个斐波那契数列的问题，解释了如何通过「备忘录」或者「dp table」的方法来优化递归树，并且明确了这两种方法本质上是一样的，只是自顶向下和自底向上的不同而已。</p>
<p>第二个凑零钱的问题，展示了如何流程化确定「状态转移方程」，只要通过状态转移方程写出暴力递归解，剩下的也就是优化递归树，消除重叠子问题而已。</p>
<p><strong>计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举</strong>，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。</p>
<p>列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。</p>
<p>备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/23/Leetcode-Task02/" data-id="cke6vrf2i0000rwwc8bcv9soi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/08/25/Leetcode-Task03/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Leetcode-Task03
        
      </div>
    </a>
  
  
    <a href="/2020/08/19/Leetcode-Task01/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Leetcode-Task01</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/08/25/Leetcode-Task03/">Leetcode-Task03</a>
          </li>
        
          <li>
            <a href="/2020/08/23/Leetcode-Task02/">Leetcode-Task02</a>
          </li>
        
          <li>
            <a href="/2020/08/19/Leetcode-Task01/">Leetcode-Task01</a>
          </li>
        
          <li>
            <a href="/2020/08/07/Python-Task09/">Python-Task09</a>
          </li>
        
          <li>
            <a href="/2020/08/07/Python-Task08/">Python-Task08</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>