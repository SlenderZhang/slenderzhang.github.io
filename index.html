<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Leetcode-Task02" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/23/Leetcode-Task02/" class="article-date">
  <time datetime="2020-08-23T08:34:54.000Z" itemprop="datePublished">2020-08-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/23/Leetcode-Task02/">Leetcode-Task02</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Leetcode编程-Task02"><a href="#Leetcode编程-Task02" class="headerlink" title="Leetcode编程-Task02"></a>Leetcode编程-Task02</h1><h2 id="Task-2-动态规划"><a href="#Task-2-动态规划" class="headerlink" title="Task 2:动态规划"></a>Task 2:动态规划</h2><p>动态规划常常适用于<strong>有重叠子问题</strong>和<strong>最优子结构</strong>性质的问题，动态规划方法<strong>所耗时间往往远少于朴素解</strong></p>
<p><strong>法</strong>。</p>
<p><strong>1.主要思想</strong></p>
<p>若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。动</p>
<p>态规划往往用于优化递归问题，例如斐波那契数列，如果运用递归的方式来求解会重复计算很多相同的</p>
<p>子问题，利用动态规划的思想可以减少计算量。</p>
<p>动态规划法仅仅解决每个子问题一次，具有天然剪枝的功能，从而减少计算量，</p>
<p>一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。</p>
<p><strong>2.动态规划模板步骤：</strong></p>
<p>确定动态规划状态</p>
<p>写出状态转移方程（画出状态转移表）</p>
<p>考虑初始化条件</p>
<p>考虑输出状态</p>
<p>考虑对时间，空间复杂度的优化（Bonus）</p>
<p>3.具体来说，动态规划的一般流程就是三步：<strong>暴力的递归解法 -&gt; 带备忘录的递归解法 -&gt; 迭代的动态规划解法</strong>。</p>
<p>就思考流程来说，就分为一下几步：<strong>找到状态和选择 -&gt; 明确 dp 数组/函数的定义 -&gt; 寻找状态之间的关系</strong>。</p>
<p>4.动态规划法与分治法最大的差别是：适合于用动态规划法求解的问题，经分解后得到的子问题往往不是互相独立的（即下一个子阶段的求解是建立在上一个子阶段的解的基础上，进行进一步的求解）。</p>
<p>能采用动态规划求解的问题的一般要具有3个性质：</p>
<p>  (1) 最优化原理：如果问题的最优解所包含的子问题的解也是最优的，就称该问题具有最优子结构，即满足最优化原理。</p>
<p>  (2) 无后效性：即某阶段状态一旦确定，就不受这个状态以后决策的影响。也就是说，某状态以后的过程不会影响以前的状态，只与当前状态有关。</p>
<p>  （3）有重叠子问题：即子问题之间是不独立的，一个子问题在下一阶段决策中可能被多次使用到。（该性质并不是动态规划适用的必要条件，但是如果没有这条性质，动态规划算法同其他算法相比就不具备优势）</p>
<p>5.动态规划解题套路框架</p>
<p><strong>首先，动态规划问题的一般形式就是求最值</strong>。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求<strong>最长</strong>递增子序列呀，<strong>最小</strong>编辑距离呀等等。</p>
<p><strong>求解动态规划的核心问题是穷举</strong>。因为要求最值，肯定要把所有可行的答案穷举出来，然后在其中找最值呗。</p>
<p>首先，动态规划的穷举有点特别，因为这类问题<strong>存在「重叠子问题」</strong>，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。</p>
<p>而且，动态规划问题一定会<strong>具备「最优子结构」</strong>，才能通过子问题的最值得到原问题的最值。</p>
<p>另外，虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，只有列出<strong>正确的「状态转移方程」</strong>才能正确地穷举。</p>
<p>以上提到的重叠子问题、最优子结构、状态转移方程就是动态规划三要素。但是在实际的算法问题中，<strong>写出状态转移方程是最困难的</strong>，这也就是为什么很多朋友觉得动态规划问题困难的原因，这里提供一个思维框架，辅助你思考状态转移方程：</p>
<p><strong>明确 base case -&gt; 明确「状态」-&gt; 明确「选择」 -&gt; 定义 dp 数组/函数的含义</strong>。</p>
<p>按上面的套路走，最后的结果就可以套这个框架：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 初始化 base case</span><br><span class="line">dp[0][0][...] &#x3D; base</span><br><span class="line"># 进行状态转移</span><br><span class="line">for 状态1 in 状态1的所有取值：</span><br><span class="line">    for 状态2 in 状态2的所有取值：</span><br><span class="line">        for ...</span><br><span class="line">            dp[状态1][状态2][...] &#x3D; 求最值(选择1，选择2...)</span><br></pre></td></tr></table></figure>

<p>下面通过斐波那契数列问题和凑零钱问题来详解动态规划的基本原理。前者主要是让你明白什么是重叠子问题（斐波那契数列没有求最值，所以严格来说不是动态规划问题），后者主要集中于如何列出状态转移方程。</p>
<p>（1）斐波那契数列</p>
<p><strong>1、暴力递归</strong></p>
<p>斐波那契数列的数学形式就是递归的，写成代码就是这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int fib(int N) &#123;</span><br><span class="line">    if (N &#x3D;&#x3D; 1 || N &#x3D;&#x3D; 2) return 1;</span><br><span class="line">    return fib(N - 1) + fib(N - 2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 递归法       O(2^n)</span></span><br><span class="line"><span class="comment"># T(n) = T(n-2) + T(n-1)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-2</span>)+fib(n<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>

<p>假设 n = 20，画出递归树：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/15/16c95abdd02f2886?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="递归树"></p>
<p>这个递归树怎么理解？就是说想要计算原问题 <code>f(20)</code>，我就得先计算出子问题 <code>f(19)</code> 和 <code>f(18)</code>，然后要计算 <code>f(19)</code>，我就要先算出子问题 <code>f(18)</code> 和 <code>f(17)</code>，以此类推。最后遇到 <code>f(1)</code> 或者 <code>f(2)</code> 的时候，结果已知，就能直接返回结果，递归树不再向下生长了。</p>
<p><strong>递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间。</strong></p>
<p>首先计算子问题个数，即递归树中节点的总数。显然二叉树节点总数为指数级别，所以子问题个数为 O(2^n)。</p>
<p>然后计算解决一个子问题的时间，在本算法中，没有循环，只有 <code>f(n - 1) + f(n - 2)</code> 一个加法操作，时间为 O(1)。</p>
<p>所以，这个算法的时间复杂度为二者相乘，即 O(2^n)，指数级别。</p>
<p>观察递归树，很明显发现了算法低效的原因：存在大量重复计算，比如 <code>f(18)</code> 被计算了两次，而且你可以看到，以 <code>f(18)</code> 为根的这个递归树体量巨大，多算一遍，会耗费巨大的时间。更何况，还不止 <code>f(18)</code> 这一个节点被重复计算，所以这个算法及其低效。</p>
<p>这就是动态规划问题的第一个性质：<strong>重叠子问题</strong>。下面，我们想办法解决这个问题。</p>
<p><strong>2、带备忘录的递归解法</strong></p>
<p>既然耗时的原因是重复计算，那么我们可以造一个「备忘录」，每次算出某个子问题的答案后别急着返回，先记到「备忘录」里再返回；每次遇到一个子问题先去「备忘录」里查一查，如果发现之前已经解决过这个问题了，直接把答案拿出来用，不要再耗时去计算了。</p>
<p>一般使用一个数组充当这个「备忘录」，当然你也可以使用哈希表（字典），思想都是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int fib(int N) &#123;</span><br><span class="line">    if (N &lt; 1) return 0;</span><br><span class="line">    &#x2F;&#x2F; 备忘录全初始化为 0</span><br><span class="line">    vector&lt;int&gt; memo(N + 1, 0);</span><br><span class="line">    &#x2F;&#x2F; 进行带备忘录的递归</span><br><span class="line">    return helper(memo, N);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int helper(vector&lt;int&gt;&amp; memo, int n) &#123;</span><br><span class="line">    &#x2F;&#x2F; base case </span><br><span class="line">    if (n &#x3D;&#x3D; 1 || n &#x3D;&#x3D; 2) return 1;</span><br><span class="line">    &#x2F;&#x2F; 已经计算过</span><br><span class="line">    if (memo[n] !&#x3D; 0) return memo[n];</span><br><span class="line">    memo[n] &#x3D; helper(memo, n - 1) + helper(memo, n - 2);</span><br><span class="line">    return memo[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，画出递归树，你就知道「备忘录」到底做了什么。</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/15/16c95abdd0316e49?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="备忘录">实际上，带「备忘录」的递归算法，把一棵存在巨量冗余的递归树通过「剪枝」，改造成了一幅不存在冗余的递归图，极大减少了子问题（即递归图中节点）的个数。</p>
<p><strong>递归算法的时间复杂度怎么计算？就是用子问题个数乘以解决一个子问题需要的时间。</strong></p>
<p>子问题个数，即图中节点的总数，由于本算法不存在冗余计算，子问题就是 <code>f(1)</code>, <code>f(2)</code>, <code>f(3)</code> … <code>f(20)</code>，数量和输入规模 n = 20 成正比，所以子问题个数为 O(n)。</p>
<p>解决一个子问题的时间，同上，没有什么循环，时间为 O(1)。</p>
<p>所以，本算法的时间复杂度是 O(n)。比起暴力算法，是降维打击。</p>
<p>至此，带备忘录的递归解法的效率已经和迭代的动态规划解法一样了。实际上，这种解法和迭代的动态规划已经差不多了，只不过这种方法叫做「自顶向下」，动态规划叫做「自底向上」。</p>
<p>啥叫「自顶向下」？注意我们刚才画的递归树（或者说图），是从上向下延伸，都是从一个规模较大的原问题比如说 <code>f(20)</code>，向下逐渐分解规模，直到 <code>f(1)</code> 和 <code>f(2)</code> 这两个 base case，然后逐层返回答案，这就叫「自顶向下」。</p>
<p>啥叫「自底向上」？反过来，我们直接从最底下，最简单，问题规模最小的 <code>f(1)</code> 和 <code>f(2)</code> 开始往上推，直到推到我们想要的答案 <code>f(20)</code>，这就是动态规划的思路，这也是为什么动态规划一般都脱离了递归，而是由循环迭代完成计算。</p>
<p><strong>3、dp 数组的迭代解法</strong></p>
<p>有了上一步「备忘录」的启发，我们可以把这个「备忘录」独立出来成为一张表，就叫做 DP table 吧，在这张表上完成「自底向上」的推算岂不美哉！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int fib(int N) &#123;</span><br><span class="line">    vector&lt;int&gt; dp(N + 1, 0);</span><br><span class="line">    &#x2F;&#x2F; base case</span><br><span class="line">    dp[1] &#x3D; dp[2] &#x3D; 1;</span><br><span class="line">    for (int i &#x3D; 3; i &lt;&#x3D; N; i++)</span><br><span class="line">        dp[i] &#x3D; dp[i - 1] + dp[i - 2];</span><br><span class="line">    return dp[N];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 改进版本  存一个数组,循环得到      O(n)</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    tmp = np.zeros(n)</span><br><span class="line">    tmp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">    tmp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">        tmp[i] = tmp[i<span class="number">-2</span>] + tmp[i<span class="number">-1</span>]</span><br><span class="line">    <span class="keyword">return</span> tmp[n<span class="number">-1</span>]</span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2019/8/15/16c95abdd13d8a9e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img">画个图就很好理解了，而且你发现这个 DP table 特别像之前那个「剪枝」后的结果，只是反过来算而已。实际上，带备忘录的递归解法中的「备忘录」，最终完成后就是这个 DP table，所以说这两种解法其实是差不多的，大部分情况下，效率也基本相同。</p>
<p>这里，引出「状态转移方程」这个名词，实际上就是描述问题结构的数学形式：</p>
<p><img src="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F6b54539705dc61842749cf10bfa80e367c912664.png?alt=media" alt="img"></p>
<p>为啥叫「状态转移方程」？其实就是为了听起来高端。你把 <code>f(n)</code> 想做一个状态 <code>n</code>，这个状态 <code>n</code> 是由状态 <code>n - 1</code> 和状态 <code>n - 2</code> 相加转移而来，这就叫状态转移，仅此而已。</p>
<p>你会发现，上面的几种解法中的所有操作，例如 <code>return f(n - 1) + f(n - 2)</code>，<code>dp[i] = dp[i - 1] + dp[i - 2]</code>，以及对备忘录或 DP table 的初始化操作，都是围绕这个方程式的不同表现形式。可见列出「状态转移方程」的重要性，它是解决问题的核心。而且很容易发现，其实状态转移方程直接代表着暴力解法。</p>
<p><strong>千万不要看不起暴力解，动态规划问题最困难的就是写出这个暴力解，即状态转移方程</strong>。只要写出暴力解，优化方法无非是用备忘录或者 DP table，再无奥妙可言。</p>
<p>这个例子的最后，讲一个细节优化。根据斐波那契数列的状态转移方程，当前状态只和之前的两个状态有关，其实并不需要那么长的一个 DP table 来存储所有的状态，只要想办法存储之前的两个状态就行了。所以，可以进一步优化，把空间复杂度降为 O(1)：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int fib(int n) &#123;</span><br><span class="line">    if (n &#x3D;&#x3D; 2 || n &#x3D;&#x3D; 1) </span><br><span class="line">        return 1;</span><br><span class="line">    int prev &#x3D; 1, curr &#x3D; 1;</span><br><span class="line">    for (int i &#x3D; 3; i &lt;&#x3D; n; i++) &#123;</span><br><span class="line">        int sum &#x3D; prev + curr;</span><br><span class="line">        prev &#x3D; curr;</span><br><span class="line">        curr &#x3D; sum;</span><br><span class="line">    &#125;</span><br><span class="line">    return curr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进一步改进版本</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    a,b = <span class="number">1</span>,<span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>,n):</span><br><span class="line">        c = a+b</span><br><span class="line">        a = b</span><br><span class="line">        b = c</span><br><span class="line">    <span class="keyword">return</span> c</span><br></pre></td></tr></table></figure>

<p>这个技巧就是所谓的「<strong>状态压缩</strong>」，如果我们发现每次状态转移只需要 DP table 中的一部分，那么可以尝试用状态压缩来缩小 DP table 的大小，只记录必要的数据，上述例子就相当于把DP table 的大小从 <code>n</code> 缩小到 2。一般来说是把一个二维的 DP table 压缩成一维，即把空间复杂度从 O(n^2) 压缩到 O(n)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 还有更简便的方法，怎么在O(1)的时间复杂度下计算fib(n)?    套公式</span></span><br><span class="line"><span class="comment"># 通项公式求解</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    denominator = math.sqrt(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">return</span> int((np.power((<span class="number">1</span>+denominator)/<span class="number">2</span>, n) - np.power((<span class="number">1</span>-denominator)/<span class="number">2</span>, n)) / denominator)</span><br><span class="line"></span><br><span class="line">print(fib(<span class="number">7</span>))</span><br></pre></td></tr></table></figure>

<p>斐波那契数列的例子严格来说不算动态规划，因为没有涉及求最值，所以没有「最优子结构」，以上旨在说明重叠子问题的消除方法，演示得到最优解法逐步求精的过程。下面，看第二个例子，凑零钱问题。</p>
<p>（2）凑零钱问题</p>
<p>先看下题目：给你 <code>k</code> 种面值的硬币，面值分别为 <code>c1, c2 ... ck</code>，每种硬币的数量无限，再给一个总金额 <code>amount</code>，问你<strong>最少</strong>需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。算法的函数签名如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; coins 中是可选硬币面值，amount 是目标金额</span><br><span class="line">int coinChange(int[] coins, int amount);</span><br></pre></td></tr></table></figure>

<p>比如说 <code>k = 3</code>，面值分别为 1，2，5，总金额 <code>amount = 11</code>。那么最少需要 3 枚硬币凑出，即 11 = 5 + 5 + 1。</p>
<p>最先能想到的方法，就是把所有可能的凑硬币方法都穷举出来，然后找找看最少需要多少枚硬币。</p>
<p><strong>1、暴力递归</strong></p>
<p>首先，这个问题是动态规划问题，因为它具有「最优子结构」的。<strong>要符合「最优子结构」，子问题间必须互相独立</strong>。啥叫相互独立？就是子问题是互相独立，互不干扰的。</p>
<p>但是，如果加一个条件：一个子问题和另一个子问题会互相制约，这样的话，因为子问题并不独立，两个子问题无法同时最优，所以最优子结构被破坏。</p>
<p>回到凑零钱问题，为什么说它符合最优子结构呢？比如你想求 <code>amount = 11</code> 时的最少硬币数（原问题），如果你知道凑出 <code>amount = 10</code> 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 1 的硬币）就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。</p>
<p>那么，既然知道了这是个动态规划问题，就要思考<strong>如何列出正确的状态转移方程</strong>？</p>
<p>1、<strong>确定 base case</strong>，这个很简单，显然目标金额 <code>amount</code> 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。</p>
<p>2、<strong>确定「状态」，也就是原问题和子问题中会变化的变量</strong>。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 <code>amount</code>。</p>
<p>3、<strong>确定「选择」，也就是导致「状态」产生变化的行为</strong>。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。</p>
<p>4、<strong>明确</strong> <strong><code>dp</code></strong> <strong>函数/数组的定义</strong>。我们这里讲的是自顶向下的解法，所以会有一个递归的 <code>dp</code> 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。所以我们可以这样定义 <code>dp</code> 函数：</p>
<p><code>dp(n)</code> 的定义：输入一个目标金额 <code>n</code>，返回凑出目标金额 <code>n</code> 的最少硬币数量。</p>
<p>搞清楚上面这几个关键点，解法的伪码就可以写出来了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 伪码框架</span><br><span class="line">def coinChange(coins: List[int], amount: int):</span><br><span class="line"></span><br><span class="line">    # 定义：要凑出金额 n，至少要 dp(n) 个硬币</span><br><span class="line">    def dp(n):</span><br><span class="line">        # 做选择，选择需要硬币最少的那个结果</span><br><span class="line">        for coin in coins:</span><br><span class="line">            res &#x3D; min(res, 1 + dp(n - coin))</span><br><span class="line">        return res</span><br><span class="line"></span><br><span class="line">    # 题目要求的最终结果是 dp(amount)</span><br><span class="line">    return dp(amount)</span><br></pre></td></tr></table></figure>

<p>根据伪码，我们加上 base case 即可得到最终的答案。显然目标金额为 0 时，所需硬币数量为 0；当目标金额小于 0 时，无解，返回 -1：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">ncount = <span class="number">0</span>   <span class="comment"># 记录进入求min的次数</span></span><br><span class="line">ncount1 = <span class="number">0</span>   <span class="comment"># 记录实际处理的子问题数量</span></span><br><span class="line"><span class="comment"># def coinChange(coins, amount):</span></span><br><span class="line">coins = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">amount = <span class="number">18</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> ncount</span><br><span class="line">    ncount += <span class="number">1</span>   <span class="comment"># 实际进入求min，但是如果n为0或1，能直接返回结果，就不会再进入下一级子问题了。</span></span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="comment"># 求最小值，所以初始化为正无穷</span></span><br><span class="line">    res = float(<span class="string">'INF'</span>)</span><br><span class="line">    <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">        subproblem = dp(n - coin)</span><br><span class="line">        <span class="comment"># 子问题无解，跳过</span></span><br><span class="line">        <span class="keyword">if</span> subproblem == <span class="number">-1</span>: <span class="keyword">continue</span></span><br><span class="line">        res = min(res, <span class="number">1</span> + subproblem)</span><br><span class="line">    <span class="keyword">global</span> ncount1</span><br><span class="line">    ncount1 += <span class="number">1</span>       <span class="comment"># 上面没有return，就代表实际进入子问题的求解了。</span></span><br><span class="line">    <span class="keyword">return</span> res <span class="keyword">if</span> res != float(<span class="string">'INF'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">print(dp(amount))</span><br><span class="line">print(ncount)</span><br><span class="line">print(ncount1)</span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># 38869  # 子问题个数</span></span><br><span class="line"><span class="comment"># 12956</span></span><br></pre></td></tr></table></figure>

<p>至此，状态转移方程其实已经完成了，以上算法已经是暴力解法了，以上代码的数学形式就是状态转移方程：</p>
<p><img src="https://gblobscdn.gitbook.com/assets%2F-LrtQOWSnDdXhp3kYN4k%2Fsync%2F5381a5e30482682c1c6f111e882991113b8661f7.png?alt=media" alt="img"></p>
<p>至此，这个问题其实就解决了，只不过需要消除一下重叠子问题，比如 <code>amount = 11, coins = {1,2,5}</code> 时画出递归树看看：</p>
<p><img src="https://user-gold-cdn.xitu.io/2019/8/15/16c95abdd4d29a1a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img"></p>
<p><strong>递归算法的时间复杂度分析：子问题总数 x 每个子问题的时间</strong>。</p>
<p><strong>时间复杂度:</strong></p>
<ul>
<li><p>子问题总数为递归树节点个数</p>
<p>这里不止涉及到了递归，还涉及到了遍历size为<strong>k</strong>数组的， 就这个问题而言,按照最坏的情况来算，假设每一个子问题都会分裂<strong>k份</strong>，那么所有子问题的个数就是<strong>O(k^n)</strong>，指数级别。由以上代码可知，所有子节点(子问题)个数是38869个，走到计算 求和+比较min 的部分有12956次，其他是n=0或n=-1的节点。</p>
</li>
<li><p>解决一个子问题所需的时间</p>
<p>size为<strong>k</strong>的循环中，存在<strong>一次加法</strong>，和<strong>一次min对比</strong>计算，所以最多有<strong>2*k=2k</strong>次运算.</p>
</li>
</ul>
<p>所以，时间复杂度就是<strong>O(k^n)</strong>x<strong>2k</strong> = <strong>O(2*k^(n+1)）。指数级别的时间复杂度。</strong></p>
<p><strong>空间复杂度：</strong></p>
<p>由于没有数据保存，一律认为空间复杂度是<strong>O(1)</strong></p>
<p><strong>2、带备忘录的递归</strong></p>
<p>类似之前斐波那契数列的例子，只需要稍加修改，就可以通过备忘录消除子问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">ncount = <span class="number">0</span>   <span class="comment"># 记录进入求min的次数</span></span><br><span class="line">ncount1 = <span class="number">0</span>   <span class="comment"># 记录实际处理的子问题数量</span></span><br><span class="line"><span class="comment"># def coinChange(coins, amount):</span></span><br><span class="line">coins = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>]</span><br><span class="line">amount = <span class="number">18</span></span><br><span class="line">memo = dict()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dp</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> ncount   </span><br><span class="line">    ncount += <span class="number">1</span>   <span class="comment"># 实际进入求min，但是如果能直接找到结果，就不会再进入下一级子问题了。</span></span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> memo:<span class="keyword">return</span> memo[n]</span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>: <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">0</span>: <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="comment"># 求最小值，所以初始化为正无穷</span></span><br><span class="line">    res = float(<span class="string">'INF'</span>)</span><br><span class="line">    <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">        <span class="comment"># 实际进入求min</span></span><br><span class="line">        subproblem = dp(n - coin)</span><br><span class="line">        <span class="comment"># 子问题无解，跳过</span></span><br><span class="line">        <span class="keyword">if</span> subproblem == <span class="number">-1</span>: <span class="keyword">continue</span></span><br><span class="line">        res = min(res, <span class="number">1</span> + subproblem)</span><br><span class="line">    memo[n] = res <span class="keyword">if</span> res != float(<span class="string">'INF'</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line">    <span class="keyword">global</span> ncount1</span><br><span class="line">    ncount1 += <span class="number">1</span>    <span class="comment"># 上面没有return，就代表实际进入子问题的求解了。</span></span><br><span class="line">    <span class="keyword">return</span> memo[n]</span><br><span class="line"></span><br><span class="line">print(<span class="string">"凑出目标金额 %d 的最少硬币数量:%d"</span> %(amount,dp(amount)))</span><br><span class="line">print(<span class="string">"实际处理的子问题数量:"</span>, ncount1)</span><br><span class="line">print(<span class="string">"因为每个实际计算的子问题需要遍历k次，实际处理的子问题循环的数量:"</span>, ncount)</span><br><span class="line"><span class="comment"># 凑出目标金额18的最少硬币数量:5</span></span><br><span class="line"><span class="comment"># 实际处理的子问题数量: 18</span></span><br><span class="line"><span class="comment"># 因为每个实际计算的子问题需要遍历k次，实际处理的子问题循环的数量：55</span></span><br></pre></td></tr></table></figure>

<p>很显然「备忘录」大大减小了子问题数目，完全消除了子问题的冗余，所以子问题总数不会超过金额数 <code>n</code>，即子问题数目为 O(n)。处理一个子问题的时间不变，仍是 2k，所以总的时间复杂度是 O(kn)。</p>
<p><strong>3、dp 数组的迭代解法</strong></p>
<p>当然，我们也可以自底向上使用 dp table 来消除重叠子问题，关于「状态」「选择」和 base case 与之前没有区别，<code>dp</code> 数组的定义和刚才 <code>dp</code> 函数类似，也是把「状态」，也就是目标金额作为变量。不过 <code>dp</code> 函数体现在函数参数，而 <code>dp</code> 数组体现在数组索引：</p>
<p><strong><code>dp</code></strong> <strong>数组的定义：当目标金额为</strong> <strong><code>i</code></strong> <strong>时，至少需要</strong> <strong><code>dp[i]</code></strong> <strong>枚硬币凑出</strong>。</p>
<p>根据我们文章开头给出的动态规划代码框架可以写出如下解法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coinChange</span><span class="params">(coins, amount)</span>:</span></span><br><span class="line">    <span class="comment"># 数组大小为 amount + 1，初始值也为 amount + 1</span></span><br><span class="line">    dp = [amount+<span class="number">1</span>]*(amount+<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># base case</span></span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 外层 for 循环在遍历所有状态的所有取值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(amount+<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 内层 for 循环在求所有选择的最小值</span></span><br><span class="line">        <span class="keyword">for</span> coin <span class="keyword">in</span> coins:</span><br><span class="line">            <span class="comment"># 子问题无解，跳过</span></span><br><span class="line">            <span class="keyword">if</span> i-coin &lt; <span class="number">0</span>: </span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            dp[i] = min(dp[i], dp[i-coin]+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> dp[amount] <span class="keyword">if</span> dp[amount] != (amount+<span class="number">1</span>) <span class="keyword">else</span> <span class="number">-1</span></span><br><span class="line"></span><br><span class="line">print(coinChange([<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>],<span class="number">18</span>))</span><br><span class="line"><span class="comment"># 5</span></span><br></pre></td></tr></table></figure>

<p><img src="https://user-gold-cdn.xitu.io/2019/8/15/16c95abdfb407337?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="img">PS：为啥 <code>dp</code> 数组初始化为 <code>amount + 1</code> 呢，因为凑成 <code>amount</code> 金额的硬币数最多只可能等于 <code>amount</code>（全用 1 元面值的硬币），所以初始化为 <code>amount + 1</code> 就相当于初始化为正无穷，便于后续取最小值。</p>
<p>（3）最后总结</p>
<p>第一个斐波那契数列的问题，解释了如何通过「备忘录」或者「dp table」的方法来优化递归树，并且明确了这两种方法本质上是一样的，只是自顶向下和自底向上的不同而已。</p>
<p>第二个凑零钱的问题，展示了如何流程化确定「状态转移方程」，只要通过状态转移方程写出暴力递归解，剩下的也就是优化递归树，消除重叠子问题而已。</p>
<p><strong>计算机解决问题其实没有任何奇技淫巧，它唯一的解决办法就是穷举</strong>，穷举所有可能性。算法设计无非就是先思考“如何穷举”，然后再追求“如何聪明地穷举”。</p>
<p>列出动态转移方程，就是在解决“如何穷举”的问题。之所以说它难，一是因为很多穷举需要递归实现，二是因为有的问题本身的解空间复杂，不那么容易穷举完整。</p>
<p>备忘录、DP table 就是在追求“如何聪明地穷举”。用空间换时间的思路，是降低时间复杂度的不二法门。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/23/Leetcode-Task02/" data-id="cke6vrf2i0000rwwc8bcv9soi" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Leetcode-Task01" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/19/Leetcode-Task01/" class="article-date">
  <time datetime="2020-08-19T15:04:47.000Z" itemprop="datePublished">2020-08-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/19/Leetcode-Task01/">Leetcode-Task01</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Leetcode编程-Task01"><a href="#Leetcode编程-Task01" class="headerlink" title="Leetcode编程-Task01"></a>Leetcode编程-Task01</h1><h2 id="Task-1-分治"><a href="#Task-1-分治" class="headerlink" title="Task 1:分治"></a>Task 1:分治</h2><p><strong>1.主要思想</strong></p>
<p>分治算法的主要思想是将原问题<strong>递归地分成</strong>若干个子问题，直到子问题<strong>满足边界条件</strong>，停止递归。将子</p>
<p>问题逐个击破(一般是同种方法)，将已经解决的子问题合并，最后，算法会<strong>层层合并</strong>得到原问题的答</p>
<p>案。</p>
<p><strong>2.分治算法的步骤</strong></p>
<p>分：<strong>递归地</strong>将问题<strong>分解</strong>为各个的子<strong>问题</strong>(性质相同的、相互独立的子问题)；</p>
<p>治：将这些规模更小的子问题<strong>逐个击破</strong>；</p>
<p>合：将已解决的子问题<strong>逐层合并</strong>，最终得出原问题的解；</p>
<p><strong>3.分治法适用的情况</strong></p>
<p>原问题的<strong>计算复杂度</strong>随着问题的规模的增加而增加。</p>
<p>原问题<strong>能够被分解</strong>成更小的子问题。</p>
<p>子问题的<strong>结构和性质</strong>与原问题一样，并且<strong>相互独立</strong>，子问题之间<strong>不包含</strong>公共的子子问题。</p>
<p>原问题分解出的子问题的解<strong>可以合并</strong>为该问题的解。</p>
<p>4.算法应用样例</p>
<p><strong>1）Leetcode 169.</strong> <strong>多数元素</strong></p>
<p>题目描述：给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 [n/2] 的元素。</p>
<p>你可以假设数组是非空的，并且给定的数组总是存在众数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [3,2,3]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [2,2,1,1,1,2,2]</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure>

<p>解题思路1：（不过这里默认了只有一个多数元素）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    s = set(nums)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> s:</span><br><span class="line">        <span class="keyword">if</span> nums.count(i)&gt;len(nums)//<span class="number">2</span>:</span><br><span class="line">            rs = i</span><br><span class="line">            <span class="keyword">return</span> rs</span><br></pre></td></tr></table></figure>

<p>解题思路2（分治思想）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">majorityElement</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    <span class="comment"># 不断切分的终止条件</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">        <span class="keyword">return</span> none</span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 准备数据  nums</span></span><br><span class="line">    <span class="comment"># 将大问题拆分为小问题</span></span><br><span class="line">    <span class="comment"># 处理小问题，得到子结果</span></span><br><span class="line">    left = self.majorityElement(nums[:len(nums)//<span class="number">2</span>])</span><br><span class="line">    right = self.majorityElement(nums[len(nums)//<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 对子结果进行合并，得到最终结果</span></span><br><span class="line">    <span class="keyword">if</span> left == right:</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    <span class="keyword">if</span> nums.count(left) &gt; nums.count(right):</span><br><span class="line">        <span class="keyword">return</span> left</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure>

<p><strong>2.Leetcode 53.</strong> <strong>最大子序和</strong></p>
<p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p>
<p>示例:</p>
<p>输入: [-2,1,-3,4,-1,2,1,-5,4]<br>输出: 6<br>解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</p>
<p>解题思路1：动态规划</p>
<p>时间复杂度：O(n)，其中 n为 nums 数组的长度。我们只需要遍历一遍数组即可求得答案。<br>空间复杂度：O(1)。我们只需要常数空间存放若干变量。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    <span class="comment"># 动态规则，时间复杂度 O(n) </span></span><br><span class="line">    pre = <span class="number">0</span></span><br><span class="line">    maxsum = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> i,x <span class="keyword">in</span> enumerate(nums):</span><br><span class="line">        <span class="comment">#只有加上当前元素会更大时，才加上，否则从当前元素重新开始加和，也就是会去掉前面和是负数的所有元素</span></span><br><span class="line">        pre = max(pre+x, x)</span><br><span class="line">        maxsum = max(maxsum, pre)</span><br><span class="line">    <span class="keyword">return</span> maxsum</span><br></pre></td></tr></table></figure>

<p>解题思路2（分治思想）：</p>
<p>复杂度分析</p>
<p>假设序列 a 的长度为 n。</p>
<p>时间复杂度：假设我们把递归的过程看作是一颗二叉树的先序遍历，那么这颗二叉树的深度的渐进上界为 O(logn)，这里的总时间相当于遍历这颗二叉树的所有节点，故总时间的渐进上界是<img src="Leetcode-Task01/image-20200821144822058.png" alt="image-20200821144822058"> ，故渐进时间复杂度为 O(n)。</p>
<p>？？？大部分写的时间复杂度是O(nlogn)，到底是多少？归并排序是O(nlogn)，这个应该和那个差不多？</p>
<p>空间复杂度：递归会使用 O(logn) 的栈空间，故渐进空间复杂度为 O(logn)。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    <span class="comment"># 不断切分的终止条件</span></span><br><span class="line">    <span class="keyword">if</span> len(nums) == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># 准备数据  nums</span></span><br><span class="line">    <span class="comment"># 将大问题拆分为小问题。三种情况：左子串得到最大和；右子串得到最大和；最大和穿过左右子串。</span></span><br><span class="line">    <span class="comment"># 处理小问题，得到子结果</span></span><br><span class="line">    <span class="comment"># 递归计算左子串的最大和</span></span><br><span class="line">    left = self.maxSubArray(nums[:len(nums)//<span class="number">2</span>])</span><br><span class="line">    <span class="comment"># 递归计算右子串的最大和</span></span><br><span class="line">    right = self.maxSubArray(nums[len(nums)//<span class="number">2</span>:])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从右到左计算左子串的最大和</span></span><br><span class="line">    max_l = nums[len(nums)//<span class="number">2</span><span class="number">-1</span>]</span><br><span class="line">    tmp = <span class="number">0</span>  <span class="comment"># 记录连续子数组的和</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)//<span class="number">2</span><span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        tmp += nums[i]</span><br><span class="line">        max_l = max(tmp, max_l)</span><br><span class="line">    <span class="comment"># 从左到右计算右子串的最大和</span></span><br><span class="line">    max_r = nums[len(nums)//<span class="number">2</span>]</span><br><span class="line">    tmp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)//<span class="number">2</span>, len(nums)):</span><br><span class="line">        tmp += nums[i]</span><br><span class="line">        max_r = max(tmp, max_r)</span><br><span class="line"></span><br><span class="line">     <span class="comment"># 对子结果进行合并，得到最终结果</span></span><br><span class="line">     <span class="keyword">return</span> max(left, right, max_l+max_r)</span><br></pre></td></tr></table></figure>

<p>「方法二」相较于「方法一」来说，时间复杂度相同，但是因为使用了递归，并且维护了四个信息的结构体，运行的时间略长，空间复杂度也不如方法一优秀，而且难以理解。那么这种方法存在的意义是什么呢？</p>
<p>对于这道题而言，确实是如此的。但是仔细观察「方法二」，它不仅可以解决区间 [][0, n - 1][0,n−1]，还可以用于解决任意的子区间[][l, r][l,r] 的问题。如果我们把 [][0, n - 1][0,n−1] 分治下去出现的所有子区间的信息都用堆式存储的方式记忆化下来，即建成一颗真正的树之后，我们就可以在 O(logn) 的时间内求到任意区间内的答案，我们甚至可以修改序列中的值，做一些简单的维护，之后仍然可以在 O(logn) 的时间内求到任意区间内的答案，对于大规模查询的情况下，这种方法的优势便体现了出来。这棵树就是上文提及的一种神奇的数据结构——线段树。</p>
<p><strong>3.Leetcode 50.</strong> <strong>Pow(x,n)</strong></p>
<p>实现 pow(x, n) ，即计算 x 的 n 次幂函数。</p>
<p>示例 1:</p>
<p>输入: 2.00000, 10<br>输出: 1024.00000<br>示例 2:</p>
<p>输入: 2.10000, 3<br>输出: 9.26100<br>示例 3:</p>
<p>输入: 2.00000, -2<br>输出: 0.25000<br>解释: 2-2 = 1/22 = 1/4 = 0.25<br>说明:</p>
<p>-100.0 &lt; x &lt; 100.0<br>n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">    <span class="comment"># 不断切分的终止条件</span></span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="comment"># 准备数据  nums</span></span><br><span class="line">    <span class="comment"># 将大问题拆分为小问题</span></span><br><span class="line">    <span class="comment"># 处理小问题，得到子结果</span></span><br><span class="line">    <span class="keyword">if</span> n&lt;<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>/self.myPow(x, -n)</span><br><span class="line">    s = self.myPow(x,n//<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># # 对子结果进行合并，得到最终结果</span></span><br><span class="line">    <span class="keyword">if</span> n%<span class="number">2</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> s*s</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> s*s*x</span><br><span class="line">    <span class="comment"># 用以下方式拆分，不行，会超出时间限制，left中把一次方、二次方。。全部算了一遍，right中也把一次方、二次方。。全部算了一遍，没有解决问题，此题问题关键是，每次拆分后，只需要算x的n//2次方，再将两个x的n//2次方相乘即可。</span></span><br><span class="line">    <span class="comment"># left = self.myPow(x,n//2)</span></span><br><span class="line">    <span class="comment"># right = self.myPow(x,n-(n//2))    </span></span><br><span class="line">    <span class="comment"># return left*right</span></span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myPow</span><span class="params">(self, x: float, n: int)</span> -&gt; float:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quickMul</span><span class="params">(x, n)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span></span><br><span class="line">        y = quickMul(x, n//<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> n%<span class="number">2</span> ==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> y*y</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> y*y*x</span><br><span class="line">    <span class="keyword">if</span> n&lt;<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1.0</span>/quickMul(x, -n)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> quickMul(x,n)</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/19/Leetcode-Task01/" data-id="cke1jfl5a000088wc5npw7nla" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Python-Task09" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/07/Python-Task09/" class="article-date">
  <time datetime="2020-08-07T14:52:44.000Z" itemprop="datePublished">2020-08-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/07/Python-Task09/">Python-Task09</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Python编程基础-Task09"><a href="#Python编程基础-Task09" class="headerlink" title="Python编程基础-Task09"></a>Python编程基础-Task09</h1><h2 id="Task-9-文件与文件系统"><a href="#Task-9-文件与文件系统" class="headerlink" title="Task 9:文件与文件系统"></a>Task 9:文件与文件系统</h2><p>1.文件与文件系统</p>
<p>打开文件  <code>open(file, mode=&#39;r&#39;, buffering=None, encoding=None, errors=None, newline=None, closefd=True)</code>，file：必需，文件路径（相对或者绝对路径）。mode：可选，文件打开模式。encoding：一般使用utf8。errors：报错级别。newline：区分换行符。</p>
<p>mode：’r’只读方式，’w’打开一个文件只用于写入，覆盖式；’x’新建一个文件，写模式；’a’追加模式；’b’以二进制模式打开文件；’t’以文本模式打开；’+’可读写模式。</p>
<p>文件对象方法：</p>
<p>1）<code>fileObject.close()</code> 用于关闭一个已打开的文件。关闭后的文件不能再进行读写操作， 否则会触发<code>ValueError</code>错误。</p>
<p>2）<code>fileObject.read([size])</code> 用于从文件读取指定的字符数，如果未给定或为负则读取所有。</p>
<p>3）<code>fileObject.readline()</code>读取整行，包括 “\n” 字符。</p>
<p>4）<code>fileObject.readlines()</code>用于读取所有行(直到结束符 EOF)并返回列表，该列表可以由 Python 的 <code>for... in ...</code> 结构进行处理。</p>
<p>5）<code>fileObject.tell()</code>返回文件的当前位置，即文件指针当前位置。按字节数计算，一个中文汉字占两个字节的空间。</p>
<p>6）<code>fileObject.seek(offset[, whence])</code>用于移动文件读取指针到指定位置。<code>offset</code>：开始的偏移量，也就是代表需要移动偏移的字节数，如果是负数表示从倒数第几位开始。<code>whence</code>：可选，默认值为 0。给 <code>offset</code> 定义一个参数，表示要从哪个位置开始偏移；0 代表从文件开头开始算起，1 代表从当前位置开始算起，2 代表从文件末尾算起。</p>
<p>7）<code>fileObject.write(str)</code>用于向文件中写入指定字符串，返回的是写入的字符长度。在文件关闭前或缓冲区刷新前，字符串内容存储在缓冲区中，这时你在文件中是看不到写入的内容的。</p>
<p>如果文件打开模式带<code>b</code>，那写入文件内容时，<code>str</code>（参数）要用<code>encode</code>方法转为<code>bytes</code>形式，否则报错：<code>TypeError: a bytes-like object is required, not &#39;str&#39;</code>。</p>
<p>8）<code>fileObject.writelines(sequence)</code>向文件写入一个序列字符串列表，如果需要换行则要自己加入每行的换行符<code>\n</code>。</p>
<p>9）关键词 with 语句就可以保证诸如文件之类的对象在使用完之后一定会正确的执行它的清理方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'myfile.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">            print(line)</span><br><span class="line"><span class="keyword">except</span> OSError <span class="keyword">as</span> error:</span><br><span class="line">    print(<span class="string">'出错啦!%s'</span> % str(error))</span><br></pre></td></tr></table></figure>

<p>2.OS模块中关于文件/目录常用的函数</p>
<p>1）<code>os.getcwd()</code>用于返回当前工作目录。</p>
<p>2）<code>os.chdir(path)</code>用于改变当前工作目录到指定的路径。</p>
<p>3）<code>listdir (path=&#39;.&#39;)</code>返回<code>path</code>指定的文件夹包含的文件或文件夹的名字的列表。</p>
<p>4）<code>os.mkdir(path)</code>创建单层目录，如果该目录已存在抛出异常。</p>
<p>5）<code>os.makedirs(path)</code>用于递归创建多层目录，如果该目录已存在抛出异常。</p>
<p>6）<code>os.remove(path)</code>用于删除指定路径的文件。如果指定的路径是一个目录，将抛出 <code>OSError</code>。</p>
<p>7）<code>os.rmdir(path)</code>用于删除单层目录。仅当这文件夹是空的才可以, 否则, 抛出 <code>OSError</code>。</p>
<p>8）<code>os.removedirs(path)</code>递归删除目录，从子目录到父目录逐层尝试删除，遇到目录非空则抛出异常。</p>
<p>9）<code>os.rename(src, dst)</code>方法用于命名文件或目录，从 <code>src</code> 到 <code>dst</code>，如果 <code>dst</code> 是一个存在的目录, 将抛出 <code>OSError</code>。</p>
<p>10）<code>os.system(command)</code>运行系统的shell命令（将字符串转化成命令）</p>
<p>11）<code>os.curdir</code>指代当前目录（<code>.</code>）</p>
<p>12）<code>os.pardir</code>指代上一级目录（<code>..</code>）</p>
<p>13）<code>os.sep</code>输出操作系统特定的路径分隔符（win下为<code>\\</code>，Linux下为<code>/</code>）</p>
<p>14）<code>os.linesep</code>当前平台使用的行终止符（win下为<code>\r\n</code>，Linux下为<code>\n</code>）</p>
<p>15）<code>os.name</code>指代当前使用的操作系统（包括：’mac’，’nt’）</p>
<p>16）<code>os.path.basename(path)</code>去掉目录路径，单独返回文件名</p>
<p>17）<code>os.path.dirname(path)</code>去掉文件名，单独返回目录路径</p>
<p>18）<code>os.path.join(path1[, path2[, ...]])</code>将 <code>path1</code>，<code>path2</code> 各部分组合成一个路径名</p>
<p>19）<code>os.path.split(path)</code>分割文件名与路径，返回<code>(f_path,f_name)</code>元组。如果完全使用目录，它会将最后一个目录作为文件名分离，且不会判断文件或者目录是否存在。</p>
<p>20）<code>os.path.splitext(path)</code>分离文件名与扩展名，返回<code>(f_path,f_name)</code>元组。</p>
<p>21）<code>os.path.getsize(file)</code>返回指定文件大小，单位是字节。</p>
<p>22）<code>os.path.getatime(file)</code>返回指定文件最近的访问时间</p>
<p>23）<code>os.path.getctime(file)</code>返回指定文件的创建时间</p>
<p>24）<code>os.path.getmtime(file)</code>返回指定文件的最新的修改时间</p>
<p>25）浮点型秒数，可用time模块的<code>gmtime()</code>或<code>localtime()</code>函数换算</p>
<p>26）<code>os.path.exists(path)</code>判断指定路径（目录或文件）是否存在</p>
<p>27）<code>os.path.isabs(path)</code>判断指定路径是否为绝对路径</p>
<p>28）<code>os.path.isdir(path)</code>判断指定路径是否存在且是一个目录</p>
<p>29）<code>os.path.isfile(path)</code>判断指定路径是否存在且是一个文件</p>
<p>30）<code>os.path.islink(path)</code>判断指定路径是否存在且是一个符号链接</p>
<p>31）<code>os.path.ismount(path)</code>判断指定路径是否存在且是一个悬挂点</p>
<p>32）<code>os.path.samefile(path1,path2)</code>判断path1和path2两个路径是否指向同一个文件</p>
<p>3.序列化与反序列化</p>
<p>Python 的 pickle 模块实现了基本的数据序列和反序列化。</p>
<ul>
<li>通过 pickle 模块的序列化操作我们能够将程序中运行的对象信息保存到文件中去，永久存储。</li>
<li>通过 pickle 模块的反序列化操作，我们能够从文件中创建上一次程序保存的对象。</li>
</ul>
<p>pickle模块中最常用的函数为：</p>
<p><code>pickle.dump(obj, file, [,protocol])</code> 将<code>obj</code>对象序列化存入已经打开的<code>file</code>中。<code>obj</code>：想要序列化的<code>obj</code>对象。<code>file</code>:文件名称。<code>protocol</code>：序列化使用的协议。如果该项省略，则默认为0。如果为负值或<code>HIGHEST_PROTOCOL</code>，则使用最高的协议版本。</p>
<p><code>pickle.load(file)</code> 将<code>file</code>中的对象序列化读出。<code>file</code>：文件名称。</p>
<p>4.练习题</p>
<p>1)打开中文字符的文档时，会出现乱码，Python自带的打开文件是否可以指定文字编码？还是只能用相关函数？</p>
<p>用open(path, ‘r’, encoding = ‘utf-8’) 打开文件就可以。linux使用’utf-8’编码方式，window使用’GBK’编码方式。linux平台编码（UTF-8）与window平台（GBK）不一样。中文字符默认是用gbk编码方式来读取，所以会乱码。</p>
<p>2）编写程序查找最长的单词</p>
<p>输入文档: res/test.txt</p>
<p>题目说明:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">Input file</span></span><br><span class="line"><span class="string">   test.txt</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">Output file</span></span><br><span class="line"><span class="string">   ['general-purpose,', 'object-oriented,']</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longest_word</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="comment"># 读取全部数据，用strip()去除头尾的字符，再用split(’\n’)切割每一段。</span></span><br><span class="line">    <span class="comment"># readlines()读取的结果里还是包含了’\n’.</span></span><br><span class="line">    <span class="keyword">with</span> open(filename,<span class="string">'r'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = f.read().strip().split(<span class="string">'\n'</span>)</span><br><span class="line">    <span class="comment"># 替换英文字符 逗号</span></span><br><span class="line">    data = [i.replace(<span class="string">','</span>,<span class="string">' '</span>)  <span class="keyword">for</span> i <span class="keyword">in</span> data]</span><br><span class="line">    <span class="comment"># 用’ ‘.join 的方法重新组合字符串，再进行split(’ '), 按照空格来切割，得到单个字符。</span></span><br><span class="line">    data1 = <span class="string">' '</span>.join(data).split(<span class="string">' '</span>)</span><br><span class="line">    <span class="comment"># 根据字符串长度排序</span></span><br><span class="line">    data1.sort(key = <span class="keyword">lambda</span> x:len(x))</span><br><span class="line">    <span class="comment"># 保留所有与最长字符串长度相同的字符串</span></span><br><span class="line">    longest = [i <span class="keyword">for</span> i <span class="keyword">in</span> data1 <span class="keyword">if</span> len(i)==len(data1[<span class="number">-1</span>])]</span><br><span class="line">    <span class="keyword">return</span> longest</span><br><span class="line"></span><br><span class="line">print(longest_word(<span class="string">'test2.txt'</span>))</span><br></pre></td></tr></table></figure>

<p>[‘general-purpose’, ‘object-oriented’]</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/07/Python-Task09/" data-id="ckdkd6nob000068wc5d28dy4t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Python-Task08" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/07/Python-Task08/" class="article-date">
  <time datetime="2020-08-07T03:08:22.000Z" itemprop="datePublished">2020-08-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/07/Python-Task08/">Python-Task08</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Python编程基础-Task08"><a href="#Python编程基础-Task08" class="headerlink" title="Python编程基础-Task08"></a>Python编程基础-Task08</h1><h2 id="Task-8-模块与datetime模块"><a href="#Task-8-模块与datetime模块" class="headerlink" title="Task 8:模块与datetime模块"></a>Task 8:模块与datetime模块</h2><p><strong>模块</strong></p>
<p>1.模块   </p>
<p>​    模块是一个包含所有你定义的函数和变量的文件，其后缀名是.py。模块可以被别的程序引入，以使用该模块中的函数等功能。这也是使用 python 标准库的方法。</p>
<ul>
<li>容器 -&gt; 数据的封装</li>
<li>函数 -&gt; 语句的封装</li>
<li>类 -&gt; 方法和属性的封装</li>
<li>模块 -&gt; 程序文件</li>
</ul>
<p>2.命名空间</p>
<p>​    命名空间（namespace）是从名称到对象的映射，大部分命名空间都是通过Python字典来实现的。命名空间提供了在项目中避免名字冲突的一种方法。各个命名空间是独立的，没有任何关系的，所以一个命名空间中不能有重名，但不同的命名空间是可以重名而没有任何影响。</p>
<p>因为对象的不同，也有所区别，可以分为如下几种：</p>
<ul>
<li>内置命名空间（Built-in Namespaces）：Python语言内置的名称，Python 运行起来，它们就存在了。内置函数的命名空间都属于内置命名空间，所以，我们可以在任何程序中直接运行它们，比如<code>id()</code>,不需要做什么操作，拿过来就直接使用了。</li>
<li>全局命名空间（Module：Global Namespaces）：模块中定义的名称，记录了模块的变量，包括函数、类、其他导入的模块、模块级的变量和常量。每个模块创建它自己所拥有的全局命名空间，不同模块的全局命名空间彼此独立，不同模块中相同名称的命名空间，也会因为模块的不同而不相互干扰。</li>
<li>本地命名空间（Function &amp; Class：Local Namespaces）：函数中定义的名称，记录了函数的变量，包括函数的参数和局部定义的变量。模块中有函数或者类，每个函数或者类所定义的命名空间就是本地命名空间。如果函数返回了结果或者抛出异常，则本地命名空间也结束了。</li>
</ul>
<img src="https://www.runoob.com/wp-content/uploads/2014/05/types_namespace-1.png" alt="img" style="zoom:50%;" />

<p>命名空间查找顺序:按照从里到外的顺序，为：<strong>局部的命名空间去 -&gt; 全局命名空间 -&gt; 内置命名空间</strong>。</p>
<p>如果找不到变量 ，它将放弃查找并引发一个 NameError 异常</p>
<p>命名空间的生命周期：命名空间的生命周期取决于对象的作用域，如果对象执行完成，则该命名空间的生命周期就结束。因此，我们无法从外部命名空间访问内部命名空间的对象。</p>
<p>作用域：作用域就是一个 Python 程序可以直接访问命名空间的正文区域。</p>
<p>变量的作用域决定了在哪一部分程序可以访问哪个特定的变量名称。Python的作用域一共有4种，分别是：</p>
<p>有四种作用域：</p>
<ul>
<li><strong>L（Local）</strong>：最内层，包含局部变量，比如一个函数/方法内部。</li>
<li><strong>E（Enclosing）</strong>：包含了非局部(non-local)也非全局(non-global)的变量。比如两个嵌套函数，一个函数（或类） A 里面又包含了一个函数 B ，那么对于 B 中的名称来说 A 中的作用域就为 nonlocal。</li>
<li><strong>G（Global）</strong>：当前脚本的最外层，比如当前模块的全局变量。</li>
<li><strong>B（Built-in）</strong>： 包含了内建的变量/关键字等。，最后被搜索</li>
</ul>
<p>规则顺序： <strong>L –&gt; E –&gt; G –&gt;gt; B</strong>。</p>
<p>在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内置中找。</p>
<p><img src="https://www.runoob.com/wp-content/uploads/2014/05/1418490-20180906153626089-1835444372.png" alt="img"></p>
<p>3.导入模块</p>
<p>第一种：import 模块名</p>
<p>第二种：from 模块名 import 函数名</p>
<p>第三种：import 模块名 as 新名字</p>
<p><strong>比如引入同一目录下的py文件：</strong></p>
<p>例如在admin.py文件中要引入dealcode.py文件：</p>
<p>1)在目录下有<strong>init</strong>.py文件</p>
<p>2)在admin.py文件中加一行：from . import dealcode</p>
<p>（如果要引入同一目录下的dealcode.py文件中的一个类Hello，在admin.py文件中加一行：from .dealcode import Hello）</p>
<p>引入同级目录文件夹的下级文件：from .templateminer import lenma_template</p>
<p>（一定要加.）</p>
<p>from .. import module_name：导入本模块上一级目录的模块。</p>
<p>from ..package_name import module_name。导入本模块上一级目录下的包中的模块。</p>
<p>但需要注意：</p>
<p>需要执行main的模块中，将相对引用改为绝对引用。较常见的比如单元测试类中的导入。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> .package <span class="keyword">import</span> mymodule</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">   do_something()</span><br></pre></td></tr></table></figure>

<p>更改：</p>
<p>比较简单的一种是将”.”之前加上文件夹的名字，形如：</p>
<p>​    from my_dir.package import mymodule   或者  from package import mymodule</p>
<p>分析：</p>
<p>在main函数中执行时，<strong>name</strong>这个变量值是”<strong>main</strong>”。而相对引用符号”.”的就是对应<strong>name</strong>这个变量。</p>
<p>当这个模块是在别的模块中被导入使用，此时的”.”就是原模块的文件名。在main函数中执行时，此时”.”变成了”<strong>main</strong>”。所以，出现了这个问题。</p>
<p>4.<code>if __name__ == &#39;__main__&#39;</code></p>
<p><code>__name__</code>：是内置变量，可用于表示当前模块的名字。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> const</span><br><span class="line"></span><br><span class="line">print(__name__)</span><br><span class="line"><span class="comment"># __main__</span></span><br><span class="line"></span><br><span class="line">print(const.__name__)</span><br><span class="line"><span class="comment"># const</span></span><br></pre></td></tr></table></figure>

<p>​    由此我们可知：如果一个 .py 文件（模块）被直接运行时，其<code>__name__</code>值为<code>__main__</code>，即模块名为<code>__main__</code>。</p>
<p>所以，<code>if __name__ == &#39;__main__&#39;</code>的意思是：当 .py 文件被直接运行时，<code>if __name__ == &#39;__main__&#39;</code>之下的代码块将被运行；当 .py 文件以模块形式被导入时，<code>if __name__ == &#39;__main__&#39;</code>之下的代码块不被运行。</p>
<p>5.搜索路径</p>
<p>当解释器遇到 import 语句，如果模块在当前的搜索路径就会被导入。</p>
<p>当我们使用import语句的时候，Python解释器是怎样找到对应的文件的呢？</p>
<p>这就涉及到Python的搜索路径，搜索路径是由一系列目录名组成的，Python解释器就依次从这些目录中去寻找所引入的模块。这看起来很像环境变量，事实上，也可以通过定义环境变量的方式来确定搜索路径。</p>
<p>搜索路径是在Python编译或安装的时候确定的，安装新的库应该也会修改。搜索路径被存储在sys模块中的path变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">print(sys.path)</span><br><span class="line"><span class="comment"># ['C:\\ProgramData\\Anaconda3\\DLLs', 'C:\\ProgramData\\Anaconda3\\lib', 'C:\\ProgramData\\Anaconda3', 'C:\\ProgramData\\Anaconda3\\lib\\site-packages',...]</span></span><br></pre></td></tr></table></figure>

<p>6.包</p>
<p>包是一种管理 Python 模块命名空间的形式，采用”点模块名称”。</p>
<p>创建包分为三个步骤：</p>
<ul>
<li><p>创建一个文件夹，用于存放相关的模块，文件夹的名字即包的名字。</p>
</li>
<li><p>在文件夹中创建一个 <code>__init__.py</code> 的模块文件，内容可以为空。</p>
</li>
<li><p>将相关的模块放入文件夹中。</p>
</li>
</ul>
<p>如果我们使用 <code>from sound.effects import *</code>，Python 会进入文件系统，找到这个包里面所有的子模块，一个一个的把它们都导入进来。</p>
<p>导入语句遵循如下规则：如果包定义文件 <code>__init__.py</code> 存在一个叫做 <code>__all__</code> 的列表变量，那么在使用 <code>from package import *</code> 的时候就把这个列表中的所有名字作为包内容导入。</p>
<p>例如，在 <code>sounds/effects/__init__.py</code>中包含如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__all__ &#x3D; [&quot;echo&quot;, &quot;surround&quot;, &quot;reverse&quot;]</span><br></pre></td></tr></table></figure>

<p>这表示当你使用 <code>from sound.effects import *</code>这种用法时，你只会导入包里面这三个子模块。</p>
<p>如果 <code>__all__</code> 真的没有定义，那么使用<code>from sound.effects import *</code>这种语法的时候，就不会导入包 <code>sound.effects</code> 里的任何子模块。他只是把包 <code>sound.effects</code> 和它里面定义的所有内容导入进来（可能运行<code>__init__.py</code>里定义的初始化代码）。</p>
<p>这会把 <code>__init__.py</code> 里面定义的所有名字导入进来。并且他不会破坏掉我们在这句话之前导入的所有明确指定的模块。</p>
<p>7.练习题</p>
<p>1）怎么查出通过 from xx import xx导⼊的可以直接调⽤的⽅法？</p>
<p>方法1：通过 dir() 函数查看该模块中包含哪些成员：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line">print(dir(string))</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>[‘Formatter’, ‘Template’, ‘<em>ChainMap’, ‘<em>TemplateMetaclass’, ‘__all</em></em>‘, ‘<strong>builtins</strong>‘, ‘<strong>cached</strong>‘, ‘<strong>doc</strong>‘, ‘<strong>file</strong>‘, ‘<strong>loader</strong>‘, ‘<strong>name</strong>‘, ‘<strong>package</strong>‘, ‘<strong>spec</strong>‘, ‘_re’, ‘_string’, ‘ascii_letters’, ‘ascii_lowercase’, ‘ascii_uppercase’, ‘capwords’, ‘digits’, ‘hexdigits’, ‘octdigits’, ‘printable’, ‘punctuation’, ‘whitespace’]</p>
<p>​    通过 dir() 函数获取到的模块成员，不仅包含供外部文件使用的成员，还包含很多“特殊”（名称以 2 个下划线开头和结束）的成员，列出这些成员，对我们并没有实际意义。</p>
<p>​    可以忽略显示 dir() 函数输出的特殊成员的方法。仍以 string 模块为例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line">print([e <span class="keyword">for</span> e <span class="keyword">in</span> dir(string) <span class="keyword">if</span> <span class="keyword">not</span> e.startswith(<span class="string">'_'</span>)])</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>[‘Formatter’, ‘Template’, ‘ascii_letters’, ‘ascii_lowercase’, ‘ascii_uppercase’, ‘capwords’, ‘digits’, ‘hexdigits’, ‘octdigits’, ‘printable’, ‘punctuation’, ‘whitespace’]</p>
<p>方法2：除了使用 dir() 函数之外，还可以使用<code>__all__</code>变量，借助该变量也可以查看模块（包）内包含的所有成员。</p>
<p>仍以 string 模块为例，举个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> string</span><br><span class="line">print(string.__all__)</span><br></pre></td></tr></table></figure>

<p>程序执行结果为：</p>
<p>[‘ascii_letters’, ‘ascii_lowercase’, ‘ascii_uppercase’, ‘capwords’, ‘digits’, ‘hexdigits’, ‘octdigits’, ‘printable’, ‘punctuation’, ‘whitespace’, ‘Formatter’, ‘Template’]</p>
<p>​    显然，和 dir() 函数相比，<code>__all__</code>变量在查看指定模块成员时，它不会显示模块中的特殊成员，同时还会根据成员的名称进行排序显示。</p>
<p>​    不过需要注意的是，并非所有的模块都支持使用<code>__all__</code> 变量，因此对于获取有些模块的成员，就只能使用 dir() 函数。</p>
<p>方法3：在python交互解释器中使用help()查看，使用help函数查看里面的FUNCTIONS</p>
<p>2）了解Collection模块，编写程序以查询给定列表中最常见的元素。</p>
<p>题目说明：</p>
<p>输入：language = [‘PHP’, ‘PHP’, ‘Python’, ‘PHP’, ‘Python’, ‘JS’, ‘Python’, ‘Python’,’PHP’, ‘Python’]</p>
<p>输出：Python</p>
<p>方法1：利用字典dict来完成统计</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">most_element</span><span class="params">(language)</span>:</span></span><br><span class="line">    dic = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> language:</span><br><span class="line">        dic[key] = dic.get(key,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">    d = sorted(dic.items(),key = <span class="keyword">lambda</span> i:i[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">    rs = d[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> rs</span><br><span class="line">language = [<span class="string">'PHP'</span>, <span class="string">'PHP'</span>, <span class="string">'Python'</span>, <span class="string">'PHP'</span>, <span class="string">'Python'</span>, <span class="string">'JS'</span>, <span class="string">'Python'</span>, <span class="string">'Python'</span>,<span class="string">'PHP'</span>, <span class="string">'Python'</span>]</span><br><span class="line"></span><br><span class="line">print(most_element(language))</span><br></pre></td></tr></table></figure>

<p>Python</p>
<p>方法2：利用Python的collection包下Counter的类</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">most_element</span><span class="params">(language)</span>:</span></span><br><span class="line">    <span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line">    d = Counter(language)</span><br><span class="line">    <span class="comment"># 取第一个出现频率最高的元素以及他的次数,返回的数据格式是列表里面嵌套元组</span></span><br><span class="line">    c = d.most_common(<span class="number">1</span>)</span><br><span class="line">    rs = c[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> rs</span><br><span class="line">language = [<span class="string">'PHP'</span>, <span class="string">'PHP'</span>, <span class="string">'Python'</span>, <span class="string">'PHP'</span>, <span class="string">'Python'</span>, <span class="string">'JS'</span>, <span class="string">'Python'</span>, <span class="string">'Python'</span>,<span class="string">'PHP'</span>, <span class="string">'Python'</span>]</span><br><span class="line"></span><br><span class="line">print(most_element(language))</span><br></pre></td></tr></table></figure>

<p>Python</p>
<p><strong>datetime模块</strong></p>
<p>1.datatime类</p>
<p>1）<code>datetime.now(tz=None)</code> 获取当前的日期时间，输出顺序为：年、月、日、时、分、秒、微秒。引入datetime模块，调用时，要用datetime.datetime.now()。</p>
<p>2）<code>datetime.timestamp()</code> 获取以 1970年1月1日为起点记录的秒数。</p>
<p>3）<code>datetime.fromtimestamp(tz=None)</code> 使用 unixtimestamp 创建一个 datetime。</p>
<p>4）<code>datetime.strftime(fmt)</code> 格式化 datetime 对象。</p>
<p>5）datetime.date()  返回具有同样 year, month 和 day 值的date对象。</p>
<p>6）datetime.time()  返回具有同样 hour, minute, second, microsecond 和 fold 值的time对象。 tzinfo值为 <code>None</code>。 另请参见timetz()方法。</p>
<p>7）<code>datetime.year</code> 年</p>
<p>8）<code>datetime.month</code> 月</p>
<p>9）<code>datetime.day</code> 日</p>
<p>10）<code>datetime.hour</code> 小时</p>
<p>11）<code>datetime.minute</code> 分钟</p>
<p>12）<code>datetime.second</code> 秒</p>
<p>13）<code>datetime.isoweekday</code> 星期几</p>
<p>在处理含有字符串日期的数据集或表格时，我们需要一种自动解析字符串的方法，无论它是什么格式的，都可以将其转化为 datetime 对象。这时，就要使用到 dateutil 中的 parser 模块。from dateutil import parser</p>
<ul>
<li><code>parser.parse(timestr, parserinfo=None, **kwargs)</code></li>
</ul>
<p>2.date类</p>
<p><code>date.today()</code> 获取当前日期信息。datetime.date.today()</p>
<p>支持的运算：</p>
<table>
<thead>
<tr>
<th align="left">运算</th>
<th align="left">结果：</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>date2 = date1 + timedelta</code></td>
<td align="left"><em>date2</em> 等于从 <em>date1</em> 减去 <code>timedelta.days</code> 天。 (1)</td>
</tr>
<tr>
<td align="left"><code>date2 = date1 - timedelta</code></td>
<td align="left">计算 <em>date2</em> 的值使得 <code>date2 + timedelta == date1</code>。 (2)</td>
</tr>
<tr>
<td align="left"><code>timedelta = date1 - date2</code></td>
<td align="left">(3)</td>
</tr>
<tr>
<td align="left"><code>date1 &lt; date2</code></td>
<td align="left">如果 <em>date1</em> 的时间在 <em>date2</em> 之前则认为 <em>date1</em> 小于 <em>date2</em> 。 (4)</td>
</tr>
</tbody></table>
<p>3.time类</p>
<p>datetime.time() 类   </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">t = datetime.time(<span class="number">12</span>, <span class="number">9</span>, <span class="number">23</span>, <span class="number">12980</span>)</span><br><span class="line">print(t)  <span class="comment"># 12:09:23.012980</span></span><br><span class="line">print(type(t))  <span class="comment"># &lt;class 'datetime.time'&gt;</span></span><br></pre></td></tr></table></figure>

<p>4.timedelta类</p>
<p>​    <code>timedelta</code> 表示具体时间实例中的一段时间。你可以把它们简单想象成两个日期或时间之间的间隔。它常常被用来从 <code>datetime</code> 对象中添加或移除一段特定的时间。</p>
<p>​    如果将两个 datetime 对象相减，就会得到表示该时间间隔的 timedelta 对象。同样地，将两个时间间隔相减，可以得到另一个 timedelta 对象。</p>
<p>timedelta.days()   天数</p>
<p>timedelta.total_seconds()      秒数</p>
<p>5.时间格式转换</p>
<p>1）datetime转换为timestamp：调用timestamp()方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dt = datetime(<span class="number">2015</span>, <span class="number">4</span>, <span class="number">19</span>, <span class="number">12</span>, <span class="number">20</span>) <span class="comment"># 用指定日期时间创建datetime</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dt.timestamp() <span class="comment"># 把datetime转换为timestamp</span></span><br><span class="line"><span class="number">1429417200.0</span></span><br></pre></td></tr></table></figure>

<p>注意：Python的timestamp是一个浮点数，整数位表示秒。</p>
<p>某些编程语言（如Java和JavaScript）的timestamp使用整数表示毫秒数，这种情况下只需要把timestamp除以1000就得到Python的浮点表示方法。</p>
<p>2）timestamp转换为datetime：fromtimestamp()方法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>t = <span class="number">1429417200.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(datetime.fromtimestamp(t))</span><br><span class="line"><span class="number">2015</span><span class="number">-04</span><span class="number">-19</span> <span class="number">12</span>:<span class="number">20</span>:<span class="number">00</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(datetime.utcfromtimestamp(t)) <span class="comment"># UTC时间，也可以直接转换到UTC标准时区的时间</span></span><br><span class="line"><span class="number">2015</span><span class="number">-04</span><span class="number">-19</span> <span class="number">04</span>:<span class="number">20</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure>

<p>注意：timestamp是一个浮点数，它没有时区的概念，而datetime是有时区的。上述转换是在timestamp和本地时间做转换。本地时间是指当前操作系统设定的时区。</p>
<p>3）str转换为datetime：datetime.strptime()</p>
<p>很多时候，用户输入的日期和时间是字符串，要处理日期和时间，首先必须把str转换为datetime。转换方法是通过<code>datetime.strptime()</code>实现，需要一个日期和时间的格式化字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cday = datetime.strptime(<span class="string">'2015-6-1 18:19:59'</span>, <span class="string">'%Y-%m-%d %H:%M:%S'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(cday)</span><br><span class="line"><span class="number">2015</span><span class="number">-06</span><span class="number">-01</span> <span class="number">18</span>:<span class="number">19</span>:<span class="number">59</span></span><br></pre></td></tr></table></figure>

<p>字符串<code>&#39;%Y-%m-%d %H:%M:%S&#39;</code>规定了日期和时间部分的格式。注意转换后的datetime是没有时区信息的。</p>
<p>4）datetime转换为str：strftime()</p>
<p>如果已经有了datetime对象，要把它格式化为字符串显示给用户，就需要转换为str，转换方法是通过<code>strftime()</code>实现的，同样需要一个日期和时间的格式化字符串：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(now.strftime(<span class="string">'%a, %b %d %H:%M'</span>))</span><br><span class="line">Mon, May <span class="number">05</span> <span class="number">16</span>:<span class="number">28</span></span><br></pre></td></tr></table></figure>

<p>5）datetime加减</p>
<p>对日期和时间进行加减实际上就是把datetime往后或往前计算，得到新的datetime。加减可以直接用<code>+</code>和<code>-</code>运算符，不过需要导入<code>timedelta</code>这个类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now</span><br><span class="line">datetime.datetime(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">18</span>, <span class="number">16</span>, <span class="number">57</span>, <span class="number">3</span>, <span class="number">540997</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now + timedelta(hours=<span class="number">10</span>)</span><br><span class="line">datetime.datetime(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">19</span>, <span class="number">2</span>, <span class="number">57</span>, <span class="number">3</span>, <span class="number">540997</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now - timedelta(days=<span class="number">1</span>)</span><br><span class="line">datetime.datetime(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">17</span>, <span class="number">16</span>, <span class="number">57</span>, <span class="number">3</span>, <span class="number">540997</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now + timedelta(days=<span class="number">2</span>, hours=<span class="number">12</span>)</span><br><span class="line">datetime.datetime(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">21</span>, <span class="number">4</span>, <span class="number">57</span>, <span class="number">3</span>, <span class="number">540997</span>)</span><br></pre></td></tr></table></figure>

<p>可见，使用<code>timedelta</code>你可以很容易地算出前几天和后几天的时刻。</p>
<p>6）本地时间转换为UTC时间</p>
<p>本地时间是指系统设定时区的时间，例如北京时间是UTC+8:00时区的时间，而UTC时间指UTC+0:00时区的时间。</p>
<p>一个<code>datetime</code>类型有一个时区属性<code>tzinfo</code>，但是默认为<code>None</code>，所以无法区分这个<code>datetime</code>到底是哪个时区，除非强行给<code>datetime</code>设置一个时区：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta, timezone</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tz_utc_8 = timezone(timedelta(hours=<span class="number">8</span>)) <span class="comment"># 创建时区UTC+8:00</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now = datetime.now()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>now</span><br><span class="line">datetime.datetime(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">871012</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dt = now.replace(tzinfo=tz_utc_8) <span class="comment"># 强制设置为UTC+8:00</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dt</span><br><span class="line">datetime.datetime(<span class="number">2015</span>, <span class="number">5</span>, <span class="number">18</span>, <span class="number">17</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">871012</span>, tzinfo=datetime.timezone(datetime.timedelta(<span class="number">0</span>, <span class="number">28800</span>)))</span><br></pre></td></tr></table></figure>

<p>如果系统时区恰好是UTC+8:00，那么上述代码就是正确的，否则，不能强制设置为UTC+8:00时区。</p>
<p>7）时区转换</p>
<p>我们可以先通过<code>utcnow()</code>拿到当前的UTC时间，再转换为任意时区的时间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 拿到UTC时间，并强制设置时区为UTC+0:00:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>utc_dt = datetime.utcnow().replace(tzinfo=timezone.utc)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(utc_dt)</span><br><span class="line"><span class="number">2015</span><span class="number">-05</span><span class="number">-18</span> <span class="number">09</span>:<span class="number">05</span>:<span class="number">12.377316</span>+<span class="number">00</span>:<span class="number">00</span></span><br><span class="line"><span class="comment"># astimezone()将转换时区为北京时间:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bj_dt = utc_dt.astimezone(timezone(timedelta(hours=<span class="number">8</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(bj_dt)</span><br><span class="line"><span class="number">2015</span><span class="number">-05</span><span class="number">-18</span> <span class="number">17</span>:<span class="number">05</span>:<span class="number">12.377316</span>+<span class="number">08</span>:<span class="number">00</span></span><br><span class="line"><span class="comment"># astimezone()将转换时区为东京时间:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokyo_dt = utc_dt.astimezone(timezone(timedelta(hours=<span class="number">9</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(tokyo_dt)</span><br><span class="line"><span class="number">2015</span><span class="number">-05</span><span class="number">-18</span> <span class="number">18</span>:<span class="number">05</span>:<span class="number">12.377316</span>+<span class="number">09</span>:<span class="number">00</span></span><br><span class="line"><span class="comment"># astimezone()将bj_dt转换时区为东京时间:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>tokyo_dt2 = bj_dt.astimezone(timezone(timedelta(hours=<span class="number">9</span>)))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(tokyo_dt2)</span><br><span class="line"><span class="number">2015</span><span class="number">-05</span><span class="number">-18</span> <span class="number">18</span>:<span class="number">05</span>:<span class="number">12.377316</span>+<span class="number">09</span>:<span class="number">00</span></span><br></pre></td></tr></table></figure>

<p>时区转换的关键在于，拿到一个<code>datetime</code>时，要获知其正确的时区，然后强制设置时区，作为基准时间。利用带时区的<code>datetime</code>，通过<code>astimezone()</code>方法，可以转换到任意时区。</p>
<p>注：不是必须从UTC+0:00时区转换到其他时区，任何带时区的<code>datetime</code>都可以正确转换，例如上述<code>bj_dt</code>到<code>tokyo_dt</code>的转换。</p>
<p>5.练习题</p>
<p>1）假设你获取了用户输入的日期和时间如<code>2020-1-21 9:01:30</code>，以及一个时区信息如<code>UTC+5:00</code>，均是<code>str</code>，请编写一个函数将其转换为timestamp：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">Input file</span></span><br><span class="line"><span class="string">example1: dt_str='2020-6-1 08:10:30', tz_str='UTC+7:00'</span></span><br><span class="line"><span class="string">example2: dt_str='2020-5-31 16:10:30', tz_str='UTC-09:00'</span></span><br><span class="line"><span class="string">   </span></span><br><span class="line"><span class="string">Output file</span></span><br><span class="line"><span class="string">result1: 1590973830.0</span></span><br><span class="line"><span class="string">result2: 1590973830.0</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime,timedelta,timezone</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_timestamp</span><span class="params">(dt_str, tz_str)</span>:</span></span><br><span class="line">    dt = datetime.strptime(dt_str, <span class="string">'%Y-%m-%d %H:%M:%S'</span>)</span><br><span class="line">    <span class="comment"># 转换后的datetime是没有时区信息的，需要设置时区</span></span><br><span class="line">    <span class="comment"># 通过正则获取用户输入的时区</span></span><br><span class="line">    time_zone_num = re.match(<span class="string">r'UTC([+|-][\d]&#123;1,2&#125;):00'</span>,tz_str).group(<span class="number">1</span>)</span><br><span class="line">    tz_utc = timezone(timedelta(hours=int(time_zone_num)))</span><br><span class="line">    <span class="comment"># 将用户输入的时间强制设置为输入的时区，给tzinfo属性赋值</span></span><br><span class="line">    dt1 = dt.replace(tzinfo=tz_utc)</span><br><span class="line">    <span class="comment"># 转换为timestamp</span></span><br><span class="line">    dt2 = dt1.timestamp()</span><br><span class="line">    <span class="keyword">return</span> dt2</span><br><span class="line"></span><br><span class="line">dt_str=<span class="string">'2020-6-1 08:10:30'</span></span><br><span class="line">tz_str=<span class="string">'UTC+7:00'</span></span><br><span class="line">print(to_timestamp(dt_str,tz_str))</span><br><span class="line"></span><br><span class="line">dt_str=<span class="string">'2020-5-31 16:10:30'</span></span><br><span class="line">tz_str=<span class="string">'UTC-09:00'</span></span><br><span class="line">print(to_timestamp(dt_str,tz_str))</span><br></pre></td></tr></table></figure>

<p>1590973830.0<br>1590973830.0</p>
<p>2）编写Python程序以选择指定年份的所有星期日。</p>
<p>题目说明:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime,timedelta,date</span><br><span class="line">a = int(input())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">all_sundays</span><span class="params">(year)</span>:</span></span><br><span class="line">    dt1 = date(year,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">    dt2 = date(year,<span class="number">12</span>,<span class="number">31</span>)</span><br><span class="line">    td = (dt2-dt1).days</span><br><span class="line">    a = dt1.isoweekday()</span><br><span class="line">    i = <span class="number">7</span>-a</span><br><span class="line">    <span class="keyword">while</span> i&lt;=td:</span><br><span class="line">        day = dt1 + timedelta(days=i)</span><br><span class="line">        print(day)</span><br><span class="line">        i += <span class="number">7</span></span><br><span class="line"></span><br><span class="line">all_sundays(a)</span><br></pre></td></tr></table></figure>

<p>2020<br>2020-01-05<br>2020-01-12<br>2020-01-19<br>2020-01-26<br>2020-02-02<br>2020-02-09<br>2020-02-16<br>2020-02-23<br>2020-03-01<br>2020-03-08<br>2020-03-15<br>2020-03-22<br>2020-03-29<br>2020-04-05<br>2020-04-12<br>2020-04-19<br>2020-04-26<br>2020-05-03<br>2020-05-10<br>2020-05-17<br>2020-05-24<br>2020-05-31<br>2020-06-07<br>2020-06-14<br>2020-06-21<br>2020-06-28<br>2020-07-05<br>2020-07-12<br>2020-07-19<br>2020-07-26<br>2020-08-02<br>2020-08-09<br>2020-08-16<br>2020-08-23<br>2020-08-30<br>2020-09-06<br>2020-09-13<br>2020-09-20<br>2020-09-27<br>2020-10-04<br>2020-10-11<br>2020-10-18<br>2020-10-25<br>2020-11-01<br>2020-11-08<br>2020-11-15<br>2020-11-22<br>2020-11-29<br>2020-12-06<br>2020-12-13<br>2020-12-20<br>2020-12-27</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/07/Python-Task08/" data-id="ckdjx2wel0000r0wc99eqej1t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Python-Task07" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/05/Python-Task07/" class="article-date">
  <time datetime="2020-08-05T15:20:52.000Z" itemprop="datePublished">2020-08-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/05/Python-Task07/">Python-Task07</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Python编程基础-Task07"><a href="#Python编程基础-Task07" class="headerlink" title="Python编程基础-Task07"></a>Python编程基础-Task07</h1><h2 id="Task-7-类、对象与魔法方法"><a href="#Task-7-类、对象与魔法方法" class="headerlink" title="Task 7:类、对象与魔法方法"></a>Task 7:类、对象与魔法方法</h2><p><strong>类与对象</strong></p>
<p>1.对象=属性+方法</p>
<p>对象是类的实例。</p>
<p>封装：我们可以使用关键字class定义Python类，关键字后面紧跟类的名称、分号和类的实现。</p>
<p>Python中的类名约定以大写字母开头。</p>
<p>继承：子类自动共享父类之间数据和方法的机制。</p>
<p>多态：不同对象对不同方法响应不同的行动。</p>
<p>2.Self   Python 的 <code>self</code> 相当于 C++ 的 <code>this</code> 指针。</p>
<p>类的方法与普通的函数只有一个特别的区别 —— 它们必须有一个额外的第一个参数名称（对应于该实例，即该对象本身），按照惯例它的名称是 <code>self</code>。在调用方法时，我们无需明确提供与参数 <code>self</code> 相对应的参数。</p>
<p>3.Python的魔法方法</p>
<p>​    最基本的魔法方法就是<code>__init__</code>，我们可以用它来指明一个对象初始化的行为。然而，当我们调用 x = SomeClass() 的时候， <code>__init__</code> 并不是第一个被调用的方法。事实上，第一个被调用的是 <code>__new__</code>，这个 方法才真正地创建了实例。当这个对象的生命周期结束的时候， <code>__del__</code> 会被调用。让我们近一步理解这三个方法：</p>
<ul>
<li><p><code>__new__(cls,[...)</code> </p>
<p><code>__new__</code> 是对象实例化时第一个调用的方法，它只取下 cls 参数，并把其他参数传给<code>__init__</code>。 <code>__new__</code>很少使用，但是也有它适合的场景，尤其是当类继承自一个像元组或者字符串这样不经常改变的类型的时候。</p>
</li>
<li><p><code>__init__(self,[...])</code>        构造函数，在生成对象时调用</p>
<p>类的初始化方法。它获取任何传给构造器的参数（比如我们调用 x = SomeClass(10, ‘foo’) ， <code>__init__</code>就会接到参数 10 和 ‘foo’ 。 <code>__init__</code>在Python的类定义中用的最多。</p>
</li>
<li><p><code>__del__(self)</code>       析构函数，释放对象时使用</p>
<p><code>__new__</code>和 <code>__init__</code> 是对象的构造器， <code>__del__</code>是对象的销毁器。它并非实现了语句 del x (因此该语句不等同于 x.<strong>del</strong>())。而是定义了当对象被垃圾回收时的行为。 当对象需要在销毁时做一些处理的时候这个方法很有用，比如 socket 对象、文件对象。但是需要注意的是，当Python解释器退出但对象仍然存活的时候， <code>__del__</code> 并不会 执行。 所以养成一个手工清理的好习惯是很重要的，比如及时关闭连接。</p>
</li>
</ul>
<p><strong><strong>call</strong>(self[, args…])</strong>允许一个类的实例像函数一样被调用：x(a, b) 调用 x.<strong>call</strong>(a, b)</p>
<p><strong><strong>len</strong>(self)</strong>定义当被 len() 调用时的行为，获得长度。</p>
<p><strong>repr</strong>(self)定义当被 repr() 调用时的行为，打印，转换。</p>
<p><strong><strong>str</strong>(self)</strong>定义当被 str() 调用时的行为</p>
<p><strong>bytes</strong>(self)定义当被 bytes() 调用时的行为</p>
<p><strong><strong>hash</strong>(self)</strong>定义当被 hash() 调用时的行为</p>
<p><strong><strong>bool</strong>(self)</strong>定义当被 bool() 调用时的行为，应该返回 True 或 False</p>
<p><strong><strong>format</strong>(self, format_spec)</strong>定义当被 format() 调用时的行为</p>
<p><strong><strong>setitem</strong> :</strong> 按照索引赋值</p>
<p><strong><strong>getitem</strong>:</strong> 按照索引获取值</p>
<p><strong><strong>cmp</strong>:</strong> 比较运算</p>
<p><strong><strong>add</strong>:</strong> 加运算</p>
<p><strong><strong>sub</strong>:</strong> 减运算</p>
<p><strong><strong>mul</strong>:</strong> 乘运算</p>
<p><strong><strong>truediv</strong>:</strong> 除运算</p>
<p><strong><strong>mod</strong>:</strong> 求余运算</p>
<p><strong><strong>pow</strong>:</strong> 乘方</p>
<p>4.公有和私有</p>
<p>在 Python 中定义私有变量只需要在变量名或函数名前加上“__”两个下划线。</p>
<p>​    以这种格式定义的方法或变量一般来说应当是仅供类的内部调用。对于以这种格式定义的私有属性，python并没有强制性的访问限制，而是采用了所谓的<strong>名字改编(name mangling)</strong>。名字改编指的是Python会将类中定义的所有以至少两个下划线开头，至多一个下划线结尾的属性(包括方法和变量)的名称改编为<code>_类名__方法名</code>的格式。例如对于<code>__func()</code>，其会被改编为<code>_classname__func()</code>。_注意在改编的时候，类名中包含的所有前缀下划线都将被忽略。_只要在类中定义了符合上述格式的属性，不论该属性是方法还是变量，这一名字改编的过程总是会发生。另外，名字改编还可以使得子类在重载父类的方法时避免产生命名冲突。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">foo</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__var = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__bar</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'bar'</span>)</span><br><span class="line"></span><br><span class="line">f = foo()</span><br><span class="line"></span><br><span class="line">hasattr(f, <span class="string">'__bar'</span>)  <span class="comment"># False</span></span><br><span class="line">hasattr(f, <span class="string">'_foo__bar'</span>)  <span class="comment">#True</span></span><br><span class="line">hasattr(f, <span class="string">'__var'</span>)  <span class="comment"># False</span></span><br><span class="line">hasattr(f, <span class="string">'_foo__var'</span>)  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line">f.__bar()  <span class="comment"># AttributeError: 'foo' object has no attribute '__bar'  不能直接访问</span></span><br><span class="line">f._foo__bar()  <span class="comment"># will print out 'bar'  换个名字就可以访问了</span></span><br><span class="line">f._foo_var  <span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<p>5.继承</p>
<p>继承父类时，如果重写了子类的<code>__init__</code>，也就是子类的构造方法把父类的构造方法覆盖了，此时如果还想用父类的<code>__init__</code>中定义的属性，有两种方式：</p>
<ul>
<li><p>调用未绑定的父类方法<code>Fish.__init__(self)</code>，传入self参数，通过父类.方法名调用，此时的self是作为子类的属性传入。</p>
</li>
<li><p>使用super函数<code>super().__init__()</code>，不传self参数。super() 函数是用于调用父类(超类)的一个方法。</p>
</li>
</ul>
<p>python对大小写是敏感的。</p>
<p>6.组合</p>
<p>类的组合，是指一个类的属性直接是另外一个类的实例。</p>
<p>一个类被定义后，目标就是把它当成一个模块来使用，并把这些对象嵌入到你的代码中去，同其他数据类型及逻辑执行流混合使用。<br>有两种方法可以在你的代码中利用类。<br>第一种是组合，就是让不同的类混合并加入到其他类中，来增强功能和代码重用性。你可以在一个大点的类中创建你自己的类的实例，实现一些其他属性和方法来增强原来的类对象。<br>另一种是派生，通过子类从基类继承核心属性，不断地派生扩展功能实现。</p>
<p><strong>关于类的组合与类的继承的选择问题</strong></p>
<ul>
<li>类的继承和组合都是将别的类的属性或者方法拿过来用</li>
<li>使用组合的情况:当类之间有显著不同，并且较小的类是较大类所需要的组件时候，就可以用组合</li>
<li>使用继承的情况:当类与类之间有相同的功能，提取这些共同的功能做成基类，用继承比较好</li>
</ul>
<p>7.类、类对象和实例对象</p>
<p>类对象：创建一个类，其实也是一个对象也在内存开辟了一块空间，称为类对象，类对象只有一个。</p>
<p>实例对象：就是通过实例化类创建的对象，称为实例对象，实例对象可以有多个。</p>
<p>类属性：类里面方法外面定义的变量称为类属性。类属性所属于类对象并且多个实例对象之间共享同一个类属性，说白了就是类属性所有的通过该类实例化的对象都能共享。</p>
<p>实例属性：实例属性和具体的某个实例对象有关系，并且一个实例对象和另外一个实例对象是不共享属性的，说白了实例属性只能在自己的对象里面使用，其他的对象不能直接使用，因为<code>self</code>是谁调用，它的值就属于该对象。</p>
<p>类属性和实例属性区别</p>
<ul>
<li>类属性：类外面，可以通过<code>实例对象.类属性</code>和<code>类名.类属性</code>进行调用。类里面，通过<code>self.类属性</code>和<code>类名.类属性</code>进行调用。</li>
<li>实例属性 ：类外面，可以通过<code>实例对象.实例属性</code>调用。类里面，通过<code>self.实例属性</code>调用。</li>
<li>实例属性就相当于局部变量。出了这个类或者这个类的实例对象，就没有作用了。</li>
<li>类属性就相当于类里面的全局变量，可以和这个类的所有实例对象共享。</li>
</ul>
<p>注意：属性与方法名相同时，属性会覆盖方法。</p>
<p>8.绑定</p>
<p>Python 严格要求方法需要有实例才能被调用。</p>
<p>self参数的作用是绑定方法，有了这个参数，Python 可以分清是哪个对象在调用方法和属性，可以认为方法中的 self 其实就是实例对象的唯一标志。</p>
<p>Python 对象的数据属性通常存储在名为<code>.__ dict__</code>的字典中，我们可以直接访问<code>__dict__</code>，或利用 Python 的内置函数<code>vars()</code>获取<code>.__ dict__</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CC</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setXY</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">printXY</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(self.x, self.y)</span><br><span class="line"></span><br><span class="line">dd = CC()</span><br><span class="line">print(dd.__dict__)</span><br><span class="line"><span class="comment"># &#123;&#125;</span></span><br><span class="line">print(vars(dd))</span><br><span class="line"><span class="comment"># &#123;&#125;</span></span><br><span class="line">print(CC.__dict__)</span><br><span class="line"><span class="comment"># &#123;'__module__': '__main__', 'setXY': &lt;function CC.setXY at 0x000000C3473DA048&gt;, 'printXY': &lt;function CC.printXY at 0x000000C3473C4F28&gt;, '__dict__': &lt;attribute '__dict__' of 'CC' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'CC' objects&gt;, '__doc__': None&#125;</span></span><br><span class="line">dd.setXY(<span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">print(dd.__dict__)</span><br><span class="line"><span class="comment"># &#123;'x': 4, 'y': 5&#125;</span></span><br><span class="line">print(vars(CC))</span><br><span class="line"><span class="comment"># &#123;'__module__': '__main__', 'setXY': &lt;function CC.setXY at 0x000000632CA9B048&gt;, 'printXY': &lt;function CC.printXY at 0x000000632CA83048&gt;, '__dict__': &lt;attribute '__dict__' of 'CC' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'CC' objects&gt;, '__doc__': None&#125;</span></span><br><span class="line">print(CC.__dict__)</span><br><span class="line"><span class="comment"># &#123;'__module__': '__main__', 'setXY': &lt;function CC.setXY at 0x000000632CA9B048&gt;, 'printXY': &lt;function CC.printXY at 0x000000632CA83048&gt;, '__dict__': &lt;attribute '__dict__' of 'CC' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'CC' objects&gt;, '__doc__': None&#125;</span></span><br></pre></td></tr></table></figure>

<p>9.一些相关的内置函数（BIF）</p>
<p>1）<code>issubclass(class, classinfo)</code> 方法用于判断参数 class 是否是类型参数 classinfo 的子类。一个类被认为是其自身的子类。<code>classinfo</code>可以是类对象的元组，只要class是其中任何一个候选类的子类，则返回<code>True</code>。</p>
<p>2）<code>isinstance(object, classinfo)</code> 方法用于判断一个对象是否是一个已知的类型，类似<code>type()</code>。但是，<code>type()</code>不会认为子类是一种父类类型，不考虑继承关系；<code>isinstance()</code>会认为子类是一种父类类型，考虑继承关系。（如果第一个参数不是对象，则永远返回<code>False</code>。如果第二个参数不是类或者由类对象组成的元组，会抛出一个<code>TypeError</code>异常。）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line">print(isinstance(a, int))  <span class="comment"># True</span></span><br><span class="line">print(isinstance(a, str))  <span class="comment"># False</span></span><br><span class="line">print(isinstance(a, (str, int, list)))  <span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(isinstance(A(), A))  <span class="comment"># True</span></span><br><span class="line">print(type(A()) == A)  <span class="comment"># True</span></span><br><span class="line">print(isinstance(B(), A))  <span class="comment"># True</span></span><br><span class="line">print(type(B()) == A)  <span class="comment"># False</span></span><br></pre></td></tr></table></figure>

<p>3）<code>hasattr(object, name)</code>用于判断对象是否包含对应的属性。</p>
<p>4）<code>getattr(object, name[, default])</code>用于返回一个对象属性值。如果没有该属性，则返回default。name可以传 方法名，则返回的是方法。可以调用该方法。</p>
<p>5）<code>setattr(object, name, value)</code>对应函数 <code>getattr()</code>，用于设置属性值，该属性不一定是存在的。</p>
<p>6）<code>delattr(object, name)</code>用于删除属性。</p>
<p>7）<code>class property([fget[, fset[, fdel[, doc]]]])</code>用于在新式类中返回属性值。<code>fget</code> – 获取属性值的函数；<code>fset</code> – 设置属性值的函数；<code>fdel</code> – 删除属性值函数；<code>doc</code> – 属性描述信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__x = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getx</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setx</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.__x = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delx</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">del</span> self.__x</span><br><span class="line"></span><br><span class="line">    x = property(getx, setx, delx, <span class="string">"I'm the 'x' property."</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cc = C()</span><br><span class="line">cc.x = <span class="number">2</span></span><br><span class="line">print(cc.x)  <span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> cc.x</span><br><span class="line">print(cc.x)</span><br><span class="line"><span class="comment"># AttributeError: 'C' object has no attribute '_C__x'</span></span><br></pre></td></tr></table></figure>



<p>10.练习题</p>
<p>1）以下类定义中哪些是类属性，哪些是实例属性？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.x = <span class="number">4</span></span><br><span class="line">        self.y = <span class="number">5</span></span><br><span class="line">        C.count = <span class="number">6</span></span><br></pre></td></tr></table></figure>

<p>num、count是类属性；x、y是实例属性。</p>
<p>2）怎么定义私有⽅法？</p>
<p>前面加两个下划线。</p>
<p>3）执行以下代码，并解释错误原因：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myFun</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">'Hello!'</span>)</span><br><span class="line">    c = C()</span><br><span class="line">    c.myFun()</span><br></pre></td></tr></table></figure>

<p>定义方法时，没有self参数；类内写了创建类实例和调用实例的方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">myFun</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Hello!'</span>)</span><br><span class="line">c = C()</span><br><span class="line">c.myFun()</span><br></pre></td></tr></table></figure>

<p>4）按照以下要求定义一个游乐园门票的类，并尝试计算2个成人+1个小孩平日票价。</p>
<p>要求:</p>
<ul>
<li>平日票价100元</li>
<li>周末票价为平日的120%</li>
<li>儿童票半价</li>
</ul>
<p>实现1：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># your code here</span></span><br><span class="line"></span><br><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.price = <span class="number">100</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">weekendPrice</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.price *= <span class="number">1.2</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">kidsPrice</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.price *= <span class="number">0.5</span></span><br><span class="line">adult = Ticket()</span><br><span class="line">kid = Ticket()</span><br><span class="line">kid.kidsPrice()</span><br><span class="line">print(adult.price * <span class="number">2</span>+kid.price)</span><br></pre></td></tr></table></figure>

<p>250.0</p>
<p>实现2：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, weekend=False, child=False)</span>:</span></span><br><span class="line">        self.price = <span class="number">100</span></span><br><span class="line">        <span class="keyword">if</span> weekend:</span><br><span class="line">            self.w = <span class="number">1.2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.w = <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> child:</span><br><span class="line">            self.discount = <span class="number">0.5</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.discount = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clacPrice</span><span class="params">(self,num)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.price * self.w * self.discount * num</span><br><span class="line"></span><br><span class="line">adult = Ticket()</span><br><span class="line">child = Ticket(child=<span class="literal">True</span>)</span><br><span class="line">print(<span class="string">"2个成人+1个小孩平日票价为：%.2f"</span>% (adult.clacPrice(<span class="number">2</span>) + child.clacPrice(<span class="number">1</span>)))</span><br></pre></td></tr></table></figure>

<p>2个成人+1个小孩平日票价为：250.00</p>
<p>实现3：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ticket</span>:</span></span><br><span class="line">    price = <span class="number">100</span></span><br><span class="line">    weekend = price*<span class="number">1.2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">(self, adultcount, childcount, isweekend)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isweekend == <span class="string">'no'</span>:</span><br><span class="line">            total = int(adultcount) * self.price + int(childcount)*self.price/<span class="number">2</span></span><br><span class="line">            print(<span class="string">"应该支付金额："</span>, str(total))</span><br><span class="line">        <span class="keyword">elif</span> isweekend ==<span class="string">'yes'</span>:</span><br><span class="line">            total = int(adultcount) * self.weekend + int(childcount)*self.weekend/<span class="number">2</span></span><br><span class="line">            print(<span class="string">"应该支付金额："</span>, str(total))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"输入有误！"</span>)</span><br><span class="line"></span><br><span class="line">adult = input(<span class="string">"请输入成年人数量"</span>)</span><br><span class="line">child = input(<span class="string">"请输入小孩数量"</span>)</span><br><span class="line">isweekend = input(<span class="string">"是否是周末？yes/no"</span>)</span><br><span class="line">t = Ticket()</span><br><span class="line">t.compute(adult, child, isweekend)</span><br></pre></td></tr></table></figure>

<p>请输入成年人数量2<br>请输入小孩数量1<br>是否是周末？yes/nono<br>应该支付金额： 250.0</p>
<p><strong>魔法方法</strong></p>
<p>​    魔法方法总是被双下划线包围，例如<code>__init__</code>。魔法方法的“魔力”体现在它们总能够在适当的时候被自动调用。</p>
<p>​    魔法方法的第一个参数应为<code>cls</code>（类方法） 或者<code>self</code>（实例方法）。</p>
<ul>
<li><code>cls</code>：代表一个类的名称</li>
<li><code>self</code>：代表一个实例对象的名称</li>
</ul>
<p>1.基本的魔法方法</p>
<p>1）<code>__init__(self[, ...])</code> 构造器，当一个实例被创建的时候调用的初始化方法</p>
<p>2）<code>__new__(cls[, ...])</code> 在一个对象实例化的时候所调用的第一个方法，在调用<code>__init__</code>初始化前，先调用<code>__new__</code>。</p>
<ul>
<li><code>__new__</code>至少要有一个参数<code>cls</code>，代表要实例化的类，此参数在实例化时由 Python 解释器自动提供，后面的参数直接传递给<code>__init__</code>。</li>
<li><code>__new__</code>对当前类进行了实例化，并将实例返回，传给<code>__init__</code>的<code>self</code>。但是，执行了<code>__new__</code>，并不一定会进入<code>__init__</code>，只有<code>__new__</code>返回的是当前类<code>cls</code>的实例，当前类的<code>__init__</code>才会进入。也就是说，在init()调用之前，new()决定是否要使用该init()方法，因为new()可以调用其他类的构造方法或者直接返回别的对象来作为本类 的实例。 </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,value)</span>:</span></span><br><span class="line">        print(<span class="string">"into A __init__"</span>)</span><br><span class="line">        self.value = value</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"into A __new__"</span>)</span><br><span class="line">        print(cls)</span><br><span class="line">        <span class="keyword">return</span> object.__new__(cls)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        print(<span class="string">"into B __init__"</span>)</span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls,*args,**kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"into B __new__"</span>)</span><br><span class="line">        print(cls)</span><br><span class="line">        <span class="keyword">return</span> super().__new__(cls,*args,**kwargs)    <span class="comment"># __new__返回了当前类cls的实例，当前类的__init__才会进入。</span></span><br><span class="line"></span><br><span class="line">b = B(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">into B __new__</span><br><span class="line">&lt;class &#39;__main__.B&#39;&gt;</span><br><span class="line">into A __new__</span><br><span class="line">&lt;class &#39;__main__.B&#39;&gt;</span><br><span class="line">into B __init__</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,value)</span>:</span></span><br><span class="line">        print(<span class="string">"into A __init__"</span>)</span><br><span class="line">        self.value = value</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"into A __new__"</span>)</span><br><span class="line">        print(cls)</span><br><span class="line">        <span class="keyword">return</span> object.__new__(cls)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        print(<span class="string">"into B __init__"</span>)</span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls,*args,**kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"into B __new__"</span>)</span><br><span class="line">        print(cls)</span><br><span class="line">        <span class="keyword">return</span> super().__new__(A,*args,**kwargs)  <span class="comment"># 若__new__没有正确返回当前类cls的实例，那__init__是不会被调用的，即使是父类的实例也不行，将没有__init__被调用。</span></span><br><span class="line"></span><br><span class="line">b = B(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">into B __new__</span><br><span class="line">&lt;class &#39;__main__.B&#39;&gt;</span><br><span class="line">into A __new__</span><br><span class="line">&lt;class &#39;__main__.A&#39;&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,value)</span>:</span></span><br><span class="line">        print(<span class="string">"into A __init__"</span>)</span><br><span class="line">        self.value = value</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"into A __new__"</span>)</span><br><span class="line">        print(cls)</span><br><span class="line">        <span class="keyword">return</span> object.__new__(cls)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        print(<span class="string">"into B __init__"</span>)</span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls,*args,**kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"into B __new__"</span>)</span><br><span class="line">        print(cls)</span><br><span class="line">        <span class="keyword">return</span> super().__new__(B,*args,**kwargs)   <span class="comment"># 再改__new__返回当前类B的实例，那B的__init__会被调用。与传入'cls'结果一样。</span></span><br><span class="line"></span><br><span class="line">b = B(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">into B __new__</span><br><span class="line">&lt;class &#39;__main__.B&#39;&gt;</span><br><span class="line">into A __new__</span><br><span class="line">&lt;class &#39;__main__.B&#39;&gt;</span><br><span class="line">into B __init__</span><br></pre></td></tr></table></figure>

<p>new()方法的特性：</p>
<p>new()方法是在类准备将自身实例化时调用。 </p>
<p>new()方法始终都是类的静态方法，即使没有被加上静态方法装饰器。</p>
<p>什么情况下使用 <strong>new</strong>() 呢？答案很简单，在 <strong>init</strong>() 不够用的时候。例如，对 Python 不可变的内置类型（如 int、str、float 等）进行子类化，这是因为一旦创建了这样不可变的对象实例，就无法在 <strong>init</strong>() 方法中对其进行修改。</p>
<p><code>__new__</code>方法主要是当你继承一些不可变的 class 时（比如<code>int, str, tuple</code>）， 提供给你一个自定义这些类的实例化过程的途径：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CapStr</span><span class="params">(str)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls,string)</span>:</span></span><br><span class="line">        string = string.upper()</span><br><span class="line">        <span class="keyword">return</span> str.__new__(cls,string)</span><br><span class="line">    </span><br><span class="line">a = CapStr(<span class="string">"i love lsgogroup"</span>)</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>

<p>结果： I LOVE LSGOGROUP</p>
<p>可以利用<code>__new__</code>实现单例模式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Earth</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">a = Earth()</span><br><span class="line">print(id(a))</span><br><span class="line">b = Earth()</span><br><span class="line">print(id(b))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Earth</span>:</span></span><br><span class="line">    __instance = <span class="literal">None</span>   <span class="comment"># 定义一个类属性做判断</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls.__instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls.__instance = object.__new__(cls)</span><br><span class="line">            <span class="keyword">return</span> cls.__instance</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> cls.__instance</span><br><span class="line"></span><br><span class="line">a = Earth()</span><br><span class="line">print(id(a))</span><br><span class="line">b = Earth()</span><br><span class="line">print(id(b))</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1737562503208</span><br><span class="line">1737562503264</span><br><span class="line">1737562493112</span><br><span class="line">1737562493112</span><br></pre></td></tr></table></figure>

<p>3）<code>__del__(self)</code> 析构器，当一个对象将要被系统回收之时调用的方法。</p>
<p>Python 采用自动引用计数（简称 ARC）的方式实现垃圾回收GC机制。该方法的核心思想是：每个 Python 对象都会配置一个计数器，初始 Python 实例对象的计数器值都为 0，如果有变量引用该实例对象，其计数器的值会加 1，依次类推；反之，每当一个变量取消对该实例对象的引用，计数器会减 1。如果一个 Python 对象的的计数器值为 0，则表明没有变量引用该 Python 对象，即证明程序不再需要它，此时 Python 就会自动调用 <code>__del__</code>() 方法将其回收。</p>
<p>4）<code>__str__(self)</code>：当你打印一个对象的时候；当你使用%s格式化的时候；str强转数据类型的时候，都会触发<code>__str__</code>。</p>
<p>5）<code>__repr__(self)</code>：</p>
<ul>
<li><p><code>repr</code>是<code>str</code>的备胎</p>
</li>
<li><p>有<code>__str__</code>的时候执行<code>__str__</code>,没有实现<code>__str__</code>的时候，执行<code>__repr__</code></p>
</li>
<li><p><code>repr(obj)</code>内置函数对应的结果是<code>__repr__</code>的返回值</p>
</li>
<li><p>当你使用<code>%r</code>格式化的时候 触发<code>__repr__</code></p>
</li>
</ul>
<p>  <code>__str__(self)</code> 和<code>__repr__(self)</code> 对比：</p>
<p>  1 <code>__str__(self)</code> 的返回结果可读性强。<code>__str__</code> 的意义是得到便于人们阅读的信息，就像下面的 ‘2019-10-11’ 一样。</p>
<p>  2 <code>__repr__(self)</code> 的返回结果应更准确。<code>__repr__</code> 存在的目的在于调试，便于开发者使用。</p>
<p>【例子】</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line">today = datetime.date.today()</span><br><span class="line">print(str(today))  <span class="comment"># 2019-10-11</span></span><br><span class="line">print(repr(today))  <span class="comment"># datetime.date(2019, 10, 11)</span></span><br><span class="line">print(<span class="string">'%s'</span> %today)  <span class="comment"># 2019-10-11</span></span><br><span class="line">print(<span class="string">'%r'</span> %today)  <span class="comment"># datetime.date(2019, 10, 11)</span></span><br></pre></td></tr></table></figure>

<p>2.算术运算符</p>
<p>类型工厂函数，指的是“不通过类而是通过函数来创建对象”。</p>
<p>1）<strong>add</strong>(self, other)<code>定义加法的行为：</code>+</p>
<p>2）<strong>sub</strong>(self, other)<code>定义减法的行为：</code>-</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,height,weight)</span>:</span></span><br><span class="line">        self.height = height</span><br><span class="line">        self.weight = weight</span><br><span class="line">    <span class="comment"># 两个对象的长相加，宽不变，返回一个新的类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span><span class="params">(self,others)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> MyClass(self.height + others.height, self.weight)</span><br><span class="line">    <span class="comment"># 两个对象的宽相减，长不变，返回一个新的类</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__sub__</span><span class="params">(self,others)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> MyClass(self.height, self.weight-others.weight)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">intro</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"高为"</span>, self.height, <span class="string">"重为"</span>, self.weight)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    a = MyClass(<span class="number">10</span>,<span class="number">5</span>)</span><br><span class="line">    a.intro()</span><br><span class="line">    b = MyClass(<span class="number">20</span>,<span class="number">10</span>)</span><br><span class="line">    b.intro()</span><br><span class="line">    c = b-a</span><br><span class="line">    c.intro()</span><br><span class="line">    d = a+b</span><br><span class="line">    d.intro()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>

<p>高为 10 重为 5<br>高为 20 重为 10<br>高为 20 重为 5<br>高为 30 重为 5</p>
<p>3）<code>__mul__(self, other)</code>定义乘法的行为：<code>*</code></p>
<p>4）<code>__truediv__(self, other)</code>定义真除法的行为：<code>/</code></p>
<p>5）<strong>floordiv</strong>(self, other)<code>定义整数除法的行为：</code>//</p>
<p>6）<strong>mod</strong>(self, other)<code>定义取模算法的行为：</code>%</p>
<p>7）<code>__divmod__(self, other)</code>定义当被 <code>divmod()</code> 调用时的行为</p>
<p>8）<code>divmod(a, b)</code>把除数和余数运算结果结合起来，返回一个包含商和余数的元组<code>(a // b, a % b)</code>。</p>
<p>9）<code>__pow__(self, other[, module])</code>定义当被 <code>power()</code> 调用或 <code>**</code> 运算时的行为</p>
<p>10）<code>__lshift__(self, other)</code>定义按位左移位的行为：<code>&lt;&lt;</code></p>
<p>11）<code>__rshift__(self, other)</code>定义按位右移位的行为：<code>&gt;&gt;</code></p>
<p>12）<code>__and__(self, other)</code>定义按位与操作的行为：<code>&amp;</code></p>
<p>13）<code>__xor__(self, other)</code>定义按位异或操作的行为：<code>^</code></p>
<p>14）<code>__or__(self, other)</code>定义按位或操作的行为：<code>|</code></p>
<p>3.反算术运算符</p>
<p>反运算魔方方法，与算术运算符保持一一对应，不同之处就是反运算的魔法方法多了一个“r”。当文件左操作不支持相应的操作时被调用。</p>
<ul>
<li><code>__radd__(self, other)</code>定义加法的行为：<code>+</code></li>
<li><code>__rsub__(self, other)</code>定义减法的行为：<code>-</code></li>
<li><code>__rmul__(self, other)</code>定义乘法的行为：<code>*</code></li>
<li><code>__rtruediv__(self, other)</code>定义真除法的行为：<code>/</code></li>
<li><code>__rfloordiv__(self, other)</code>定义整数除法的行为：<code>//</code></li>
<li><code>__rmod__(self, other)</code> 定义取模算法的行为：<code>%</code></li>
<li><code>__rdivmod__(self, other)</code>定义当被 divmod() 调用时的行为</li>
<li><code>__rpow__(self, other[, module])</code>定义当被 power() 调用或 <code>**</code> 运算时的行为</li>
<li><code>__rlshift__(self, other)</code>定义按位左移位的行为：<code>&lt;&lt;</code></li>
<li><code>__rrshift__(self, other)</code>定义按位右移位的行为：<code>&gt;&gt;</code></li>
<li><code>__rand__(self, other)</code>定义按位与操作的行为：<code>&amp;</code></li>
<li><code>__rxor__(self, other)</code>定义按位异或操作的行为：<code>^</code></li>
<li><code>__ror__(self, other)</code>定义按位或操作的行为：<code>|</code></li>
<li></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a + b</span><br></pre></td></tr></table></figure>

<p>这里加数是<code>a</code>，被加数是<code>b</code>，因此是<code>a</code>主动，反运算就是如果<code>a</code>对象的<code>__add__()</code>方法没有实现或者不支持相应的操作，那么 Python 就会调用<code>b</code>的<code>__radd__()</code>方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Nint</span><span class="params">(int)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__radd__</span><span class="params">(self, other)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> int.__sub__(other, self) <span class="comment"># 注意 self 在后面，1-3=-2</span></span><br><span class="line">a = Nint(<span class="number">5</span>)</span><br><span class="line">b = Nint(<span class="number">3</span>)</span><br><span class="line">print(a + b)  <span class="comment"># 8</span></span><br><span class="line">print(<span class="number">1</span> + b)  <span class="comment"># -2</span></span><br></pre></td></tr></table></figure>

<p>4.增量赋值运算符</p>
<ul>
<li><code>__iadd__(self, other)</code>定义赋值加法的行为：<code>+=</code></li>
<li><code>__isub__(self, other)</code>定义赋值减法的行为：<code>-=</code></li>
<li><code>__imul__(self, other)</code>定义赋值乘法的行为：<code>*=</code></li>
<li><code>__itruediv__(self, other)</code>定义赋值真除法的行为：<code>/=</code></li>
<li><code>__ifloordiv__(self, other)</code>定义赋值整数除法的行为：<code>//=</code></li>
<li><code>__imod__(self, other)</code>定义赋值取模算法的行为：<code>%=</code></li>
<li><code>__ipow__(self, other[, modulo])</code>定义赋值幂运算的行为：<code>**=</code></li>
<li><code>__ilshift__(self, other)</code>定义赋值按位左移位的行为：<code>&lt;&lt;=</code></li>
<li><code>__irshift__(self, other)</code>定义赋值按位右移位的行为：<code>&gt;&gt;=</code></li>
<li><code>__iand__(self, other)</code>定义赋值按位与操作的行为：<code>&amp;=</code></li>
<li><code>__ixor__(self, other)</code>定义赋值按位异或操作的行为：<code>^=</code></li>
<li><code>__ior__(self, other)</code>定义赋值按位或操作的行为：<code>|=</code></li>
</ul>
<p>5.一元运算符</p>
<ul>
<li><code>__neg__(self)</code>定义正号的行为：<code>+x</code></li>
<li><code>__pos__(self)</code>定义负号的行为：<code>-x</code></li>
<li><code>__abs__(self)</code>定义当被<code>abs()</code>调用时的行为</li>
<li><code>__invert__(self)</code>定义按位求反的行为：<code>~x</code></li>
</ul>
<p>6.属性访问</p>
<ul>
<li><code>__getattr__(self, name)</code>: 定义当用户试图获取一个不存在的属性时的行为。</li>
<li><code>__getattribute__(self, name)</code>：定义当该类的属性被访问时的行为（先调用该方法，查看是否存在该属性，若不存在，接着去调用<code>__getattr__</code>）。</li>
<li><code>__setattr__(self, name, value)</code>：定义当一个属性被设置时的行为。</li>
<li><code>__delattr__(self, name)</code>：定义当一个属性被删除时的行为。</li>
</ul>
<p>7.描述符</p>
<p>描述符就是将某种特殊类型的类的实例指派给另一个类的属性。</p>
<p>描述符就是将某种特殊类型的类的实例指派给另一个类的属性。</p>
<ul>
<li><code>__get__(self, instance, owner)</code>用于访问属性，它返回属性的值。</li>
<li><code>__set__(self, instance, value)</code>将在属性分配操作中调用，不返回任何内容。</li>
<li><code>__del__(self, instance)</code>控制删除操作，不返回任何内容。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/05/Python-Task07/" data-id="ckdhise3o0000h4wc0n7l0fdg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-NLP-Task06" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/04/NLP-Task06/" class="article-date">
  <time datetime="2020-08-04T15:38:13.000Z" itemprop="datePublished">2020-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/04/NLP-Task06/">NLP-Task06</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="零基础入门NLP-新闻文本分类-Task06"><a href="#零基础入门NLP-新闻文本分类-Task06" class="headerlink" title="零基础入门NLP - 新闻文本分类-Task06"></a>零基础入门NLP - 新闻文本分类-Task06</h1><h2 id="Task06-基于深度学习的文本分类3"><a href="#Task06-基于深度学习的文本分类3" class="headerlink" title="Task06:基于深度学习的文本分类3"></a>Task06:基于深度学习的文本分类3</h2><p>1.Attention Is All You Need论文学习</p>
<p>摘要</p>
<p>主流的序列转换模型都基于复杂的循环或卷积神经网络，包括编码器和解码器。最佳性能的模型还通过注意力机制将编码器和解码器连接起来。我们提出了一种新的简单网络架构Transformer，它仅仅基于注意力机制，完全不需要循环和卷积。在两个机器翻译任务上的实验表明，这些模型在质量上更优，同时更具并行性，并且需要更少的训练时间。我们的模型在WMT 2014英语到德语的翻译任务中达到了28.4 BLEU，比现有的最佳结果(包括集成模型)提高了2个BLEU以上。在WMT 2014英语到法语翻译任务中，我们的模型在八个GPU上训练了3.5天后，建立了一个新的单模型，效果为BLEU分数41.8，是其他最好模型的训练成本的一小部分。我们通过将Transformer成功应用于大量训练数据和有限训练数据的两种情况下的英语成分解析，表明Transformer可以很好地推广到其他任务。</p>
<p>1 introduction</p>
<p>递归神经网络，特别是长短期记忆[13]和门控递归[7]神经网络，已经作为序列建模和转换问题的最先进的解决方法，诸如在语言模型和机器翻译上。自那以后，许多努力继续推进循环语言模型和编码器-解码器架构[38，24，15 ]。</p>
<p>循环模型通常沿着输入和输出序列的符号位置进行计算。将位置与计算时间中的步骤对齐，它们生成隐藏状态ht序列，作为先前隐藏状态ht - 1和位置t的输入的函数。这种固有的顺序性质使在训练中难以并行化，当序列长度较长时这变得相当致命，因为存储器约束限制了批处理。最近的工作通过因式分解技巧[ 21 ]和条件计算[ 32 ]在计算效率上取得了显著提高，同时在后者的情况下也提高了模型性能。然而，顺序计算的基本约束仍然存在。</p>
<p>注意力机制已经成为各种任务中很重要的一部分，允许对依赖关系进行建模，而不考虑它们在输入或输出序列中的距离[ 2，19 ]。然而，在除了少数情况之外的所有情况下，[ 27 ]，这种关注机制经常与神经网络结合使用。</p>
<p>在这项工作中，我们提出了Transformer，它不用循环，取而代之的是完全依赖attention机制来描绘输入输出之间的全局依赖。Transformer允许更大程度的并行化，并且在八个P100 GPUs上训练12小时后，翻译质量可以达到最先进的水平。</p>
<p>2 Background</p>
<p>减少顺序计算的目标也是扩展神经GPU[16], ByteNet [18]和ConvS2S [9]的基础，所有这些都使用卷积神经网络作为基本构件，并行计算所有输入和输出位置的隐藏表示。在这些模型中，将来自两个任意输入或输出位置的信号相关联所需的操作数量随着位置之间的距离增加，对于ConvS2S为线性，对于ByteNet为对数。这使得了解远处位置之间的相关性变得更加困难，[ 12 ]。在Transformer中，这操作会被减少到固定数量，尽管由于平均注意力加权位置而降低了有效resolution，正如第3.2节所述，我们用Multi-Head注意力抵消了这种影响。</p>
<p>Self-attention，有时被称为intra-attention，是一种attention机制，将单个序列的不同位置联系起来，以计算该序列的表示。自我关注已经成功地应用于各种任务中，包括阅读理解、抽象概括、文本蕴涵和独立于学习任务的句子表征[ 4、27、28、22 ]。</p>
<p>端到端记忆网络是基于循环注意力机制，而不是序列对齐的循环，在简单语言问答和语言建模任务中表现良好，[ 34 ]。</p>
<p>然而，Transformer是第一个完全依靠self-attention来计算其输入和输出表示的转换模型，而不使用序列rnn或者卷积模型。在接下来的章节中，我们将描述Transformer，激发self-attention，并讨论其优于[ 17、18 ]和[ 9 ]等模型的优势。</p>
<p>3 Model Architecture</p>
<p>大部分有竞争力的神经序列转换模型 都有一个encoder-decoder结构。Encoder会把一个输入的序列表示（x1，x2，。。。Xn）映射为另一个表示z=（z1，。。。Zn）。接着，decoder会根据z输出序列（y1，。。Ym）。模型的每一步都是自回归的，并且当生成下一个的时候会消耗以前生成的符号作为额外的输入。</p>
<p>Transformer大概沿用这种架构，为encoder和decoder同时使用tacked self-attention和point-wise，还有全连接层，分别如下图的左半部分和右半部分所示。</p>
<p><img src="NLP-Task06/8e0b1_1440w.jpeg" alt="img"></p>
<p>3.1 Encoder and Decoder Stacks</p>
<p>Encoder:encoder由6个相同层堆叠而成。每一层都有两个子层。首先是一个multi-head self-attention 机制，第二个是简单的、按位置全连接的前馈网络。我们在两个子层的每一个周围都使用残差连接，然后是层归一化。也就是说，每个子层的输出是LayerNorm(x+ Sublayer(x))，其中Sublayer(x)是由子层本身实现的功能。为了便于这些残差连接，模型中的所有子层以及嵌入层产生尺寸 </p>
<p><img src="https://www.zhihu.com/equation?tex=d_%7Bmodel%7D" alt="img"></p>
<p> = 512的输出。</p>
<p>Decoder:decoder也由6个相同层堆叠而成。除了decoder里面有的两个子层，还加入了第三个子层，可以在encoder的输出上有multi-head attention的功能。我们同样在子层周围用残差连接和层归一化。我们还修改了decoder堆栈中的self-attention子层，以防止位置关注后续位置。这种masking，加上输出嵌入偏移一个位置，确保了位置i的预测只能依赖于小于i的位置处的已知输出。</p>
<p>3.2 Attention</p>
<p>Attention函数可以描述为将query和一组key-value对映射到输出，其中query、key、value和输出都是向量。 输出为value的加权和，其中分配给每个value的权重通过query与相应key的兼容函数来计算。</p>
<p><img src="NLP-Task06/5b75f_1440w.jpeg" alt="img"></p>
<p>3.2.1 Scaled Dot-Product Attention</p>
<p>我们称我们特殊的attention为“缩放版的点积attention”（图 2）。 输入由query、 </p>
<p><img src="https://www.zhihu.com/equation?tex=d_k" alt="img"></p>
<p> 维的key和</p>
<p><img src="https://www.zhihu.com/equation?tex=d_v+" alt="img"></p>
<p> 维的value组成。 我们计算query和所有key的点积、用 </p>
<p><img src="https://www.zhihu.com/equation?tex=%5Csqrt%7Bd_%7Bk%7D%7D+" alt="img"></p>
<p> 相除，然后应用一个softmax函数以获得值的权重。</p>
<p>在实践中，我们同时计算一组query的attention函数，将它们组合成一个矩阵Q。 key和value也一起打包成矩阵 K 和 V 。 我们计算输出矩阵为：</p>
<p><img src="NLP-Task06/3bcd2d_1440w.png" alt="img"></p>
<p>两个最常用的attention函数是加法attention[2]和点积（乘法）attention。 除了缩放因子 </p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B1%7D%7B%5Csqrt%7Bd_%7Bk%7D%7D%7D" alt="img"></p>
<p> 之外，点积attention与我们的算法相同。 加法attention使用具有单个隐藏层的前馈网络计算兼容性函数。 虽然两者在理论上的复杂性相似，但在实践中点积attention的速度更快、更节省空间，因为它可以使用高度优化的矩阵乘法代码来实现。</p>
<p>当 </p>
<p><img src="https://www.zhihu.com/equation?tex=d_k" alt="img"></p>
<p> 的值比较小的时候，这两个机制的性能相差相近，当 </p>
<p><img src="https://www.zhihu.com/equation?tex=d_k+" alt="img"></p>
<p> 比较大时，加法attention比不带缩放的点积attention性能好[3]。 我们怀疑，对于很大的 </p>
<p><img src="https://www.zhihu.com/equation?tex=d_k" alt="img"></p>
<p> 值，点积大幅度增长，将softmax函数推向具有极小梯度的区域。 为了抵消这种影响，我们缩小点积 </p>
<p><img src="https://www.zhihu.com/equation?tex=+%5Cfrac%7B1%7D%7B%5Csqrt%7Bd_%7Bk%7D%7D%7D+" alt="img"></p>
<p> 倍。（作者备注：为了解释点积为什么变大，假设q和k的组成成员是独立随机的变量，其均值为0方差为1。然后它们的点积有均值0和方差 </p>
<p><img src="https://www.zhihu.com/equation?tex=d_k" alt="img"></p>
<p> 。 </p>
<p><img src="https://www.zhihu.com/equation?tex=d_k" alt="img"></p>
<p> 过大会进入softmax的极小梯度区。</p>
<p>3.2.2 Multi-Head Attention</p>
<p>我们发现将query、key和value分别用不同的、学习到的线性映射来映射到 </p>
<p><img src="https://www.zhihu.com/equation?tex=d_k" alt="img"></p>
<p> 、 </p>
<p><img src="https://www.zhihu.com/equation?tex=d_k" alt="img"></p>
<p> 和 </p>
<p><img src="https://www.zhihu.com/equation?tex=d_v" alt="img"></p>
<p> 维h次效果更好，而不是用 </p>
<p><img src="https://www.zhihu.com/equation?tex=d_%7Bmodel%7D" alt="img"></p>
<p> 维的query、key和value执行单个attention函数。 基于每个映射版本的query、key和value，我们并行执行attention函数，产生</p>
<p><img src="https://www.zhihu.com/equation?tex=d_v" alt="img"></p>
<p> 维输出值。 将它们连接并再次映射，产生最终值，如图所示 2。</p>
<p>Multi-head attention允许模型的不同表示子空间联合关注不同位置的信息。 如果只有一个attention head，它的平均值会削弱这个信息。</p>
<p><img src="NLP-Task06/f9775d_1440w.png" alt="img"></p>
<p>其中，映射为参数矩阵WiQ ∈ ℝdmodel×dk , WiK ∈ ℝdmodel×dk , WiV ∈ ℝdmodel×dv 及W O ∈ ℝhdv×dmodel。</p>
<p>在这项工作中，我们采用h = 8 个并行attention层或head。 对每个head，我们使用 </p>
<p><img src="https://www.zhihu.com/equation?tex=d_k" alt="img"></p>
<p> = </p>
<p><img src="https://www.zhihu.com/equation?tex=d_v" alt="img"></p>
<p> = </p>
<p><img src="https://www.zhihu.com/equation?tex=d_%7Bmodel%7D" alt="img"></p>
<p> ∕ h = 64。 由于每个head的大小减小，总的计算成本与具有全部维度的单个head attention相似。</p>
<p>3.2.3 Applications of Attention in our Model</p>
<p>Transformer使用以3种方式使用multi-head attention：</p>
<p>在“编码器—解码器attention”层，query来自前一个解码器层，key和value来自编码器的输出。 这允许解码器中的每个位置能关注到输入序列中的所有位置。 这模仿序列到序列模型中典型的编码器—解码器的attention机制，例如[38, 2, 9]。</p>
<p>编码器包含self-attention层。 在self-attention层中，所有的key、value和query来自同一个地方，在这里是编码器中前一层的输出。编码器中的每个位置都可以关注编码器上一层的所有位置。</p>
<p>类似地，解码器中的self-attention层允许解码器中的每个位置都关注解码器中直到并包括该位置的所有位置。我们需要防止解码器中的向左信息流，来保持自回归属性。通过屏蔽softmax的输入中所有不合法连接的值（设置为-∞），我们在缩放版的点积attention中实现。 见图 2.</p>
<p>3.3 Position-wise Feed-Forward Networks</p>
<p>除了attention子层之外，我们的编码器和解码器中的每个层都包含一个完全连接的前馈网络，该前馈网络单独且相同地应用于每个位置。 它由两个线性变换组成，之间有一个ReLU激活。</p>
<p><img src="NLP-Task06/2209c7_1440w.png" alt="img"></p>
<p>尽管线性变换在不同位置上是相同的，但它们层与层之间的参数是不一样的。 它的另一种描述方式是两个内核大小为1的卷积。 输入和输出的维度为 </p>
<p><img src="https://www.zhihu.com/equation?tex=d_%7Bmodel%7D" alt="img"></p>
<p> = 512，内部层的维度为 </p>
<p><img src="https://www.zhihu.com/equation?tex=d_%7Bff%7D" alt="img"></p>
<p> = 2048。</p>
<p>3.4 Embeddings and Softmax</p>
<p>与其他序列转导模型类似，我们使用学习到的嵌入将输入词符和输出词符转换为维度为dmodel的向量。 我们还使用普通的线性变换和softmax函数将解码器输出转换为预测的下一个词符的概率。 在我们的模型中，两个嵌入层之间和pre-softmax线性变换共享相同的权重矩阵，类似于[30]。 在嵌入层中，我们将这些权重乘以 </p>
<p><img src="https://www.zhihu.com/equation?tex=%5Csqrt%7Bd_%7Bmodel%7D%7D+" alt="img"></p>
<p> 。</p>
<p>3.5 Positional Encoding</p>
<p>由于我们的模型不包含循环和卷积，为了让模型利用序列的顺序，我们必须注入序列中关于词符相对或者绝对位置的一些信息。 为此，我们将“位置编码”添加到编码器和解码器堆栈底部的输入嵌入中。 位置编码和嵌入的维度 </p>
<p><img src="https://www.zhihu.com/equation?tex=d_%7Bmodel%7D" alt="img"></p>
<p> 相同，所以它们俩可以相加。 有多种位置编码可以选择，例如通过学习得到的位置编码和固定的位置编码[9]。</p>
<p>在这项工作中，我们使用不同频率的正弦和余弦函数：</p>
<p><img src="NLP-Task06/b7b7e_1440w.jpeg" alt="img"></p>
<p>其中pos 是位置，i 是维度。 也就是说，位置编码的每个维度对应于一个正弦曲线。 这些波长形成一个几何级数，从2π 到10000 ⋅ 2π。 我们选择这个函数是因为我们假设它允许模型很容易学习对相对位置的关注，因为对任意确定的偏移k, </p>
<p><img src="https://www.zhihu.com/equation?tex=PE_%7Bpos%2Bk%7D" alt="img"></p>
<p> 可以表示为 </p>
<p><img src="https://www.zhihu.com/equation?tex=PE_%7Bpos%7D" alt="img"></p>
<p> 的线性函数。</p>
<p>我们还使用学习到的位置嵌入进行了试验，发现这两个版本产生几乎相同的结果（参见表 3 行(E)）。 我们选择了正弦曲线，因为它允许使用时出现比训练时更长的序列。</p>
<p>4 Why Self-Attention</p>
<p>本节，我们比较self-attention与循环层和卷积层的各个方面，它们通常用于映射变长的符号序列表示(x1,…,xn) 到另一个等长的序列(z1,…,zn)，其中xi,zi ∈ ℝd，例如一个典型的序列转导编码器或解码器中的隐藏层。 我们使用self-attention是考虑到要解决三个问题。</p>
<p>一个是每层计算的总复杂度。 另一个是可以并行的计算量，以所需的最小顺序操作的数量来衡量。</p>
<p>第三个是网络中长距离依赖之间的路径长度。 学习长距离依赖性是许多序列转导任务中的关键挑战。 影响学习这种依赖能力的一个关键因素，是前向和后向信号必须在网络中传播的路径长度。 输入和输出序列中任意位置组合之间的这些路径越短，学习远距离依赖性就越容易[12]。因此，我们还比较了由不同层类型组成的网络中任意两个输入和输出位置之间的最大路径长度。</p>
<p><img src="NLP-Task06/0c2e9_1440w.jpeg" alt="img"></p>
<p>如表1所示，self-attention层将所有位置连接到恒定数量的顺序执行的操作，而循环层需要O(n) 顺序操作。 在计算复杂性方面，当序列长度n 小于表示维度d 时，self-attention层比循环层快，这是机器翻译中最先进的模型最常见情况，例如单词[38]表示法和字节对[31]表示法。为了提高涉及很长序列的任务的计算性能，可以将self-attention限制在仅考虑大小为r 的邻域。 这会将最大路径长度增加到O(n ∕ r)。 我们计划在未来的工作中进一步调查这种方法。</p>
<p>核宽度为k &lt; n的单层卷积不会连接每一对输入和输出的位置。 要这么做，在邻近核的情况下需要O(n∕k) 个卷积层， 在扩展卷积的情况下需要O(logk(n)) 个层[18]，它们增加了网络中任意两个位置之间的最长路径的长度。 卷积层通常比循环层更昂贵，与因子k有关。然而，可分卷积[6]大幅减少复杂度到O(k ⋅n⋅d + n⋅d2)。 然而，即使k = n，一个可分卷积的复杂度等同于self-attention层和point-wise前向层的组合，即我们的模型采用的方法。</p>
<p>间接的好处是self-attention可以产生更可解释的模型。 我们从我们的模型中研究attention的分布，并在附录中展示和讨论示例。 每个attention head不仅清楚地学习到执行不同的任务，许多似乎展现与句子的句法和语义结构的行为。</p>
<p>5 Training</p>
<p>本节介绍我们的模型训练方法。</p>
<p>5.1 训练数据和批次</p>
<p>我们在标准的WMT 2014英语-德语数据集上进行了训练，其中包含约450万个句子对。 这些句子使用字节对编码[3]进行编码，源语句和目标语句共享大约37000个词符的词汇表。 对于英语-法语翻译，我们使用大得多的WMT 2014英法数据集，它包含3600万个句子，并将词符分成32000个word-piece词汇表[38]。 序列长度相近的句子一起进行批处理。 每个训练批次的句子对包含大约25000个源词符和25000个目标词符。</p>
<p>5.2 硬件和时间</p>
<p>我们在一台具有8个NVIDIA P100 GPU的机器上训练我们的模型。 使用本文描述的超参数的基础模型，每个训练步骤耗时约0.4秒。 我们的基础模型共训练了10万步或12小时。 对于我们的大模型(表格三底部一行), 每一步耗时1秒. 大模型训练了30万步（3.5天）。</p>
<p>5.3 优化</p>
<p>我们使用Adam优化[20]，其中β1 = 0.9, β2 = 0.98 及ϵ = 10-9。 我们根据以下公式在训练过程中改变学习率：</p>
<p><img src="NLP-Task06/bda5e4_1440w.png" alt="img"></p>
<p>这对应于在第一次warm up_steps 步骤中线性地增加学习速率，并且随后将其与步骤数的平方根成比例地减小。 我们使用warm up_steps = 4000。</p>
<p>5.4 正则化</p>
<p>训练期间我们采用三种正则化：</p>
<p>残差dropout 我们将dropout[33]在它与子层的输入相加和正则化之前，应用到每个子层的输出中。 此外，在编码器和解码器堆栈中，我们将dropout应用到嵌入和位置编码的和这一步骤中。 对于基本模型，我们使用</p>
<p><img src="https://www.zhihu.com/equation?tex=P_%7Bdrop%7D" alt="img"></p>
<p> = 0.1。</p>
<p><img src="NLP-Task06/d161f_1440w.jpeg" alt="img"></p>
<p>Label Smoothing 在训练过程中，我们使用的label smoothing的值为ϵls = 0.1[36]。 这让模型不易理解，因为模型学得更加不确定，但提高了准确性和BLEU得分。</p>
<p>6 Results</p>
<p>6.1 Machine Translation</p>
<p>在WMT 2014英语-德语翻译任务中，大型transformer模型（表2中的Transformer (big)）比以前报道的最佳模型（包括集成模型）高出2.0个BLEU以上，确立了一个全新的最高BLEU分数为28.4。 该模型的配置列在表3的底部。 训练在8 个P100 GPU上花费3.5 天。 即使我们的基础模型也超过了以前发布的所有模型和整合模型，且训练成本只是这些模型的一小部分。</p>
<p>在WMT 2014英语-法语翻译任务中，我们的大型模型的BLEU得分为41.0，超过了之前发布的所有单一模型，训练成本低于先前最先进模型的1 ∕ 4 。 英语-法语的Transformer (big) 模型使用丢弃率为</p>
<p><img src="https://www.zhihu.com/equation?tex=P_%7Bdrop%7D" alt="img"></p>
<p> = 0.1，而不是0.3。</p>
<p>对于基础模型，我们使用的单个模型来自最后5个检查点的平均值，这些检查点每10分钟写一次。 对于大型模型，我们对最后20个检查点进行了平均。 我们使用beam search，beam大小为4 ，长度惩罚α = 0.6 [38]。 这些超参数是在开发集上进行实验后选定的。 在推断时，我们设置最大输出长度为输入长度+50，但在可能时尽早终止[38]。</p>
<p>表2总结了我们的结果，并将我们的翻译质量和训练成本与文献中的其他模型体系结构进行了比较。 我们通过将训练时间、所使用的GPU的数量以及每个GPU的持续单精度浮点能力的估计相乘来估计用于训练模型的浮点运算的数量。</p>
<p><img src="NLP-Task06/f08bc_1440w.jpeg" alt="img"></p>
<p>6.2 Model Variations</p>
<p>为了评估Transformer不同组件的重要性，我们以不同的方式改变我们的基础模型，测量开发集newstest2013上英文-德文翻译的性能变化。我们使用前一节所述的beam搜索，但没有平均检查点。 我们在表中列出这些结果。</p>
<p>在表3的行（A）中，我们改变attention head的数量和attention key和value的维度，保持计算量不变，如3.2.2节所述。 虽然只有一个head attention比最佳设置差0.9 BLEU，但质量也随着head太多而下降。</p>
<p>在表3行（B）中，我们观察到减小key的大小dk会有损模型质量。 这表明确定兼容性并不容易，并且比点积更复杂的兼容性函数可能更有用。我们在行（C）和（D）中进一步观察到，如预期的那样，更大的模型更好，并且dropout对避免过度拟合非常有帮助。 在行（E）中，我们用学习到的位置嵌入[9]来替换我们的正弦位置编码，并观察到与基本模型几乎相同的结果。</p>
<p>7 结论</p>
<p>在这项工作中，我们提出了Transformer，第一个完全基于attention的序列转导模型，用multi-headed self-attention取代了编码器-解码器架构中最常用的循环层。</p>
<p>对于翻译任务，Transformer可以比基于循环或卷积层的体系结构训练更快。 在WMT 2014英语-德语和WMT 2014英语-法语翻译任务中，我们取得了最好的结果。 在前面的任务中，我们最好的模型甚至胜过以前报道过的所有集成模型。</p>
<p>我们对基于attention的模型的未来感到兴奋，并计划将它们应用于其他任务。 我们计划将Transformer扩展到除文本之外的涉及输入和输出模式的问题，并调查局部的、受限attention机制以有效处理大型输入和输出，如图像、音频和视频。 让生成具有更少的顺序性是我们的另一个研究目标。</p>
<p>我们用于训练和评估模型的代码可以在<a href="https://link.zhihu.com/?target=https%3A//github.com/tensorflow/tensor2tensor">https://github.com/tensorflow/tensor2tensor</a>上找到。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/04/NLP-Task06/" data-id="ckdg43r0g0001kkwc9aen3w0c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-NLP-Task05" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/04/NLP-Task05/" class="article-date">
  <time datetime="2020-08-04T03:55:04.000Z" itemprop="datePublished">2020-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/04/NLP-Task05/">NLP-Task05</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="零基础入门NLP-新闻文本分类-Task05"><a href="#零基础入门NLP-新闻文本分类-Task05" class="headerlink" title="零基础入门NLP - 新闻文本分类-Task05"></a>零基础入门NLP - 新闻文本分类-Task05</h1><h2 id="Task05-基于深度学习的文本分类2"><a href="#Task05-基于深度学习的文本分类2" class="headerlink" title="Task05:基于深度学习的文本分类2"></a>Task05:基于深度学习的文本分类2</h2><ol>
<li>思路1：Count Vectors + RidgeClassifier</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/04/NLP-Task05/" data-id="ckdg43r090000kkwca3tqhb27" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Python-Task06" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/02/Python-Task06/" class="article-date">
  <time datetime="2020-08-02T15:50:49.000Z" itemprop="datePublished">2020-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/02/Python-Task06/">Python-Task06</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Python编程基础-Task06"><a href="#Python编程基础-Task06" class="headerlink" title="Python编程基础-Task06"></a>Python编程基础-Task06</h1><h2 id="Task-6-函数与Lambda表达式"><a href="#Task-6-函数与Lambda表达式" class="headerlink" title="Task 6:函数与Lambda表达式"></a>Task 6:函数与Lambda表达式</h2><p>1.函数定义 </p>
<p>def关键词开头，后接函数名和圆括号()。</p>
<p>return表达式结束函数，选择性的返回一个值给调用方。不带表达式return相当于返回<code>None</code>。</p>
<p>2.函数参数</p>
<p>1）位置参数，这些参数在调用函数 (call function) 时位置要固定。</p>
<p>2）默认参数，<code>arg2 = v</code> - 默认参数 = 默认值。默认参数一定要放在位置参数 <strong>后面</strong>，不然程序会报错。</p>
<p>3）可变参数，<code>*args</code> - 可变参数，可以是从零个到任意个，自动组装成元组。加了星号（*）的变量名会存放所有未命名的变量参数。</p>
<p>4）关键字参数，<code>**kw</code> - 关键字参数，可以是从零个到任意个，自动组装成字典。传入时，每个关键字参数写为key=value的形式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span><span class="params">(arg1, *args, **kwargs)</span>:</span></span><br><span class="line">    print(arg1)</span><br><span class="line">    print(args)</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printinfo(<span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span>)</span><br><span class="line"><span class="comment"># 70</span></span><br><span class="line"><span class="comment"># (60, 50)</span></span><br><span class="line"><span class="comment"># &#123;&#125;</span></span><br><span class="line">printinfo(<span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span>, a=<span class="number">1</span>, b=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 70</span></span><br><span class="line"><span class="comment"># (60, 50)</span></span><br><span class="line"><span class="comment"># &#123;'a': 1, 'b': 2&#125;</span></span><br></pre></td></tr></table></figure>

<p>「可变参数」和「关键字参数」的同异总结如下：</p>
<ul>
<li>可变参数允许传入零个到任意个参数，它们在函数调用时自动组装为一个元组 (tuple)。</li>
<li>关键字参数允许传入零个到任意个参数，它们在函数内部自动组装为一个字典 (dict)。</li>
</ul>
<p>5）命名关键字参数</p>
<p><code>*, nkw</code> - 命名关键字参数，用户想要输入的关键字参数，定义方式是在nkw 前面加个分隔符 *。</p>
<p>使用命名关键字参数时，要特别注意不能缺少参数名。不加参数名，程序可能会认为是位置参数。</p>
<p>6）参数组合</p>
<p>这 5 种参数中的 4 个都可以一起使用，但是注意，参数定义的顺序必须是：</p>
<ul>
<li>位置参数、默认参数、可变参数和关键字参数。</li>
<li>位置参数、默认参数、命名关键字参数和关键字参数。</li>
</ul>
<p>要注意定义可变参数和关键字参数的语法：</p>
<ul>
<li><code>*args</code> 是可变参数，<code>args</code> 接收的是一个 <code>tuple</code></li>
<li><code>**kw</code> 是关键字参数，<code>kw</code> 接收的是一个 <code>dict</code></li>
</ul>
<p>命名关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。定义命名关键字参数不要忘了写分隔符 <code>*</code>，否则定义的是位置参数。</p>
<p>3.变量作用域</p>
<p>当内部作用域想修改外部作用域的变量时，就要用到<code>global</code>和<code>nonlocal</code>关键字了。</p>
<p>4.闭包</p>
<p>如果在一个内部函数里对外层非全局作用域的变量进行引用，那么内部函数就被认为是闭包。</p>
<p>通过闭包可以访问外层非全局作用域的变量，这个作用域称为 <strong>闭包作用域</strong>。如果要修改闭包作用域中的变量则需要 <code>nonlocal</code> 关键字。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funX</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">funY</span><span class="params">(y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x * y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> funY</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = funX(<span class="number">8</span>)</span><br><span class="line">print(type(i))  <span class="comment"># &lt;class 'function'&gt;</span></span><br><span class="line">print(i(<span class="number">5</span>))  <span class="comment"># 40</span></span><br></pre></td></tr></table></figure>

<p>5.递归</p>
<p>如果一个函数在内部调用自身本身，这个函数就是递归函数。</p>
<p>可以通过setrecursionlimit设置递归的层数，Python默认递归层数为100。</p>
<p>6.Lambda表达式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> argument_list: expression</span><br></pre></td></tr></table></figure>

<p><code>expression</code> 中没有 return 语句，因为 lambda 不需要它来返回，表达式本身结果就是返回值。</p>
<p>匿名函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。</p>
<p><code>filter(function, iterable)</code> 过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象，如果要转换为列表，可以使用 <code>list()</code> 来转换。</p>
<p><code>map(function, *iterables)</code> 根据提供的函数对指定序列做映射。</p>
<p>7.练习题</p>
<p>1）怎么给函数编写⽂档？</p>
<p>可以在函数中利用双引号“ ”编写文档，利用<code>__doc__</code>、<code>__name__</code>等关键字获取函数的注释、名称等。利用help(MyFirstFunction)指令可以获得函数相关文档。</p>
<p>2）怎么给函数参数和返回值注解？</p>
<p>用 <code>: 类型</code> 的形式指定函数的<strong>参数类型</strong>，用 <code>-&gt; 类型</code> 的形式指定函数的<strong>返回值</strong>类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x:int, y:int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure>

<p>不过需要强调的是，Python 解释器<strong>并不会</strong>因为这些注解而提供额外的校验，没有任何的类型检查工作。也就是说，这些类型注解加不加，对你的代码来说<strong>没有任何影响</strong>。</p>
<p>但这么做的好处是：</p>
<ol>
<li>让别的程序员看得更明白</li>
<li>让 IDE 了解类型，从而提供更准确的代码提示、补全和语法检查（包括类型检查，可以看到 str 和 float 类型的参数被高亮提示）</li>
</ol>
<p>获取我们定义的函数注解：<code>__annotations__</code>、<code>inspect.signature</code></p>
<p>在 Python 3.6 中，又引入了对<strong>变量类型</strong>进行注解的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a: int = <span class="number">123</span></span><br><span class="line">b: str = <span class="string">'hello'</span></span><br></pre></td></tr></table></figure>

<p>更进一步，如果你需要指明一个全部由整数组成的列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line">l: List[int] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>3）闭包中，怎么对数字、字符串、元组等不可变元素更新。</p>
<p>如果要修改闭包作用域中的变量需要 <code>nonlocal</code> 关键字。</p>
<p>4）分别根据每一行的首元素和尾元素大小对二维列表 a = [[6, 5], [3, 7], [2, 8]] 排序。(利用lambda表达式)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = [[<span class="number">6</span>, <span class="number">5</span>], [<span class="number">3</span>, <span class="number">7</span>], [<span class="number">2</span>, <span class="number">8</span>]] </span><br><span class="line">b = sorted(a, key=<span class="keyword">lambda</span> i:i[<span class="number">0</span>])</span><br><span class="line">print(b)</span><br><span class="line">b = sorted(a, key=<span class="keyword">lambda</span> i:i[<span class="number">0</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">print(b)</span><br><span class="line">b = sorted(a, key=<span class="keyword">lambda</span> i:i[<span class="number">-1</span>])</span><br><span class="line">print(b)</span><br><span class="line">b = sorted(a, key=<span class="keyword">lambda</span> i:i[<span class="number">-1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<p>[[2, 8], [3, 7], [6, 5]]<br>[[6, 5], [3, 7], [2, 8]]<br>[[6, 5], [3, 7], [2, 8]]<br>[[2, 8], [3, 7], [6, 5]]</p>
<p>5）利用python解决汉诺塔问题？</p>
<p>move(n, a, b, c)。可以这样理解：move(盘子数量, 起点, 缓冲, 终点)。</p>
<p>（1）a 上只有一个盘子的情况，直接搬到 c，代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">    print(a, <span class="string">'--&gt;'</span>, c)</span><br></pre></td></tr></table></figure>

<p>（2）a 上不止有一个盘子的情况:</p>
<p>首先，需要把 n-1 个盘子搬到 b 柱子缓冲。打印出的效果是：a –&gt; b。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move(n - <span class="number">1</span>, a, c, b)</span><br></pre></td></tr></table></figure>

<p>再把最大的盘子搬到 c 柱子，也是最大尺寸的一个。打印出：a–&gt;c。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move(<span class="number">1</span>, a, b, c)</span><br></pre></td></tr></table></figure>

<p>最后，把剩下 b 柱的 n-1 个盘子搬到 c 上，此时缓冲变成了起点，起点变成了缓冲。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move(n - <span class="number">1</span>, b, a, c)</span><br></pre></td></tr></table></figure>

<p>程序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(n, a, b, c)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> i</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>):</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        print(<span class="string">'移动第 &#123;0&#125; 次 &#123;1&#125; --&gt; &#123;2&#125;'</span>.format(i, a, c))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    move(n - <span class="number">1</span>, a, c, b)</span><br><span class="line">    move(<span class="number">1</span>, a, b, c)</span><br><span class="line">    move(n - <span class="number">1</span>, b, a, c)</span><br><span class="line"></span><br><span class="line">move(<span class="number">64</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>)</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/02/Python-Task06/" data-id="ckddxsxa60009twwcfrzl6537" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Python-Task05" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/31/Python-Task05/" class="article-date">
  <time datetime="2020-07-30T23:15:47.000Z" itemprop="datePublished">2020-07-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/31/Python-Task05/">Python-Task05</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Python编程基础-Task05"><a href="#Python编程基础-Task05" class="headerlink" title="Python编程基础-Task05"></a>Python编程基础-Task05</h1><h2 id="Task-5-字典、集合和序列"><a href="#Task-5-字典、集合和序列" class="headerlink" title="Task 5:字典、集合和序列"></a>Task 5:字典、集合和序列</h2><p><strong>字典</strong></p>
<p>1.字典是python唯一的一个映射类型，字符串、元组、列表属于序列类型。</p>
<p>序列类型和字典不同之处：序列以连续的整数为索引，字典以“关键字”为索引，关键字可以是任意不可变类型，通常用字符串或数值。</p>
<p>2.可变类型与不可变类型</p>
<p>不可变类型：数值(int/float/bool)、字符、元组</p>
<p>可变类型：列表、集合、字典</p>
<p>如何快速判断一个数据类型x是不是可变类型：</p>
<ul>
<li>用 <code>id(X)</code> 函数，对 X 进行某种操作，比较操作前后的 <code>id</code>，如果不一样，则 <code>X</code> 不可变，如果一样，则 <code>X</code> 可变。</li>
<li>便捷方法：用 <code>hash(X)</code>，只要不报错，证明 <code>X</code> 可被哈希，即不可变，反过来不可被哈希，即可变。</li>
</ul>
<p>1）id(x) 判断依据：</p>
<p>不可变类型，变量重新赋值，id 内存地址会变。（给多个变量赋相同的值，整型、布尔型、比较短的字符串指向同个内存地址；浮点型、长字符串指向不同内存地址。这方面涉及Python内存管理机制，Python对int类型和较短的字符串进行了缓存，无论声明多少个值相同的变量，实际上都指向同个内存地址。）</p>
<p>可变类型，变量重新赋值之后，id内存地址不变。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 浮点型变量重新赋值之后，id会变</span></span><br><span class="line">i = <span class="number">1.5</span></span><br><span class="line">print(id(i))</span><br><span class="line">i = i+<span class="number">1.2</span></span><br><span class="line">print(id(i))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对变量赋值相同的浮点型，id会变，即指向不同的内存地址</span></span><br><span class="line">a = <span class="number">1.5</span></span><br><span class="line">print(id(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对变量赋值相同的整型，id不变，即指向相同的内存地址</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line">c = <span class="number">1</span></span><br><span class="line">print(id(b))</span><br><span class="line">print(id(c))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对变量赋值相同的布尔型，id不变，即指向相同的内存地址</span></span><br><span class="line">d = <span class="literal">True</span></span><br><span class="line">e = <span class="literal">True</span></span><br><span class="line">print(id(d))</span><br><span class="line">print(id(e))</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p>1933540566552<br>1933540566456<br>1933540566432<br>140718072828736<br>140718072828736<br>140718072306000<br>140718072306000</p>
<p>2）hash(x)判断依据：不可变类型能被哈希，可变类型不能被哈希。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(hash(<span class="string">'Name'</span>))  <span class="comment"># -9215951442099718823</span></span><br><span class="line"></span><br><span class="line">print(hash((<span class="number">1</span>, <span class="number">2</span>, <span class="string">'Python'</span>)))  <span class="comment"># 823362308207799471</span></span><br><span class="line"></span><br><span class="line">print(hash([<span class="number">1</span>, <span class="number">2</span>, <span class="string">'Python'</span>]))</span><br><span class="line"><span class="comment"># TypeError: unhashable type: 'list'</span></span><br><span class="line"></span><br><span class="line">print(hash(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;))</span><br><span class="line"><span class="comment"># TypeError: unhashable type: 'set'</span></span><br></pre></td></tr></table></figure>



<p>3.dict查找和插入的速度极快，不会随着key的增加而增加，但是需要占用大量的内存。</p>
<p>4.创建和访问字典</p>
<p>​    <strong>一个对象能不能作为字典的key，就取决于其有没有<strong>hash</strong>方法。所有python自带类型中，除了list、dict、set和内部至少带有上述三种类型之一的tuple之外，其余的对象都能当key。</strong></p>
<p>​    因此，字典的键key可以是任意不可变类型(数值、字符串、元组)，但需要注意的是tuple元组作为键时，其中不能以任何方式包含可变对象。</p>
<p>通过键值对的映射对象 初始化字典：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dic1 = dict([(<span class="string">'apple'</span>, <span class="number">4139</span>), (<span class="string">'peach'</span>, <span class="number">4127</span>), (<span class="string">'cherry'</span>, <span class="number">4098</span>)])</span><br><span class="line">print(dic1)  <span class="comment"># &#123;'cherry': 4098, 'apple': 4139, 'peach': 4127&#125;</span></span><br><span class="line"></span><br><span class="line">dic2 = dict(((<span class="string">'apple'</span>, <span class="number">4139</span>), (<span class="string">'peach'</span>, <span class="number">4127</span>), (<span class="string">'cherry'</span>, <span class="number">4098</span>)))</span><br><span class="line">print(dic2)  <span class="comment"># &#123;'peach': 4127, 'cherry': 4098, 'apple': 4139&#125;</span></span><br></pre></td></tr></table></figure>

<p>通过 名称=值对 创建字典：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意，此处name和age虽然作为地点的key时是加引号的字符串，但是在创建时不能加引号，加引号会报语法错误。</span></span><br><span class="line">dic = dict(name=<span class="string">'Tom'</span>, age=<span class="number">10</span>) </span><br><span class="line">print(dic)  <span class="comment"># &#123;'name': 'Tom', 'age': 10&#125;</span></span><br><span class="line">print(type(dic))  <span class="comment"># &lt;class 'dict'&gt;</span></span><br></pre></td></tr></table></figure>

<p>5.字典的内置方法</p>
<p>1）<code>dict.fromkeys(seq[, value])</code> 用于创建一个新字典，以序列 <code>seq</code> 中元素做字典的键，<code>value</code> 为字典所有键对应的初始值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">seq = (<span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'sex'</span>)</span><br><span class="line">dic1 = dict.fromkeys(seq)</span><br><span class="line">print(dic1)</span><br><span class="line"></span><br><span class="line">dic2 = dict.fromkeys(seq,<span class="number">10</span>)</span><br><span class="line">print(dic2)</span><br><span class="line"></span><br><span class="line">dic3 = dict.fromkeys(seq,(<span class="string">'小马'</span>, <span class="string">'8'</span>, <span class="string">'男'</span>))</span><br><span class="line">print(dic3)</span><br></pre></td></tr></table></figure>
<p>{‘name’: None, ‘age’: None, ‘sex’: None}<br>{‘name’: 10, ‘age’: 10, ‘sex’: 10}<br>{‘name’: (‘小马’, ‘8’, ‘男’), ‘age’: (‘小马’, ‘8’, ‘男’), ‘sex’: (‘小马’, ‘8’, ‘男’)}</p>
<p>2）<code>dict.keys()</code>返回一个可迭代对象，可以使用 <code>list()</code> 来转换为列表，列表为字典中的所有键。</p>
<p>3）<code>dict.values()</code>返回一个迭代器，可以使用 <code>list()</code> 来转换为列表，列表为字典中的所有值。</p>
<p>4）<code>dict.items()</code>以列表返回可遍历的(键值)元组数组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;<span class="string">'Name'</span>: <span class="string">'Lsgogroup'</span>, <span class="string">'Age'</span>: <span class="number">7</span>&#125;</span><br><span class="line">print(dic.items())</span><br><span class="line"><span class="comment"># dict_items([('Name', 'Lsgogroup'), ('Age', 7)])</span></span><br><span class="line"></span><br><span class="line">print(tuple(dic.items()))</span><br><span class="line"><span class="comment"># (('Name', 'Lsgogroup'), ('Age', 7))</span></span><br><span class="line"></span><br><span class="line">print(list(dic.items()))</span><br><span class="line"><span class="comment"># [('Name', 'Lsgogroup'), ('Age', 7)]</span></span><br></pre></td></tr></table></figure>

<p>5）<code>dict.get(key, default=None)</code> 返回指定键的值，如果值不在字典中返回默认值。</p>
<p>6）<code>dict.setdefault(key, default=None)</code> 和get()方法类似，返回指定键的值，如果键不存在字典中，将会添加键并将值设为默认值。</p>
<p>7）<code>key in dict</code> <code>in</code> 操作符用于判断键是否存在于字典中，如果键在字典 dict 里返回<code>true</code>，否则返回<code>false</code>。而<code>not in</code>操作符刚好相反，如果键在字典 dict 里返回<code>false</code>，否则返回<code>true</code>。</p>
<p>8）<code>dict.pop(key[,default])</code>删除字典给定键 <code>key</code> 所对应的值，返回值为被删除的值。<code>key</code> 值必须给出。若<code>key</code>不存在，必须设置默认值，返回 <code>default</code> 值。</p>
<p>9）<code>del dict[key]</code> 删除字典给定键 <code>key</code> 所对应的值。</p>
<p>10）<code>dict.popitem()</code>随机返回并删除字典中的一对键和值，如果字典已经为空，却调用了此方法，就报出KeyError异常。</p>
<p>11）<code>dict.clear()</code>用于删除字典内所有元素。</p>
<p>12）<code>dict.copy()</code>返回一个字典的浅复制。</p>
<p>直接赋值和copy的区别:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">dic1 = &#123;<span class="string">'user'</span>: <span class="string">'lsgogroup'</span>, <span class="string">'num'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 引用对象</span></span><br><span class="line">dic2 = dic1  </span><br><span class="line"><span class="comment"># 浅拷贝父对象，子对象（[1,2,3]）不拷贝，还是引用</span></span><br><span class="line">dic3 = dic1.copy()  </span><br><span class="line"></span><br><span class="line">print(id(dic1))  <span class="comment"># 148635574728</span></span><br><span class="line">print(id(dic2))  <span class="comment"># 148635574728</span></span><br><span class="line">print(id(dic3))  <span class="comment"># 148635574344</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 data 数据</span></span><br><span class="line">dic1[<span class="string">'user'</span>] = <span class="string">'root'</span></span><br><span class="line">dic1[<span class="string">'num'</span>].remove(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">print(dic1)  <span class="comment"># &#123;'user': 'root', 'num': [2, 3]&#125;</span></span><br><span class="line">print(dic2)  <span class="comment"># &#123;'user': 'root', 'num': [2, 3]&#125;</span></span><br><span class="line"><span class="comment"># 由于浅拷贝时，子对象不拷贝，列表变化时，dic3也变化</span></span><br><span class="line">print(dic3)  <span class="comment"># &#123;'user': 'runoob', 'num': [2, 3]&#125;</span></span><br></pre></td></tr></table></figure>

<p>13）<code>dict.update(dict2)</code>把字典参数 <code>dict2</code> 的 <code>key:value</code>对 更新到字典 <code>dict</code> 里。已有键的，则更新该键对应的值；没有键的，则添加该键值对。也是直接修改原字典。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;<span class="string">'Name'</span>: <span class="string">'Lsgogroup'</span>, <span class="string">'Age'</span>: <span class="number">7</span>&#125;</span><br><span class="line">dic2 = &#123;<span class="string">'Sex'</span>: <span class="string">'female'</span>, <span class="string">'Age'</span>: <span class="number">8</span>&#125;</span><br><span class="line">dic.update(dic2)</span><br><span class="line">print(dic)  </span><br><span class="line"><span class="comment"># &#123;'Sex': 'female', 'Age': 8, 'Name': 'Lsgogroup'&#125;</span></span><br></pre></td></tr></table></figure>

<p>6.练习题1</p>
<p>用程序解答下面的题目</p>
<ul>
<li>字典的长度是多少</li>
<li>请修改’java’ 这个key对应的value值为98</li>
<li>删除 c 这个key</li>
<li>增加一个key-value对，key值为 php, value是90</li>
<li>获取所有的key值，存储在列表里</li>
<li>获取所有的value值，存储在列表里</li>
<li>判断 javascript 是否在字典中</li>
<li>获得字典里所有value 的和</li>
<li>获取字典里最大的value</li>
<li>获取字典里最小的value</li>
<li>字典 dic1 = {‘php’: 97}， 将dic1的数据更新到dic中</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;</span><br><span class="line">    <span class="string">'python'</span>:<span class="number">95</span>,</span><br><span class="line">    <span class="string">'java'</span>:<span class="number">99</span>,</span><br><span class="line">    <span class="string">'c'</span>:<span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line">print(len(dic))</span><br><span class="line">dic[<span class="string">'java'</span>] = <span class="number">98</span></span><br><span class="line">print(dic)</span><br><span class="line">dic.pop(<span class="string">'c'</span>)</span><br><span class="line">print(dic)</span><br><span class="line">dic[<span class="string">'php'</span>] = <span class="number">90</span></span><br><span class="line">print(dic)</span><br><span class="line">keys = list(dic.keys())</span><br><span class="line">print(keys)</span><br><span class="line">values = list(dic.values())</span><br><span class="line">print(values)</span><br><span class="line">print(<span class="string">'javascript'</span> <span class="keyword">in</span> dic)</span><br><span class="line">print(sum(values))</span><br><span class="line">print(max(values))</span><br><span class="line">print(min(values))</span><br><span class="line">dic1 = &#123;<span class="string">'php'</span>:<span class="number">97</span>&#125;</span><br><span class="line">dic.update(dic1)</span><br><span class="line">print(dic)</span><br></pre></td></tr></table></figure>

<p>3<br>{‘python’: 95, ‘java’: 98, ‘c’: 100}<br>{‘python’: 95, ‘java’: 98}<br>{‘python’: 95, ‘java’: 98, ‘php’: 90}<br>[‘python’, ‘java’, ‘php’]<br>[95, 98, 90]<br>False<br>283<br>98<br>90<br>{‘python’: 95, ‘java’: 98, ‘php’: 97}</p>
<p>7.练习题2</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'python'</span>: &#123;<span class="string">'上学期'</span>: <span class="string">'90'</span>, <span class="string">'下学期'</span>: <span class="string">'95'</span>&#125;,</span><br><span class="line">    <span class="string">'c++'</span>: [<span class="string">'95'</span>, <span class="string">'96'</span>, <span class="string">'97'</span>],</span><br><span class="line">    <span class="string">'java'</span>: [&#123;<span class="string">'月考'</span>:<span class="string">'90'</span>, <span class="string">'期中考试'</span>: <span class="string">'94'</span>, <span class="string">'期末考试'</span>: <span class="string">'98'</span>&#125;]</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transfer_score</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(data,dict):</span><br><span class="line">        <span class="keyword">for</span> key,value <span class="keyword">in</span> data.items():</span><br><span class="line">            data[key] = transfer_score(value)</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> isinstance(data,list):</span><br><span class="line">        data_lst = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">            data_lst.append(transfer_score(i))</span><br><span class="line">        <span class="keyword">return</span> data_lst</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> isinstance(data,str):</span><br><span class="line">        <span class="keyword">return</span> int(data)</span><br><span class="line"></span><br><span class="line">data1 = transfer_score(data)</span><br><span class="line">print(data1)</span><br></pre></td></tr></table></figure>

<p>{‘python’: {‘上学期’: 90, ‘下学期’: 95}, ‘c++’: [95, 96, 97], ‘java’: [{‘月考’: 90, ‘期中考试’: 94, ‘期末考试’: 98}]}</p>
<p>8.遇到小问题</p>
<p>python字典更新时出现value为None的情况</p>
<p>如果，key对应的值是一个对象或者数据结构，该怎么去修改其对应的值呢，如：对应的值是一个列表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person = &#123;<span class="string">'name'</span>: [<span class="string">'jack'</span>, <span class="string">'alis'</span>], <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">print</span> person</span><br><span class="line">person[<span class="string">'name'</span>] = person[<span class="string">'name'</span>].append(<span class="string">'hanjun'</span>) <span class="comment"># 修改列表，重新给person['name']赋值</span></span><br><span class="line"><span class="keyword">print</span> person</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p>{‘age’: 18, ‘name’: [‘jack’, ‘alis’]}<br>{‘age’: 18, ‘name’: None}</p>
<p>结果中name对应的值为None，这样就出现了细节上的bug，并且这个bug是不容易被发现的，看起来好像没什么错。</p>
<p>正确的做法应该是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person = &#123;<span class="string">'name'</span>: [<span class="string">'jack'</span>, <span class="string">'alis'</span>], <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">print</span> person</span><br><span class="line">person[<span class="string">'name'</span>].append(<span class="string">'hanjun'</span>) <span class="comment"># 列表本身是可变类型，直接值修改字典元素值-列表，不需要再重新给person['name']赋值。</span></span><br><span class="line"><span class="keyword">print</span> person</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p>{‘age’: 18, ‘name’: [‘jack’, ‘alis’]}<br>{‘age’: 18, ‘name’: [‘jack’, ‘alis’, ‘hanjun’]}</p>
<p>对字典的值直接添加，而不是用再赋值的方式，再赋值的方式为什么会错呢？</p>
<p>因为，列表list的append是一个方法，该方法直接修改原对象，返回值为None（没有返回值就会返回None），所以key为name的值就为None了。</p>
<p><strong>集合</strong></p>
<p>1.set是一组key的集合，key不能重复。跟在dict中一样，key只能是不可变类型。</p>
<p>2.创建集合</p>
<p>1）先创建集合对象，再用add()方法加入元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">basket = set()</span><br><span class="line">basket.add(<span class="string">'apple'</span>)</span><br><span class="line">basket.add(<span class="string">'banana'</span>)</span><br><span class="line">print(basket)  <span class="comment"># &#123;'banana', 'apple'&#125;</span></span><br></pre></td></tr></table></figure>

<p>2）直接把一堆元素用花括号括起来{元素1，元素2，…，元素n}。重复元素在set中会被自动过滤掉。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">basket = &#123;<span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'apple'</span>, <span class="string">'pear'</span>, <span class="string">'orange'</span>, <span class="string">'banana'</span>&#125;</span><br><span class="line">print(basket)  <span class="comment"># &#123;'banana', 'apple', 'pear', 'orange'&#125;</span></span><br></pre></td></tr></table></figure>

<p> 3）使用set(value)工厂函数，把列表或元组转换成集合。（工厂函数基本上都是带有返回对象的，而这些返回对象则是通过调用一种或者多种类来创建的对象。工厂函数看上去有点像函数，实质上他们是类，当你调用它们时，实际上是生成的该类型的一个实例，就像工厂生产货物一样。）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = set(<span class="string">'abracadabra'</span>)</span><br><span class="line">print(a)  </span><br><span class="line"><span class="comment"># &#123;'r', 'b', 'd', 'c', 'a'&#125;</span></span><br><span class="line"></span><br><span class="line">b = set((<span class="string">"Google"</span>, <span class="string">"Lsgogroup"</span>, <span class="string">"Taobao"</span>, <span class="string">"Taobao"</span>))</span><br><span class="line">print(b)  </span><br><span class="line"><span class="comment"># &#123;'Taobao', 'Lsgogroup', 'Google'&#125;</span></span><br><span class="line"></span><br><span class="line">c = set([<span class="string">"Google"</span>, <span class="string">"Lsgogroup"</span>, <span class="string">"Taobao"</span>, <span class="string">"Google"</span>])</span><br><span class="line">print(c)  </span><br><span class="line"><span class="comment"># &#123;'Taobao', 'Lsgogroup', 'Google'&#125;</span></span><br></pre></td></tr></table></figure>

<p>3.集合的两个特点：无序和唯一。由于set存储的是无序集合，所以我们不可以为集合创建索引或执行切片操作，也没有键(keys)方法可以用来获取集合中元素的值，但是可以判断一个元素是否在集合中。</p>
<p>4.集合的内置方法</p>
<p>1）<code>set.add(elmnt)</code>用于给集合添加元素，如果添加的元素在集合中已存在，则不执行任何操作。</p>
<p>2）<code>set.update(set)</code>用于修改当前集合，可以添加新的元素或集合到当前集合中，如果添加的元素在集合中已存在，则该元素只会出现一次，重复的会忽略。</p>
<p>3）<code>set.remove(item)</code> 用于移除集合中的指定元素。如果元素不存在，则会发生错误。</p>
<p>4）<code>set.discard(value)</code> 用于移除指定的集合元素。<code>remove()</code> 方法在移除一个不存在的元素时会发生错误，而 <code>discard()</code> 方法不会。</p>
<p>5）<code>set.pop()</code> 用于随机移除一个元素。</p>
<p>6）<code>set.intersection(set1, set2)</code> 返回两个集合的交集。</p>
<p>7）<code>set1 &amp; set2</code> 返回两个集合的交集。</p>
<p>8）<code>set.intersection_update(set1, set2)</code> 交集，在原始的集合上移除不重叠的元素。</p>
<p>9）<code>set.union(set1, set2)</code> 返回两个集合的并集。</p>
<p>10）<code>set1 | set2</code> 返回两个集合的并集。</p>
<p>11）<code>set.difference(set1)</code> 返回集合的差集。set有，set1没有的。=  set-set1</p>
<p>12）<code>set1 - set2</code> 返回集合的差集。</p>
<p>13）<code>set.difference_update(set1)</code> 集合的差集，直接在原来的集合中移除元素，没有返回值。</p>
<p>14）<code>set.symmetric_difference(set1)</code>返回集合的异或。去掉set和set1中都有的元素。=set^set1</p>
<p>15）<code>set1 ^ set2</code> 返回集合的异或。</p>
<p>16）<code>set.symmetric_difference_update(set1)</code>移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。没有返回值，直接更新原集合set。</p>
<p>17）<code>set.issubset(set1)</code>判断集合是不是被其他集合包含，如果是则返回 True，否则返回 False。</p>
<p>​        =  set &lt;= set1</p>
<p>18）<code>set1 &lt;= set2</code> 判断集合是不是被其他集合包含，如果是则返回 True，否则返回 False。</p>
<p>19）<code>set.issuperset(set1)</code>用于判断集合是不是包含其他集合，如果是则返回 True，否则返回 False。  =  set&gt;= set1</p>
<p>20）<code>set1 &gt;= set2</code> 判断集合是不是包含其他集合，如果是则返回 True，否则返回 False。</p>
<p>21）<code>set.isdisjoint(set)</code> 用于判断两个集合是不是不相交，如果是返回 True，否则返回 False。</p>
<p>5.不可变集合</p>
<p>frozenset，不能增加或删除元素。仍然可以进行集合操作，只是不能用带有update的方法。</p>
<p><code>frozenset([iterable])</code> 返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。</p>
<p>6.练习题</p>
<p>1）怎么表示只包含⼀个数字1的元组。</p>
<p>a = (1,)</p>
<p>2）创建一个空集合，增加 {‘x’,‘y’,‘z’} 三个元素。</p>
<p>s = set()<br>s.add(‘x’)<br>s.add(‘y’)<br>s.add(‘z’)</p>
<p>3）列表[‘A’, ‘B’, ‘A’, ‘B’]去重。</p>
<p>l = [‘A’, ‘B’, ‘A’, ‘B’]<br>l = list(set(l))<br>print(l)    # [‘A’, ‘B’]</p>
<p>4）求两个集合{6, 7, 8}，{7, 8, 9}中不重复的元素（差集指的是两个集合交集外的部分）。</p>
<p>a = {6, 7, 8}<br>b = {7, 8, 9}<br>c = a^b</p>
<p>print(c)     # {9, 6}</p>
<p>5）求{‘A’, ‘B’, ‘C’}中元素在 {‘B’, ‘C’, ‘D’}中出现的次数。</p>
<p>a = {‘A’, ‘B’, ‘C’}<br>b = {‘B’, ‘C’, ‘D’,’B’}<br>c = a&amp;b<br>n = len(c)<br>print(c)    #{‘C’, ‘B’}<br>print(n)     # 2</p>
<p><strong>序列</strong></p>
<p>1.针对序列的内置函数</p>
<p>1）<code>list(sub)</code> 把一个可迭代对象转换为列表。</p>
<p>2）<code>tuple(sub)</code> 把一个可迭代对象转换为元组。</p>
<p>3）<code>str(obj)</code> 把obj对象转换为字符串</p>
<p>4）<code>len(s)</code> 返回对象（字符、列表、元组等）长度或元素个数。</p>
<p>5）<code>max(sub)</code>返回序列或者参数集合中的最大值</p>
<p>6）<code>min(sub)</code>返回序列或参数集合中的最小值</p>
<p>7）<code>sum(iterable[, start=0])</code> 返回序列<code>iterable</code>与可选参数<code>start</code>的总和。</p>
<p>8）<code>sorted(iterable, key=None, reverse=False)</code>对所有可迭代的对象进行排序操作。key为主要用来进行比较的元素，只有一个参数。reverse为排序规则，reverse=True降序，reverse=False升序（默认）。return返回重新排序的列表。</p>
<p>9）<code>reversed(seq)</code> 函数返回一个反转的迭代器。seq可以是tuple，string，list或range。返回的是一个reversed类型的对象，一般转为list使用。</p>
<p>10）enumerate(sequence, [start=0])。start参数为指定索引从start开始算。</p>
<p>11）zip(iter1 [,iter2 […]])。用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象。如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同。</p>
<p>*zip()函数是zip()函数的逆过程，将zip对象变成原先组合前的数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">c = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">zipped = zip(a, b)</span><br><span class="line">print(zipped)  <span class="comment"># &lt;zip object at 0x000000C5D89EDD88&gt;</span></span><br><span class="line">print(list(zipped))  <span class="comment"># [(1, 4), (2, 5), (3, 6)]</span></span><br><span class="line">zipped = zip(a, c)</span><br><span class="line">print(list(zipped))  <span class="comment"># [(1, 4), (2, 5), (3, 6)]</span></span><br><span class="line"></span><br><span class="line">a1, a2 = zip(*zip(a, b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 变成原先组合前的数据</span></span><br><span class="line"></span><br><span class="line">print(*zip(a, b))   <span class="comment"># (1, 4) (2, 5) (3, 6)</span></span><br><span class="line">print(list(a1))  <span class="comment"># [1, 2, 3]</span></span><br><span class="line">print(list(a2))  <span class="comment"># [4, 5, 6]</span></span><br></pre></td></tr></table></figure>


<p>2.练习题</p>
<p>1）怎么找出序列中的最⼤、⼩值？</p>
<p>max()</p>
<p>2）sort() 和 sorted() 区别</p>
<p>sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。</p>
<p>list 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。</p>
<p>3）怎么快速求 1 到 100 所有整数相加之和？</p>
<p>sum([i for i in range(1,101)])</p>
<p>4）求列表 [2,3,4,5] 中每个元素的立方根。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">b = []</span><br><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> enumerate(a):</span><br><span class="line">    x = pow(v,<span class="number">1</span>/<span class="number">3</span>)</span><br><span class="line">    b.append(x)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<p>[1.2599210498948732, 1.4422495703074083, 1.5874010519681994, 1.7099759466766968]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">s = [item <span class="keyword">for</span> item <span class="keyword">in</span> map(<span class="keyword">lambda</span> x:pow(x,<span class="number">1</span>/<span class="number">3</span>),a)]</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>
<p>[1.2599210498948732, 1.4422495703074083, 1.5874010519681994, 1.7099759466766968]</p>
<p>5）将[‘x’,‘y’,‘z’] 和 [1,2,3] 转成 [(‘x’,1),(‘y’,2),(‘z’,3)] 的形式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>]</span><br><span class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">c = zip(a,b)</span><br><span class="line">print(list(c))</span><br></pre></td></tr></table></figure>
<p>[(‘x’, 1), (‘y’, 2), (‘z’, 3)]</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/31/Python-Task05/" data-id="ckddxsxa20005twwc3h5kbizr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-NLP-Task04" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/27/NLP-Task04/" class="article-date">
  <time datetime="2020-07-27T15:33:02.000Z" itemprop="datePublished">2020-07-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/27/NLP-Task04/">NLP-Task04</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="零基础入门NLP-新闻文本分类-Task04"><a href="#零基础入门NLP-新闻文本分类-Task04" class="headerlink" title="零基础入门NLP - 新闻文本分类-Task04"></a>零基础入门NLP - 新闻文本分类-Task04</h1><h2 id="Task04-基于深度学习的文本分类1"><a href="#Task04-基于深度学习的文本分类1" class="headerlink" title="Task04:基于深度学习的文本分类1"></a>Task04:基于深度学习的文本分类1</h2><ol>
<li>FastText</li>
</ol>
<p>1)简介</p>
<p>fastText是一个快速文本分类算法，与基于神经网络的分类算法相比有两大优点：<br>1、fastText在保持高精度的情况下加快了训练速度和测试速度<br>2、fastText不需要预训练好的词向量，fastText会自己训练词向量<br>3、fastText两个重要的优化：Hierarchical Softmax、N-gram<br>2)模型架构</p>
<p>fastText模型架构和word2vec的CBOW模型架构非常相似。下面是fastText模型架构图：</p>
<p><img src="https://pic1.zhimg.com/80/v2-7f38f23e98ee89d21fd16e34d5f07d69_1440w.jpg" alt="img"></p>
<p>注意：此架构图没有展示词向量的训练过程。可以看到，和CBOW一样，fastText模型也只有三层：输入层、隐含层、输出层（Hierarchical Softmax），输入都是多个经向量表示的单词，输出都是一个特定的target，隐含层都是对多个词向量的叠加平均。不同的是，CBOW的输入是目标单词的上下文，fastText的输入是多个单词及其n-gram特征，这些特征用来表示单个文档；CBOW的输入单词被onehot编码过，fastText的输入特征是被embedding过；CBOW的输出是目标词汇，fastText的输出是文档对应的类标。</p>
<p>3）API</p>
<p><strong>train_unsupervised 参数 用来训练词向量模型</strong></p>
<p><strong><em>input</em></strong> :训练文件路径<br><strong><em>model</em></strong> :无监督训练使用的模型 {cbow 和 skip-gram} 默认为skip-gram<br><strong><em>lr</em></strong> :学习率 默认为0.05<br><strong><em>dim</em></strong> : 词向量维度 默认为100<br><strong><em>ws</em></strong> :（windows size） 窗口大小 默认为5<br><strong><em>epoch</em></strong> : 默认训练五轮<br><strong><em>minCount</em></strong> : 最小词数 默认为5 当数据集略小要记得调整<br><strong><em>minCountLabel</em></strong> :=0 因为是无监督。<br><strong><em>minn</em></strong> :最小char级别的3-gram（subword）<br><strong><em>maxn</em></strong> :最大char级别的6-gram （subword）<br><strong><em>neg</em></strong> :负例采样个数 默认为5<br><strong><em>wordNgrams</em></strong> :最大的词n-gram长度 默认为1<br><strong><em>loss</em></strong> :损失函数 {ns,hs,softmax,ova} 默认是ns 负采样 ， hs 是分层softmax<br><strong><em>bucket</em></strong> : 桶数默认为2000000<br><strong><em>thread</em></strong>：cpu线程数 默认为12<br><strong><em>lrUpdateRate</em></strong>：学习率更新，默认为100<br><strong><em>t</em></strong>：负采样阈值 默认0.0001<br><strong><em>verbose</em></strong>：=2</p>
<hr>
<p><strong>train_supervised 参数 用来训练分类模型</strong> 没有model参数√</p>
<p><strong><em>input</em></strong> :训练文件路径<br><strong><em>lr</em></strong> :学习率 默认为<strong>0.1</strong> √<br><strong><em>dim</em></strong> : 词向量维度 默认为100<br><strong><em>ws</em></strong> :（windows size） 窗口大小 默认为5<br><strong><em>minCount</em></strong> : 最小词数 默认为<strong>1</strong>√<br><strong><em>minCountLabel</em></strong> :=<strong>1</strong> √ 最小标签数<br><strong><em>minn</em></strong> :=<strong>0</strong>√<br><strong><em>maxn</em></strong> :=<strong>0</strong>√<br><strong><em>neg</em></strong> :负例采样个数 默认为5<br><strong><em>wordNgrams</em></strong> :最大的词n-gram长度 默认为1<br><strong><em>loss</em></strong> :损失函数 {ns,hs,softmax,ova} 默认是<strong>softmax</strong>√<br><strong><em>bucket</em></strong> : 桶数默认为2000000<br><strong><em>thread</em></strong>：cpu线程数 默认为12<br><strong><em>lrUpdateRate</em></strong>：学习率更新，默认为100<br><strong><em>t</em></strong>：负采样阈值 默认0.0001<br><strong><em>label</em></strong> :标签前缀 默认 ‘_ <em>label</em> _’√<br><strong><em>verbose</em></strong>：=2 控制打印输出 2显示每个epoch 1显示最后一个epoch<br><strong><em>pretrainedVectors</em></strong>:用于监督学习的预训练词向量（.vec文件），给出路径 ，默认为‘ ’</p>
<p>2.基于FastText的文本分类</p>
<ul>
<li>pip安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install fasttext</span><br></pre></td></tr></table></figure>

<ul>
<li>分类模型</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> f1_score</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换为FastText需要的格式</span></span><br><span class="line"><span class="comment"># pandas读取训练集数据</span></span><br><span class="line">train_df = pd.read_csv(<span class="string">'D:/PycharmProjects/tianchiLab/input/train_set.csv'</span>, sep=<span class="string">'\t'</span>, nrows=<span class="number">30000</span>)</span><br><span class="line">print(train_df.head())</span><br><span class="line"><span class="comment"># 拼接'__label__'和label</span></span><br><span class="line">train_df[<span class="string">'label_ft'</span>] = <span class="string">'__label__'</span> + train_df[<span class="string">'label'</span>].astype(str)</span><br><span class="line"><span class="comment"># 取前面25000条数据作为训练集</span></span><br><span class="line">train_df[[<span class="string">'text'</span>,<span class="string">'label_ft'</span>]].iloc[:<span class="number">-5000</span>].to_csv(<span class="string">'train.csv'</span>, index=<span class="literal">None</span>, header=<span class="literal">None</span>, sep=<span class="string">'\t'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> fasttext</span><br><span class="line"><span class="comment"># wordNgrams代表将一个单词和其后面的词组合在一起，如FastText原理介绍中输入层使用的例子。</span></span><br><span class="line"><span class="comment"># lr :学习率 默认为0.1。wordNgrams :最大的词n-gram长度 默认为1。verbose：=2 控制打印输出 2显示每个epoch 1显示最后一个epoch。</span></span><br><span class="line"><span class="comment"># minCount : 最小词数 默认为1。loss :损失函数 &#123;ns,hs,softmax,ova&#125; 默认是softmax。epoch : 训练轮数，默认训练五轮。</span></span><br><span class="line">model = fasttext.train_supervised(<span class="string">'train.csv'</span>, lr=<span class="number">0.5</span>, wordNgrams=<span class="number">2</span>, </span><br><span class="line">                                  verbose=<span class="number">2</span>, minCount=<span class="number">1</span>, epoch=<span class="number">25</span>, loss=<span class="string">"hs"</span>)</span><br><span class="line"><span class="comment"># 后5000条做测试集</span></span><br><span class="line">val_pred = [model.predict(x)[<span class="number">0</span>][<span class="number">0</span>].split(<span class="string">'__'</span>)[<span class="number">-1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> train_df.iloc[<span class="number">-5000</span>:][<span class="string">'text'</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印f1</span></span><br><span class="line">print(f1_score(train_df[<span class="string">'label'</span>].values[<span class="number">-5000</span>:].astype(str), val_pred, average=<span class="string">'macro'</span>))</span><br></pre></td></tr></table></figure>

<p>0.87332537480972</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/27/NLP-Task04/" data-id="ckddxsxa00003twwc8ojz6ioz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/08/23/Leetcode-Task02/">Leetcode-Task02</a>
          </li>
        
          <li>
            <a href="/2020/08/19/Leetcode-Task01/">Leetcode-Task01</a>
          </li>
        
          <li>
            <a href="/2020/08/07/Python-Task09/">Python-Task09</a>
          </li>
        
          <li>
            <a href="/2020/08/07/Python-Task08/">Python-Task08</a>
          </li>
        
          <li>
            <a href="/2020/08/05/Python-Task07/">Python-Task07</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>