<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Python-Task07" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/05/Python-Task07/" class="article-date">
  <time datetime="2020-08-05T15:20:52.000Z" itemprop="datePublished">2020-08-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/05/Python-Task07/">Python-Task07</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Python编程基础-Task07"><a href="#Python编程基础-Task07" class="headerlink" title="Python编程基础-Task07"></a>Python编程基础-Task07</h1><h2 id="Task-7-类、对象与魔法方法"><a href="#Task-7-类、对象与魔法方法" class="headerlink" title="Task 7:类、对象与魔法方法"></a>Task 7:类、对象与魔法方法</h2><p><strong>类</strong></p>
<p>1. </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/05/Python-Task07/" data-id="ckdhise3o0000h4wc0n7l0fdg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-NLP-Task06" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/04/NLP-Task06/" class="article-date">
  <time datetime="2020-08-04T15:38:13.000Z" itemprop="datePublished">2020-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/04/NLP-Task06/">NLP-Task06</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="零基础入门NLP-新闻文本分类-Task06"><a href="#零基础入门NLP-新闻文本分类-Task06" class="headerlink" title="零基础入门NLP - 新闻文本分类-Task06"></a>零基础入门NLP - 新闻文本分类-Task06</h1><h2 id="Task06-基于深度学习的文本分类3"><a href="#Task06-基于深度学习的文本分类3" class="headerlink" title="Task06:基于深度学习的文本分类3"></a>Task06:基于深度学习的文本分类3</h2><p>1.Attention Is All You Need论文学习</p>
<p>摘要</p>
<p>主流的序列转换模型都基于复杂的循环或卷积神经网络，包括编码器和解码器。最佳性能的模型还通过注意力机制将编码器和解码器连接起来。我们提出了一种新的简单网络架构Transformer，它仅仅基于注意力机制，完全不需要循环和卷积。在两个机器翻译任务上的实验表明，这些模型在质量上更优，同时更具并行性，并且需要更少的训练时间。我们的模型在WMT 2014英语到德语的翻译任务中达到了28.4 BLEU，比现有的最佳结果(包括集成模型)提高了2个BLEU以上。在WMT 2014英语到法语翻译任务中，我们的模型在八个GPU上训练了3.5天后，建立了一个新的单模型，效果为BLEU分数41.8，是其他最好模型的训练成本的一小部分。我们通过将Transformer成功应用于大量训练数据和有限训练数据的两种情况下的英语成分解析，表明Transformer可以很好地推广到其他任务。</p>
<p>1 introduction</p>
<p>递归神经网络，特别是长短期记忆[13]和门控递归[7]神经网络，已经作为序列建模和转换问题的最先进的解决方法，诸如在语言模型和机器翻译上。自那以后，许多努力继续推进循环语言模型和编码器-解码器架构[38，24，15 ]。</p>
<p>循环模型通常沿着输入和输出序列的符号位置进行计算。将位置与计算时间中的步骤对齐，它们生成隐藏状态ht序列，作为先前隐藏状态ht - 1和位置t的输入的函数。这种固有的顺序性质使在训练中难以并行化，当序列长度较长时这变得相当致命，因为存储器约束限制了批处理。最近的工作通过因式分解技巧[ 21 ]和条件计算[ 32 ]在计算效率上取得了显著提高，同时在后者的情况下也提高了模型性能。然而，顺序计算的基本约束仍然存在。</p>
<p>注意力机制已经成为各种任务中很重要的一部分，允许对依赖关系进行建模，而不考虑它们在输入或输出序列中的距离[ 2，19 ]。然而，在除了少数情况之外的所有情况下，[ 27 ]，这种关注机制经常与神经网络结合使用。</p>
<p>在这项工作中，我们提出了Transformer，它不用循环，取而代之的是完全依赖attention机制来描绘输入输出之间的全局依赖。Transformer允许更大程度的并行化，并且在八个P100 GPUs上训练12小时后，翻译质量可以达到最先进的水平。</p>
<p>2 Background</p>
<p>减少顺序计算的目标也是扩展神经GPU[16], ByteNet [18]和ConvS2S [9]的基础，所有这些都使用卷积神经网络作为基本构件，并行计算所有输入和输出位置的隐藏表示。在这些模型中，将来自两个任意输入或输出位置的信号相关联所需的操作数量随着位置之间的距离增加，对于ConvS2S为线性，对于ByteNet为对数。这使得了解远处位置之间的相关性变得更加困难，[ 12 ]。在Transformer中，这操作会被减少到固定数量，尽管由于平均注意力加权位置而降低了有效resolution，正如第3.2节所述，我们用Multi-Head注意力抵消了这种影响。</p>
<p>Self-attention，有时被称为intra-attention，是一种attention机制，将单个序列的不同位置联系起来，以计算该序列的表示。自我关注已经成功地应用于各种任务中，包括阅读理解、抽象概括、文本蕴涵和独立于学习任务的句子表征[ 4、27、28、22 ]。</p>
<p>端到端记忆网络是基于循环注意力机制，而不是序列对齐的循环，在简单语言问答和语言建模任务中表现良好，[ 34 ]。</p>
<p>然而，Transformer是第一个完全依靠self-attention来计算其输入和输出表示的转换模型，而不使用序列rnn或者卷积模型。在接下来的章节中，我们将描述Transformer，激发self-attention，并讨论其优于[ 17、18 ]和[ 9 ]等模型的优势。</p>
<p>3 Model Architecture</p>
<p>大部分有竞争力的神经序列转换模型 都有一个encoder-decoder结构。Encoder会把一个输入的序列表示（x1，x2，。。。Xn）映射为另一个表示z=（z1，。。。Zn）。接着，decoder会根据z输出序列（y1，。。Ym）。模型的每一步都是自回归的，并且当生成下一个的时候会消耗以前生成的符号作为额外的输入。</p>
<p>Transformer大概沿用这种架构，为encoder和decoder同时使用tacked self-attention和point-wise，还有全连接层，分别如下图的左半部分和右半部分所示。</p>
<p><img src="NLP-Task06/8e0b1_1440w.jpeg" alt="img"></p>
<p>3.1 Encoder and Decoder Stacks</p>
<p>Encoder:encoder由6个相同层堆叠而成。每一层都有两个子层。首先是一个multi-head self-attention 机制，第二个是简单的、按位置全连接的前馈网络。我们在两个子层的每一个周围都使用残差连接，然后是层归一化。也就是说，每个子层的输出是LayerNorm(x+ Sublayer(x))，其中Sublayer(x)是由子层本身实现的功能。为了便于这些残差连接，模型中的所有子层以及嵌入层产生尺寸 </p>
<p><img src="https://www.zhihu.com/equation?tex=d_%7Bmodel%7D" alt="img"></p>
<p> = 512的输出。</p>
<p>Decoder:decoder也由6个相同层堆叠而成。除了decoder里面有的两个子层，还加入了第三个子层，可以在encoder的输出上有multi-head attention的功能。我们同样在子层周围用残差连接和层归一化。我们还修改了decoder堆栈中的self-attention子层，以防止位置关注后续位置。这种masking，加上输出嵌入偏移一个位置，确保了位置i的预测只能依赖于小于i的位置处的已知输出。</p>
<p>3.2 Attention</p>
<p>Attention函数可以描述为将query和一组key-value对映射到输出，其中query、key、value和输出都是向量。 输出为value的加权和，其中分配给每个value的权重通过query与相应key的兼容函数来计算。</p>
<p><img src="NLP-Task06/5b75f_1440w.jpeg" alt="img"></p>
<p>3.2.1 Scaled Dot-Product Attention</p>
<p>我们称我们特殊的attention为“缩放版的点积attention”（图 2）。 输入由query、 </p>
<p><img src="https://www.zhihu.com/equation?tex=d_k" alt="img"></p>
<p> 维的key和</p>
<p><img src="https://www.zhihu.com/equation?tex=d_v+" alt="img"></p>
<p> 维的value组成。 我们计算query和所有key的点积、用 </p>
<p><img src="https://www.zhihu.com/equation?tex=%5Csqrt%7Bd_%7Bk%7D%7D+" alt="img"></p>
<p> 相除，然后应用一个softmax函数以获得值的权重。</p>
<p>在实践中，我们同时计算一组query的attention函数，将它们组合成一个矩阵Q。 key和value也一起打包成矩阵 K 和 V 。 我们计算输出矩阵为：</p>
<p><img src="NLP-Task06/3bcd2d_1440w.png" alt="img"></p>
<p>两个最常用的attention函数是加法attention[2]和点积（乘法）attention。 除了缩放因子 </p>
<p><img src="https://www.zhihu.com/equation?tex=%5Cfrac%7B1%7D%7B%5Csqrt%7Bd_%7Bk%7D%7D%7D" alt="img"></p>
<p> 之外，点积attention与我们的算法相同。 加法attention使用具有单个隐藏层的前馈网络计算兼容性函数。 虽然两者在理论上的复杂性相似，但在实践中点积attention的速度更快、更节省空间，因为它可以使用高度优化的矩阵乘法代码来实现。</p>
<p>当 </p>
<p><img src="https://www.zhihu.com/equation?tex=d_k" alt="img"></p>
<p> 的值比较小的时候，这两个机制的性能相差相近，当 </p>
<p><img src="https://www.zhihu.com/equation?tex=d_k+" alt="img"></p>
<p> 比较大时，加法attention比不带缩放的点积attention性能好[3]。 我们怀疑，对于很大的 </p>
<p><img src="https://www.zhihu.com/equation?tex=d_k" alt="img"></p>
<p> 值，点积大幅度增长，将softmax函数推向具有极小梯度的区域。 为了抵消这种影响，我们缩小点积 </p>
<p><img src="https://www.zhihu.com/equation?tex=+%5Cfrac%7B1%7D%7B%5Csqrt%7Bd_%7Bk%7D%7D%7D+" alt="img"></p>
<p> 倍。（作者备注：为了解释点积为什么变大，假设q和k的组成成员是独立随机的变量，其均值为0方差为1。然后它们的点积有均值0和方差 </p>
<p><img src="https://www.zhihu.com/equation?tex=d_k" alt="img"></p>
<p> 。 </p>
<p><img src="https://www.zhihu.com/equation?tex=d_k" alt="img"></p>
<p> 过大会进入softmax的极小梯度区。</p>
<p>3.2.2 Multi-Head Attention</p>
<p>我们发现将query、key和value分别用不同的、学习到的线性映射来映射到 </p>
<p><img src="https://www.zhihu.com/equation?tex=d_k" alt="img"></p>
<p> 、 </p>
<p><img src="https://www.zhihu.com/equation?tex=d_k" alt="img"></p>
<p> 和 </p>
<p><img src="https://www.zhihu.com/equation?tex=d_v" alt="img"></p>
<p> 维h次效果更好，而不是用 </p>
<p><img src="https://www.zhihu.com/equation?tex=d_%7Bmodel%7D" alt="img"></p>
<p> 维的query、key和value执行单个attention函数。 基于每个映射版本的query、key和value，我们并行执行attention函数，产生</p>
<p><img src="https://www.zhihu.com/equation?tex=d_v" alt="img"></p>
<p> 维输出值。 将它们连接并再次映射，产生最终值，如图所示 2。</p>
<p>Multi-head attention允许模型的不同表示子空间联合关注不同位置的信息。 如果只有一个attention head，它的平均值会削弱这个信息。</p>
<p><img src="NLP-Task06/f9775d_1440w.png" alt="img"></p>
<p>其中，映射为参数矩阵WiQ ∈ ℝdmodel×dk , WiK ∈ ℝdmodel×dk , WiV ∈ ℝdmodel×dv 及W O ∈ ℝhdv×dmodel。</p>
<p>在这项工作中，我们采用h = 8 个并行attention层或head。 对每个head，我们使用 </p>
<p><img src="https://www.zhihu.com/equation?tex=d_k" alt="img"></p>
<p> = </p>
<p><img src="https://www.zhihu.com/equation?tex=d_v" alt="img"></p>
<p> = </p>
<p><img src="https://www.zhihu.com/equation?tex=d_%7Bmodel%7D" alt="img"></p>
<p> ∕ h = 64。 由于每个head的大小减小，总的计算成本与具有全部维度的单个head attention相似。</p>
<p>3.2.3 Applications of Attention in our Model</p>
<p>Transformer使用以3种方式使用multi-head attention：</p>
<p>在“编码器—解码器attention”层，query来自前一个解码器层，key和value来自编码器的输出。 这允许解码器中的每个位置能关注到输入序列中的所有位置。 这模仿序列到序列模型中典型的编码器—解码器的attention机制，例如[38, 2, 9]。</p>
<p>编码器包含self-attention层。 在self-attention层中，所有的key、value和query来自同一个地方，在这里是编码器中前一层的输出。编码器中的每个位置都可以关注编码器上一层的所有位置。</p>
<p>类似地，解码器中的self-attention层允许解码器中的每个位置都关注解码器中直到并包括该位置的所有位置。我们需要防止解码器中的向左信息流，来保持自回归属性。通过屏蔽softmax的输入中所有不合法连接的值（设置为-∞），我们在缩放版的点积attention中实现。 见图 2.</p>
<p>3.3 Position-wise Feed-Forward Networks</p>
<p>除了attention子层之外，我们的编码器和解码器中的每个层都包含一个完全连接的前馈网络，该前馈网络单独且相同地应用于每个位置。 它由两个线性变换组成，之间有一个ReLU激活。</p>
<p><img src="NLP-Task06/2209c7_1440w.png" alt="img"></p>
<p>尽管线性变换在不同位置上是相同的，但它们层与层之间的参数是不一样的。 它的另一种描述方式是两个内核大小为1的卷积。 输入和输出的维度为 </p>
<p><img src="https://www.zhihu.com/equation?tex=d_%7Bmodel%7D" alt="img"></p>
<p> = 512，内部层的维度为 </p>
<p><img src="https://www.zhihu.com/equation?tex=d_%7Bff%7D" alt="img"></p>
<p> = 2048。</p>
<p>3.4 Embeddings and Softmax</p>
<p>与其他序列转导模型类似，我们使用学习到的嵌入将输入词符和输出词符转换为维度为dmodel的向量。 我们还使用普通的线性变换和softmax函数将解码器输出转换为预测的下一个词符的概率。 在我们的模型中，两个嵌入层之间和pre-softmax线性变换共享相同的权重矩阵，类似于[30]。 在嵌入层中，我们将这些权重乘以 </p>
<p><img src="https://www.zhihu.com/equation?tex=%5Csqrt%7Bd_%7Bmodel%7D%7D+" alt="img"></p>
<p> 。</p>
<p>3.5 Positional Encoding</p>
<p>由于我们的模型不包含循环和卷积，为了让模型利用序列的顺序，我们必须注入序列中关于词符相对或者绝对位置的一些信息。 为此，我们将“位置编码”添加到编码器和解码器堆栈底部的输入嵌入中。 位置编码和嵌入的维度 </p>
<p><img src="https://www.zhihu.com/equation?tex=d_%7Bmodel%7D" alt="img"></p>
<p> 相同，所以它们俩可以相加。 有多种位置编码可以选择，例如通过学习得到的位置编码和固定的位置编码[9]。</p>
<p>在这项工作中，我们使用不同频率的正弦和余弦函数：</p>
<p><img src="NLP-Task06/b7b7e_1440w.jpeg" alt="img"></p>
<p>其中pos 是位置，i 是维度。 也就是说，位置编码的每个维度对应于一个正弦曲线。 这些波长形成一个几何级数，从2π 到10000 ⋅ 2π。 我们选择这个函数是因为我们假设它允许模型很容易学习对相对位置的关注，因为对任意确定的偏移k, </p>
<p><img src="https://www.zhihu.com/equation?tex=PE_%7Bpos%2Bk%7D" alt="img"></p>
<p> 可以表示为 </p>
<p><img src="https://www.zhihu.com/equation?tex=PE_%7Bpos%7D" alt="img"></p>
<p> 的线性函数。</p>
<p>我们还使用学习到的位置嵌入进行了试验，发现这两个版本产生几乎相同的结果（参见表 3 行(E)）。 我们选择了正弦曲线，因为它允许使用时出现比训练时更长的序列。</p>
<p>4 Why Self-Attention</p>
<p>本节，我们比较self-attention与循环层和卷积层的各个方面，它们通常用于映射变长的符号序列表示(x1,…,xn) 到另一个等长的序列(z1,…,zn)，其中xi,zi ∈ ℝd，例如一个典型的序列转导编码器或解码器中的隐藏层。 我们使用self-attention是考虑到要解决三个问题。</p>
<p>一个是每层计算的总复杂度。 另一个是可以并行的计算量，以所需的最小顺序操作的数量来衡量。</p>
<p>第三个是网络中长距离依赖之间的路径长度。 学习长距离依赖性是许多序列转导任务中的关键挑战。 影响学习这种依赖能力的一个关键因素，是前向和后向信号必须在网络中传播的路径长度。 输入和输出序列中任意位置组合之间的这些路径越短，学习远距离依赖性就越容易[12]。因此，我们还比较了由不同层类型组成的网络中任意两个输入和输出位置之间的最大路径长度。</p>
<p><img src="NLP-Task06/0c2e9_1440w.jpeg" alt="img"></p>
<p>如表1所示，self-attention层将所有位置连接到恒定数量的顺序执行的操作，而循环层需要O(n) 顺序操作。 在计算复杂性方面，当序列长度n 小于表示维度d 时，self-attention层比循环层快，这是机器翻译中最先进的模型最常见情况，例如单词[38]表示法和字节对[31]表示法。为了提高涉及很长序列的任务的计算性能，可以将self-attention限制在仅考虑大小为r 的邻域。 这会将最大路径长度增加到O(n ∕ r)。 我们计划在未来的工作中进一步调查这种方法。</p>
<p>核宽度为k &lt; n的单层卷积不会连接每一对输入和输出的位置。 要这么做，在邻近核的情况下需要O(n∕k) 个卷积层， 在扩展卷积的情况下需要O(logk(n)) 个层[18]，它们增加了网络中任意两个位置之间的最长路径的长度。 卷积层通常比循环层更昂贵，与因子k有关。然而，可分卷积[6]大幅减少复杂度到O(k ⋅n⋅d + n⋅d2)。 然而，即使k = n，一个可分卷积的复杂度等同于self-attention层和point-wise前向层的组合，即我们的模型采用的方法。</p>
<p>间接的好处是self-attention可以产生更可解释的模型。 我们从我们的模型中研究attention的分布，并在附录中展示和讨论示例。 每个attention head不仅清楚地学习到执行不同的任务，许多似乎展现与句子的句法和语义结构的行为。</p>
<p>5 Training</p>
<p>本节介绍我们的模型训练方法。</p>
<p>5.1 训练数据和批次</p>
<p>我们在标准的WMT 2014英语-德语数据集上进行了训练，其中包含约450万个句子对。 这些句子使用字节对编码[3]进行编码，源语句和目标语句共享大约37000个词符的词汇表。 对于英语-法语翻译，我们使用大得多的WMT 2014英法数据集，它包含3600万个句子，并将词符分成32000个word-piece词汇表[38]。 序列长度相近的句子一起进行批处理。 每个训练批次的句子对包含大约25000个源词符和25000个目标词符。</p>
<p>5.2 硬件和时间</p>
<p>我们在一台具有8个NVIDIA P100 GPU的机器上训练我们的模型。 使用本文描述的超参数的基础模型，每个训练步骤耗时约0.4秒。 我们的基础模型共训练了10万步或12小时。 对于我们的大模型(表格三底部一行), 每一步耗时1秒. 大模型训练了30万步（3.5天）。</p>
<p>5.3 优化</p>
<p>我们使用Adam优化[20]，其中β1 = 0.9, β2 = 0.98 及ϵ = 10-9。 我们根据以下公式在训练过程中改变学习率：</p>
<p><img src="NLP-Task06/bda5e4_1440w.png" alt="img"></p>
<p>这对应于在第一次warm up_steps 步骤中线性地增加学习速率，并且随后将其与步骤数的平方根成比例地减小。 我们使用warm up_steps = 4000。</p>
<p>5.4 正则化</p>
<p>训练期间我们采用三种正则化：</p>
<p>残差dropout 我们将dropout[33]在它与子层的输入相加和正则化之前，应用到每个子层的输出中。 此外，在编码器和解码器堆栈中，我们将dropout应用到嵌入和位置编码的和这一步骤中。 对于基本模型，我们使用</p>
<p><img src="https://www.zhihu.com/equation?tex=P_%7Bdrop%7D" alt="img"></p>
<p> = 0.1。</p>
<p><img src="NLP-Task06/d161f_1440w.jpeg" alt="img"></p>
<p>Label Smoothing 在训练过程中，我们使用的label smoothing的值为ϵls = 0.1[36]。 这让模型不易理解，因为模型学得更加不确定，但提高了准确性和BLEU得分。</p>
<p>6 Results</p>
<p>6.1 Machine Translation</p>
<p>在WMT 2014英语-德语翻译任务中，大型transformer模型（表2中的Transformer (big)）比以前报道的最佳模型（包括集成模型）高出2.0个BLEU以上，确立了一个全新的最高BLEU分数为28.4。 该模型的配置列在表3的底部。 训练在8 个P100 GPU上花费3.5 天。 即使我们的基础模型也超过了以前发布的所有模型和整合模型，且训练成本只是这些模型的一小部分。</p>
<p>在WMT 2014英语-法语翻译任务中，我们的大型模型的BLEU得分为41.0，超过了之前发布的所有单一模型，训练成本低于先前最先进模型的1 ∕ 4 。 英语-法语的Transformer (big) 模型使用丢弃率为</p>
<p><img src="https://www.zhihu.com/equation?tex=P_%7Bdrop%7D" alt="img"></p>
<p> = 0.1，而不是0.3。</p>
<p>对于基础模型，我们使用的单个模型来自最后5个检查点的平均值，这些检查点每10分钟写一次。 对于大型模型，我们对最后20个检查点进行了平均。 我们使用beam search，beam大小为4 ，长度惩罚α = 0.6 [38]。 这些超参数是在开发集上进行实验后选定的。 在推断时，我们设置最大输出长度为输入长度+50，但在可能时尽早终止[38]。</p>
<p>表2总结了我们的结果，并将我们的翻译质量和训练成本与文献中的其他模型体系结构进行了比较。 我们通过将训练时间、所使用的GPU的数量以及每个GPU的持续单精度浮点能力的估计相乘来估计用于训练模型的浮点运算的数量。</p>
<p><img src="NLP-Task06/f08bc_1440w.jpeg" alt="img"></p>
<p>6.2 Model Variations</p>
<p>为了评估Transformer不同组件的重要性，我们以不同的方式改变我们的基础模型，测量开发集newstest2013上英文-德文翻译的性能变化。我们使用前一节所述的beam搜索，但没有平均检查点。 我们在表中列出这些结果。</p>
<p>在表3的行（A）中，我们改变attention head的数量和attention key和value的维度，保持计算量不变，如3.2.2节所述。 虽然只有一个head attention比最佳设置差0.9 BLEU，但质量也随着head太多而下降。</p>
<p>在表3行（B）中，我们观察到减小key的大小dk会有损模型质量。 这表明确定兼容性并不容易，并且比点积更复杂的兼容性函数可能更有用。我们在行（C）和（D）中进一步观察到，如预期的那样，更大的模型更好，并且dropout对避免过度拟合非常有帮助。 在行（E）中，我们用学习到的位置嵌入[9]来替换我们的正弦位置编码，并观察到与基本模型几乎相同的结果。</p>
<p>7 结论</p>
<p>在这项工作中，我们提出了Transformer，第一个完全基于attention的序列转导模型，用multi-headed self-attention取代了编码器-解码器架构中最常用的循环层。</p>
<p>对于翻译任务，Transformer可以比基于循环或卷积层的体系结构训练更快。 在WMT 2014英语-德语和WMT 2014英语-法语翻译任务中，我们取得了最好的结果。 在前面的任务中，我们最好的模型甚至胜过以前报道过的所有集成模型。</p>
<p>我们对基于attention的模型的未来感到兴奋，并计划将它们应用于其他任务。 我们计划将Transformer扩展到除文本之外的涉及输入和输出模式的问题，并调查局部的、受限attention机制以有效处理大型输入和输出，如图像、音频和视频。 让生成具有更少的顺序性是我们的另一个研究目标。</p>
<p>我们用于训练和评估模型的代码可以在<a href="https://link.zhihu.com/?target=https%3A//github.com/tensorflow/tensor2tensor">https://github.com/tensorflow/tensor2tensor</a>上找到。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/04/NLP-Task06/" data-id="ckdg43r0g0001kkwc9aen3w0c" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-NLP-Task05" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/04/NLP-Task05/" class="article-date">
  <time datetime="2020-08-04T03:55:04.000Z" itemprop="datePublished">2020-08-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/04/NLP-Task05/">NLP-Task05</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="零基础入门NLP-新闻文本分类-Task05"><a href="#零基础入门NLP-新闻文本分类-Task05" class="headerlink" title="零基础入门NLP - 新闻文本分类-Task05"></a>零基础入门NLP - 新闻文本分类-Task05</h1><h2 id="Task05-基于深度学习的文本分类2"><a href="#Task05-基于深度学习的文本分类2" class="headerlink" title="Task05:基于深度学习的文本分类2"></a>Task05:基于深度学习的文本分类2</h2><ol>
<li>思路1：Count Vectors + RidgeClassifier</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/04/NLP-Task05/" data-id="ckdg43r090000kkwca3tqhb27" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Python-Task06" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/08/02/Python-Task06/" class="article-date">
  <time datetime="2020-08-02T15:50:49.000Z" itemprop="datePublished">2020-08-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/08/02/Python-Task06/">Python-Task06</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Python编程基础-Task06"><a href="#Python编程基础-Task06" class="headerlink" title="Python编程基础-Task06"></a>Python编程基础-Task06</h1><h2 id="Task-6-函数与Lambda表达式"><a href="#Task-6-函数与Lambda表达式" class="headerlink" title="Task 6:函数与Lambda表达式"></a>Task 6:函数与Lambda表达式</h2><p>1.函数定义 </p>
<p>def关键词开头，后接函数名和圆括号()。</p>
<p>return表达式结束函数，选择性的返回一个值给调用方。不带表达式return相当于返回<code>None</code>。</p>
<p>2.函数参数</p>
<p>1）位置参数，这些参数在调用函数 (call function) 时位置要固定。</p>
<p>2）默认参数，<code>arg2 = v</code> - 默认参数 = 默认值。默认参数一定要放在位置参数 <strong>后面</strong>，不然程序会报错。</p>
<p>3）可变参数，<code>*args</code> - 可变参数，可以是从零个到任意个，自动组装成元组。加了星号（*）的变量名会存放所有未命名的变量参数。</p>
<p>4）关键字参数，<code>**kw</code> - 关键字参数，可以是从零个到任意个，自动组装成字典。传入时，每个关键字参数写为key=value的形式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">printinfo</span><span class="params">(arg1, *args, **kwargs)</span>:</span></span><br><span class="line">    print(arg1)</span><br><span class="line">    print(args)</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printinfo(<span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span>)</span><br><span class="line"><span class="comment"># 70</span></span><br><span class="line"><span class="comment"># (60, 50)</span></span><br><span class="line"><span class="comment"># &#123;&#125;</span></span><br><span class="line">printinfo(<span class="number">70</span>, <span class="number">60</span>, <span class="number">50</span>, a=<span class="number">1</span>, b=<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 70</span></span><br><span class="line"><span class="comment"># (60, 50)</span></span><br><span class="line"><span class="comment"># &#123;'a': 1, 'b': 2&#125;</span></span><br></pre></td></tr></table></figure>

<p>「可变参数」和「关键字参数」的同异总结如下：</p>
<ul>
<li>可变参数允许传入零个到任意个参数，它们在函数调用时自动组装为一个元组 (tuple)。</li>
<li>关键字参数允许传入零个到任意个参数，它们在函数内部自动组装为一个字典 (dict)。</li>
</ul>
<p>5）命名关键字参数</p>
<p><code>*, nkw</code> - 命名关键字参数，用户想要输入的关键字参数，定义方式是在nkw 前面加个分隔符 *。</p>
<p>使用命名关键字参数时，要特别注意不能缺少参数名。不加参数名，程序可能会认为是位置参数。</p>
<p>6）参数组合</p>
<p>这 5 种参数中的 4 个都可以一起使用，但是注意，参数定义的顺序必须是：</p>
<ul>
<li>位置参数、默认参数、可变参数和关键字参数。</li>
<li>位置参数、默认参数、命名关键字参数和关键字参数。</li>
</ul>
<p>要注意定义可变参数和关键字参数的语法：</p>
<ul>
<li><code>*args</code> 是可变参数，<code>args</code> 接收的是一个 <code>tuple</code></li>
<li><code>**kw</code> 是关键字参数，<code>kw</code> 接收的是一个 <code>dict</code></li>
</ul>
<p>命名关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。定义命名关键字参数不要忘了写分隔符 <code>*</code>，否则定义的是位置参数。</p>
<p>3.变量作用域</p>
<p>当内部作用域想修改外部作用域的变量时，就要用到<code>global</code>和<code>nonlocal</code>关键字了。</p>
<p>4.闭包</p>
<p>如果在一个内部函数里对外层非全局作用域的变量进行引用，那么内部函数就被认为是闭包。</p>
<p>通过闭包可以访问外层非全局作用域的变量，这个作用域称为 <strong>闭包作用域</strong>。如果要修改闭包作用域中的变量则需要 <code>nonlocal</code> 关键字。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funX</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">funY</span><span class="params">(y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x * y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> funY</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">i = funX(<span class="number">8</span>)</span><br><span class="line">print(type(i))  <span class="comment"># &lt;class 'function'&gt;</span></span><br><span class="line">print(i(<span class="number">5</span>))  <span class="comment"># 40</span></span><br></pre></td></tr></table></figure>

<p>5.递归</p>
<p>如果一个函数在内部调用自身本身，这个函数就是递归函数。</p>
<p>可以通过setrecursionlimit设置递归的层数，Python默认递归层数为100。</p>
<p>6.Lambda表达式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> argument_list: expression</span><br></pre></td></tr></table></figure>

<p><code>expression</code> 中没有 return 语句，因为 lambda 不需要它来返回，表达式本身结果就是返回值。</p>
<p>匿名函数拥有自己的命名空间，且不能访问自己参数列表之外或全局命名空间里的参数。</p>
<p><code>filter(function, iterable)</code> 过滤序列，过滤掉不符合条件的元素，返回一个迭代器对象，如果要转换为列表，可以使用 <code>list()</code> 来转换。</p>
<p><code>map(function, *iterables)</code> 根据提供的函数对指定序列做映射。</p>
<p>7.练习题</p>
<p>1）怎么给函数编写⽂档？</p>
<p>可以在函数中利用双引号“ ”编写文档，利用<code>__doc__</code>、<code>__name__</code>等关键字获取函数的注释、名称等。利用help(MyFirstFunction)指令可以获得函数相关文档。</p>
<p>2）怎么给函数参数和返回值注解？</p>
<p>用 <code>: 类型</code> 的形式指定函数的<strong>参数类型</strong>，用 <code>-&gt; 类型</code> 的形式指定函数的<strong>返回值</strong>类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x:int, y:int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure>

<p>不过需要强调的是，Python 解释器<strong>并不会</strong>因为这些注解而提供额外的校验，没有任何的类型检查工作。也就是说，这些类型注解加不加，对你的代码来说<strong>没有任何影响</strong>。</p>
<p>但这么做的好处是：</p>
<ol>
<li>让别的程序员看得更明白</li>
<li>让 IDE 了解类型，从而提供更准确的代码提示、补全和语法检查（包括类型检查，可以看到 str 和 float 类型的参数被高亮提示）</li>
</ol>
<p>获取我们定义的函数注解：<code>__annotations__</code>、<code>inspect.signature</code></p>
<p>在 Python 3.6 中，又引入了对<strong>变量类型</strong>进行注解的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a: int = <span class="number">123</span></span><br><span class="line">b: str = <span class="string">'hello'</span></span><br></pre></td></tr></table></figure>

<p>更进一步，如果你需要指明一个全部由整数组成的列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line">l: List[int] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<p>3）闭包中，怎么对数字、字符串、元组等不可变元素更新。</p>
<p>如果要修改闭包作用域中的变量需要 <code>nonlocal</code> 关键字。</p>
<p>4）分别根据每一行的首元素和尾元素大小对二维列表 a = [[6, 5], [3, 7], [2, 8]] 排序。(利用lambda表达式)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = [[<span class="number">6</span>, <span class="number">5</span>], [<span class="number">3</span>, <span class="number">7</span>], [<span class="number">2</span>, <span class="number">8</span>]] </span><br><span class="line">b = sorted(a, key=<span class="keyword">lambda</span> i:i[<span class="number">0</span>])</span><br><span class="line">print(b)</span><br><span class="line">b = sorted(a, key=<span class="keyword">lambda</span> i:i[<span class="number">0</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">print(b)</span><br><span class="line">b = sorted(a, key=<span class="keyword">lambda</span> i:i[<span class="number">-1</span>])</span><br><span class="line">print(b)</span><br><span class="line">b = sorted(a, key=<span class="keyword">lambda</span> i:i[<span class="number">-1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<p>[[2, 8], [3, 7], [6, 5]]<br>[[6, 5], [3, 7], [2, 8]]<br>[[6, 5], [3, 7], [2, 8]]<br>[[2, 8], [3, 7], [6, 5]]</p>
<p>5）利用python解决汉诺塔问题？</p>
<p>move(n, a, b, c)。可以这样理解：move(盘子数量, 起点, 缓冲, 终点)。</p>
<p>（1）a 上只有一个盘子的情况，直接搬到 c，代码如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">    print(a, <span class="string">'--&gt;'</span>, c)</span><br></pre></td></tr></table></figure>

<p>（2）a 上不止有一个盘子的情况:</p>
<p>首先，需要把 n-1 个盘子搬到 b 柱子缓冲。打印出的效果是：a –&gt; b。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move(n - <span class="number">1</span>, a, c, b)</span><br></pre></td></tr></table></figure>

<p>再把最大的盘子搬到 c 柱子，也是最大尺寸的一个。打印出：a–&gt;c。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move(<span class="number">1</span>, a, b, c)</span><br></pre></td></tr></table></figure>

<p>最后，把剩下 b 柱的 n-1 个盘子搬到 c 上，此时缓冲变成了起点，起点变成了缓冲。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move(n - <span class="number">1</span>, b, a, c)</span><br></pre></td></tr></table></figure>

<p>程序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">move</span><span class="params">(n, a, b, c)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> i</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>):</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        print(<span class="string">'移动第 &#123;0&#125; 次 &#123;1&#125; --&gt; &#123;2&#125;'</span>.format(i, a, c))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    move(n - <span class="number">1</span>, a, c, b)</span><br><span class="line">    move(<span class="number">1</span>, a, b, c)</span><br><span class="line">    move(n - <span class="number">1</span>, b, a, c)</span><br><span class="line"></span><br><span class="line">move(<span class="number">64</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>)</span><br></pre></td></tr></table></figure>




      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/08/02/Python-Task06/" data-id="ckddxsxa60009twwcfrzl6537" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Python-Task05" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/31/Python-Task05/" class="article-date">
  <time datetime="2020-07-30T23:15:47.000Z" itemprop="datePublished">2020-07-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/31/Python-Task05/">Python-Task05</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Python编程基础-Task05"><a href="#Python编程基础-Task05" class="headerlink" title="Python编程基础-Task05"></a>Python编程基础-Task05</h1><h2 id="Task-5-字典、集合和序列"><a href="#Task-5-字典、集合和序列" class="headerlink" title="Task 5:字典、集合和序列"></a>Task 5:字典、集合和序列</h2><p><strong>字典</strong></p>
<p>1.字典是python唯一的一个映射类型，字符串、元组、列表属于序列类型。</p>
<p>序列类型和字典不同之处：序列以连续的整数为索引，字典以“关键字”为索引，关键字可以是任意不可变类型，通常用字符串或数值。</p>
<p>2.可变类型与不可变类型</p>
<p>不可变类型：数值(int/float/bool)、字符、元组</p>
<p>可变类型：列表、集合、字典</p>
<p>如何快速判断一个数据类型x是不是可变类型：</p>
<ul>
<li>用 <code>id(X)</code> 函数，对 X 进行某种操作，比较操作前后的 <code>id</code>，如果不一样，则 <code>X</code> 不可变，如果一样，则 <code>X</code> 可变。</li>
<li>便捷方法：用 <code>hash(X)</code>，只要不报错，证明 <code>X</code> 可被哈希，即不可变，反过来不可被哈希，即可变。</li>
</ul>
<p>1）id(x) 判断依据：</p>
<p>不可变类型，变量重新赋值，id 内存地址会变。（给多个变量赋相同的值，整型、布尔型、比较短的字符串指向同个内存地址；浮点型、长字符串指向不同内存地址。这方面涉及Python内存管理机制，Python对int类型和较短的字符串进行了缓存，无论声明多少个值相同的变量，实际上都指向同个内存地址。）</p>
<p>可变类型，变量重新赋值之后，id内存地址不变。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 浮点型变量重新赋值之后，id会变</span></span><br><span class="line">i = <span class="number">1.5</span></span><br><span class="line">print(id(i))</span><br><span class="line">i = i+<span class="number">1.2</span></span><br><span class="line">print(id(i))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对变量赋值相同的浮点型，id会变，即指向不同的内存地址</span></span><br><span class="line">a = <span class="number">1.5</span></span><br><span class="line">print(id(a))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对变量赋值相同的整型，id不变，即指向相同的内存地址</span></span><br><span class="line">b = <span class="number">1</span></span><br><span class="line">c = <span class="number">1</span></span><br><span class="line">print(id(b))</span><br><span class="line">print(id(c))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对变量赋值相同的布尔型，id不变，即指向相同的内存地址</span></span><br><span class="line">d = <span class="literal">True</span></span><br><span class="line">e = <span class="literal">True</span></span><br><span class="line">print(id(d))</span><br><span class="line">print(id(e))</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p>1933540566552<br>1933540566456<br>1933540566432<br>140718072828736<br>140718072828736<br>140718072306000<br>140718072306000</p>
<p>2）hash(x)判断依据：不可变类型能被哈希，可变类型不能被哈希。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(hash(<span class="string">'Name'</span>))  <span class="comment"># -9215951442099718823</span></span><br><span class="line"></span><br><span class="line">print(hash((<span class="number">1</span>, <span class="number">2</span>, <span class="string">'Python'</span>)))  <span class="comment"># 823362308207799471</span></span><br><span class="line"></span><br><span class="line">print(hash([<span class="number">1</span>, <span class="number">2</span>, <span class="string">'Python'</span>]))</span><br><span class="line"><span class="comment"># TypeError: unhashable type: 'list'</span></span><br><span class="line"></span><br><span class="line">print(hash(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;))</span><br><span class="line"><span class="comment"># TypeError: unhashable type: 'set'</span></span><br></pre></td></tr></table></figure>



<p>3.dict查找和插入的速度极快，不会随着key的增加而增加，但是需要占用大量的内存。</p>
<p>4.创建和访问字典</p>
<p>​    <strong>一个对象能不能作为字典的key，就取决于其有没有<strong>hash</strong>方法。所有python自带类型中，除了list、dict、set和内部至少带有上述三种类型之一的tuple之外，其余的对象都能当key。</strong></p>
<p>​    因此，字典的键key可以是任意不可变类型(数值、字符串、元组)，但需要注意的是tuple元组作为键时，其中不能以任何方式包含可变对象。</p>
<p>通过键值对的映射对象 初始化字典：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dic1 = dict([(<span class="string">'apple'</span>, <span class="number">4139</span>), (<span class="string">'peach'</span>, <span class="number">4127</span>), (<span class="string">'cherry'</span>, <span class="number">4098</span>)])</span><br><span class="line">print(dic1)  <span class="comment"># &#123;'cherry': 4098, 'apple': 4139, 'peach': 4127&#125;</span></span><br><span class="line"></span><br><span class="line">dic2 = dict(((<span class="string">'apple'</span>, <span class="number">4139</span>), (<span class="string">'peach'</span>, <span class="number">4127</span>), (<span class="string">'cherry'</span>, <span class="number">4098</span>)))</span><br><span class="line">print(dic2)  <span class="comment"># &#123;'peach': 4127, 'cherry': 4098, 'apple': 4139&#125;</span></span><br></pre></td></tr></table></figure>

<p>通过 名称=值对 创建字典：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意，此处name和age虽然作为地点的key时是加引号的字符串，但是在创建时不能加引号，加引号会报语法错误。</span></span><br><span class="line">dic = dict(name=<span class="string">'Tom'</span>, age=<span class="number">10</span>) </span><br><span class="line">print(dic)  <span class="comment"># &#123;'name': 'Tom', 'age': 10&#125;</span></span><br><span class="line">print(type(dic))  <span class="comment"># &lt;class 'dict'&gt;</span></span><br></pre></td></tr></table></figure>

<p>5.字典的内置方法</p>
<p>1）<code>dict.fromkeys(seq[, value])</code> 用于创建一个新字典，以序列 <code>seq</code> 中元素做字典的键，<code>value</code> 为字典所有键对应的初始值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">seq = (<span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'sex'</span>)</span><br><span class="line">dic1 = dict.fromkeys(seq)</span><br><span class="line">print(dic1)</span><br><span class="line"></span><br><span class="line">dic2 = dict.fromkeys(seq,<span class="number">10</span>)</span><br><span class="line">print(dic2)</span><br><span class="line"></span><br><span class="line">dic3 = dict.fromkeys(seq,(<span class="string">'小马'</span>, <span class="string">'8'</span>, <span class="string">'男'</span>))</span><br><span class="line">print(dic3)</span><br></pre></td></tr></table></figure>
<p>{‘name’: None, ‘age’: None, ‘sex’: None}<br>{‘name’: 10, ‘age’: 10, ‘sex’: 10}<br>{‘name’: (‘小马’, ‘8’, ‘男’), ‘age’: (‘小马’, ‘8’, ‘男’), ‘sex’: (‘小马’, ‘8’, ‘男’)}</p>
<p>2）<code>dict.keys()</code>返回一个可迭代对象，可以使用 <code>list()</code> 来转换为列表，列表为字典中的所有键。</p>
<p>3）<code>dict.values()</code>返回一个迭代器，可以使用 <code>list()</code> 来转换为列表，列表为字典中的所有值。</p>
<p>4）<code>dict.items()</code>以列表返回可遍历的(键值)元组数组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;<span class="string">'Name'</span>: <span class="string">'Lsgogroup'</span>, <span class="string">'Age'</span>: <span class="number">7</span>&#125;</span><br><span class="line">print(dic.items())</span><br><span class="line"><span class="comment"># dict_items([('Name', 'Lsgogroup'), ('Age', 7)])</span></span><br><span class="line"></span><br><span class="line">print(tuple(dic.items()))</span><br><span class="line"><span class="comment"># (('Name', 'Lsgogroup'), ('Age', 7))</span></span><br><span class="line"></span><br><span class="line">print(list(dic.items()))</span><br><span class="line"><span class="comment"># [('Name', 'Lsgogroup'), ('Age', 7)]</span></span><br></pre></td></tr></table></figure>

<p>5）<code>dict.get(key, default=None)</code> 返回指定键的值，如果值不在字典中返回默认值。</p>
<p>6）<code>dict.setdefault(key, default=None)</code> 和get()方法类似，返回指定键的值，如果键不存在字典中，将会添加键并将值设为默认值。</p>
<p>7）<code>key in dict</code> <code>in</code> 操作符用于判断键是否存在于字典中，如果键在字典 dict 里返回<code>true</code>，否则返回<code>false</code>。而<code>not in</code>操作符刚好相反，如果键在字典 dict 里返回<code>false</code>，否则返回<code>true</code>。</p>
<p>8）<code>dict.pop(key[,default])</code>删除字典给定键 <code>key</code> 所对应的值，返回值为被删除的值。<code>key</code> 值必须给出。若<code>key</code>不存在，必须设置默认值，返回 <code>default</code> 值。</p>
<p>9）<code>del dict[key]</code> 删除字典给定键 <code>key</code> 所对应的值。</p>
<p>10）<code>dict.popitem()</code>随机返回并删除字典中的一对键和值，如果字典已经为空，却调用了此方法，就报出KeyError异常。</p>
<p>11）<code>dict.clear()</code>用于删除字典内所有元素。</p>
<p>12）<code>dict.copy()</code>返回一个字典的浅复制。</p>
<p>直接赋值和copy的区别:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">dic1 = &#123;<span class="string">'user'</span>: <span class="string">'lsgogroup'</span>, <span class="string">'num'</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 引用对象</span></span><br><span class="line">dic2 = dic1  </span><br><span class="line"><span class="comment"># 浅拷贝父对象，子对象（[1,2,3]）不拷贝，还是引用</span></span><br><span class="line">dic3 = dic1.copy()  </span><br><span class="line"></span><br><span class="line">print(id(dic1))  <span class="comment"># 148635574728</span></span><br><span class="line">print(id(dic2))  <span class="comment"># 148635574728</span></span><br><span class="line">print(id(dic3))  <span class="comment"># 148635574344</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 data 数据</span></span><br><span class="line">dic1[<span class="string">'user'</span>] = <span class="string">'root'</span></span><br><span class="line">dic1[<span class="string">'num'</span>].remove(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line">print(dic1)  <span class="comment"># &#123;'user': 'root', 'num': [2, 3]&#125;</span></span><br><span class="line">print(dic2)  <span class="comment"># &#123;'user': 'root', 'num': [2, 3]&#125;</span></span><br><span class="line"><span class="comment"># 由于浅拷贝时，子对象不拷贝，列表变化时，dic3也变化</span></span><br><span class="line">print(dic3)  <span class="comment"># &#123;'user': 'runoob', 'num': [2, 3]&#125;</span></span><br></pre></td></tr></table></figure>

<p>13）<code>dict.update(dict2)</code>把字典参数 <code>dict2</code> 的 <code>key:value</code>对 更新到字典 <code>dict</code> 里。已有键的，则更新该键对应的值；没有键的，则添加该键值对。也是直接修改原字典。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;<span class="string">'Name'</span>: <span class="string">'Lsgogroup'</span>, <span class="string">'Age'</span>: <span class="number">7</span>&#125;</span><br><span class="line">dic2 = &#123;<span class="string">'Sex'</span>: <span class="string">'female'</span>, <span class="string">'Age'</span>: <span class="number">8</span>&#125;</span><br><span class="line">dic.update(dic2)</span><br><span class="line">print(dic)  </span><br><span class="line"><span class="comment"># &#123;'Sex': 'female', 'Age': 8, 'Name': 'Lsgogroup'&#125;</span></span><br></pre></td></tr></table></figure>

<p>6.练习题1</p>
<p>用程序解答下面的题目</p>
<ul>
<li>字典的长度是多少</li>
<li>请修改’java’ 这个key对应的value值为98</li>
<li>删除 c 这个key</li>
<li>增加一个key-value对，key值为 php, value是90</li>
<li>获取所有的key值，存储在列表里</li>
<li>获取所有的value值，存储在列表里</li>
<li>判断 javascript 是否在字典中</li>
<li>获得字典里所有value 的和</li>
<li>获取字典里最大的value</li>
<li>获取字典里最小的value</li>
<li>字典 dic1 = {‘php’: 97}， 将dic1的数据更新到dic中</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;</span><br><span class="line">    <span class="string">'python'</span>:<span class="number">95</span>,</span><br><span class="line">    <span class="string">'java'</span>:<span class="number">99</span>,</span><br><span class="line">    <span class="string">'c'</span>:<span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line">print(len(dic))</span><br><span class="line">dic[<span class="string">'java'</span>] = <span class="number">98</span></span><br><span class="line">print(dic)</span><br><span class="line">dic.pop(<span class="string">'c'</span>)</span><br><span class="line">print(dic)</span><br><span class="line">dic[<span class="string">'php'</span>] = <span class="number">90</span></span><br><span class="line">print(dic)</span><br><span class="line">keys = list(dic.keys())</span><br><span class="line">print(keys)</span><br><span class="line">values = list(dic.values())</span><br><span class="line">print(values)</span><br><span class="line">print(<span class="string">'javascript'</span> <span class="keyword">in</span> dic)</span><br><span class="line">print(sum(values))</span><br><span class="line">print(max(values))</span><br><span class="line">print(min(values))</span><br><span class="line">dic1 = &#123;<span class="string">'php'</span>:<span class="number">97</span>&#125;</span><br><span class="line">dic.update(dic1)</span><br><span class="line">print(dic)</span><br></pre></td></tr></table></figure>

<p>3<br>{‘python’: 95, ‘java’: 98, ‘c’: 100}<br>{‘python’: 95, ‘java’: 98}<br>{‘python’: 95, ‘java’: 98, ‘php’: 90}<br>[‘python’, ‘java’, ‘php’]<br>[95, 98, 90]<br>False<br>283<br>98<br>90<br>{‘python’: 95, ‘java’: 98, ‘php’: 97}</p>
<p>7.练习题2</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;</span><br><span class="line">    <span class="string">'python'</span>: &#123;<span class="string">'上学期'</span>: <span class="string">'90'</span>, <span class="string">'下学期'</span>: <span class="string">'95'</span>&#125;,</span><br><span class="line">    <span class="string">'c++'</span>: [<span class="string">'95'</span>, <span class="string">'96'</span>, <span class="string">'97'</span>],</span><br><span class="line">    <span class="string">'java'</span>: [&#123;<span class="string">'月考'</span>:<span class="string">'90'</span>, <span class="string">'期中考试'</span>: <span class="string">'94'</span>, <span class="string">'期末考试'</span>: <span class="string">'98'</span>&#125;]</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">transfer_score</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(data,dict):</span><br><span class="line">        <span class="keyword">for</span> key,value <span class="keyword">in</span> data.items():</span><br><span class="line">            data[key] = transfer_score(value)</span><br><span class="line">        <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> isinstance(data,list):</span><br><span class="line">        data_lst = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">            data_lst.append(transfer_score(i))</span><br><span class="line">        <span class="keyword">return</span> data_lst</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> isinstance(data,str):</span><br><span class="line">        <span class="keyword">return</span> int(data)</span><br><span class="line"></span><br><span class="line">data1 = transfer_score(data)</span><br><span class="line">print(data1)</span><br></pre></td></tr></table></figure>

<p>{‘python’: {‘上学期’: 90, ‘下学期’: 95}, ‘c++’: [95, 96, 97], ‘java’: [{‘月考’: 90, ‘期中考试’: 94, ‘期末考试’: 98}]}</p>
<p>8.遇到小问题</p>
<p>python字典更新时出现value为None的情况</p>
<p>如果，key对应的值是一个对象或者数据结构，该怎么去修改其对应的值呢，如：对应的值是一个列表</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person = &#123;<span class="string">'name'</span>: [<span class="string">'jack'</span>, <span class="string">'alis'</span>], <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">print</span> person</span><br><span class="line">person[<span class="string">'name'</span>] = person[<span class="string">'name'</span>].append(<span class="string">'hanjun'</span>) <span class="comment"># 修改列表，重新给person['name']赋值</span></span><br><span class="line"><span class="keyword">print</span> person</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p>{‘age’: 18, ‘name’: [‘jack’, ‘alis’]}<br>{‘age’: 18, ‘name’: None}</p>
<p>结果中name对应的值为None，这样就出现了细节上的bug，并且这个bug是不容易被发现的，看起来好像没什么错。</p>
<p>正确的做法应该是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">person = &#123;<span class="string">'name'</span>: [<span class="string">'jack'</span>, <span class="string">'alis'</span>], <span class="string">'age'</span>: <span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">print</span> person</span><br><span class="line">person[<span class="string">'name'</span>].append(<span class="string">'hanjun'</span>) <span class="comment"># 列表本身是可变类型，直接值修改字典元素值-列表，不需要再重新给person['name']赋值。</span></span><br><span class="line"><span class="keyword">print</span> person</span><br></pre></td></tr></table></figure>

<p>运行结果</p>
<p>{‘age’: 18, ‘name’: [‘jack’, ‘alis’]}<br>{‘age’: 18, ‘name’: [‘jack’, ‘alis’, ‘hanjun’]}</p>
<p>对字典的值直接添加，而不是用再赋值的方式，再赋值的方式为什么会错呢？</p>
<p>因为，列表list的append是一个方法，该方法直接修改原对象，返回值为None（没有返回值就会返回None），所以key为name的值就为None了。</p>
<p><strong>集合</strong></p>
<p>1.set是一组key的集合，key不能重复。跟在dict中一样，key只能是不可变类型。</p>
<p>2.创建集合</p>
<p>1）先创建集合对象，再用add()方法加入元素</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">basket = set()</span><br><span class="line">basket.add(<span class="string">'apple'</span>)</span><br><span class="line">basket.add(<span class="string">'banana'</span>)</span><br><span class="line">print(basket)  <span class="comment"># &#123;'banana', 'apple'&#125;</span></span><br></pre></td></tr></table></figure>

<p>2）直接把一堆元素用花括号括起来{元素1，元素2，…，元素n}。重复元素在set中会被自动过滤掉。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">basket = &#123;<span class="string">'apple'</span>, <span class="string">'orange'</span>, <span class="string">'apple'</span>, <span class="string">'pear'</span>, <span class="string">'orange'</span>, <span class="string">'banana'</span>&#125;</span><br><span class="line">print(basket)  <span class="comment"># &#123;'banana', 'apple', 'pear', 'orange'&#125;</span></span><br></pre></td></tr></table></figure>

<p> 3）使用set(value)工厂函数，把列表或元组转换成集合。（工厂函数基本上都是带有返回对象的，而这些返回对象则是通过调用一种或者多种类来创建的对象。工厂函数看上去有点像函数，实质上他们是类，当你调用它们时，实际上是生成的该类型的一个实例，就像工厂生产货物一样。）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">a = set(<span class="string">'abracadabra'</span>)</span><br><span class="line">print(a)  </span><br><span class="line"><span class="comment"># &#123;'r', 'b', 'd', 'c', 'a'&#125;</span></span><br><span class="line"></span><br><span class="line">b = set((<span class="string">"Google"</span>, <span class="string">"Lsgogroup"</span>, <span class="string">"Taobao"</span>, <span class="string">"Taobao"</span>))</span><br><span class="line">print(b)  </span><br><span class="line"><span class="comment"># &#123;'Taobao', 'Lsgogroup', 'Google'&#125;</span></span><br><span class="line"></span><br><span class="line">c = set([<span class="string">"Google"</span>, <span class="string">"Lsgogroup"</span>, <span class="string">"Taobao"</span>, <span class="string">"Google"</span>])</span><br><span class="line">print(c)  </span><br><span class="line"><span class="comment"># &#123;'Taobao', 'Lsgogroup', 'Google'&#125;</span></span><br></pre></td></tr></table></figure>

<p>3.集合的两个特点：无序和唯一。由于set存储的是无序集合，所以我们不可以为集合创建索引或执行切片操作，也没有键(keys)方法可以用来获取集合中元素的值，但是可以判断一个元素是否在集合中。</p>
<p>4.集合的内置方法</p>
<p>1）<code>set.add(elmnt)</code>用于给集合添加元素，如果添加的元素在集合中已存在，则不执行任何操作。</p>
<p>2）<code>set.update(set)</code>用于修改当前集合，可以添加新的元素或集合到当前集合中，如果添加的元素在集合中已存在，则该元素只会出现一次，重复的会忽略。</p>
<p>3）<code>set.remove(item)</code> 用于移除集合中的指定元素。如果元素不存在，则会发生错误。</p>
<p>4）<code>set.discard(value)</code> 用于移除指定的集合元素。<code>remove()</code> 方法在移除一个不存在的元素时会发生错误，而 <code>discard()</code> 方法不会。</p>
<p>5）<code>set.pop()</code> 用于随机移除一个元素。</p>
<p>6）<code>set.intersection(set1, set2)</code> 返回两个集合的交集。</p>
<p>7）<code>set1 &amp; set2</code> 返回两个集合的交集。</p>
<p>8）<code>set.intersection_update(set1, set2)</code> 交集，在原始的集合上移除不重叠的元素。</p>
<p>9）<code>set.union(set1, set2)</code> 返回两个集合的并集。</p>
<p>10）<code>set1 | set2</code> 返回两个集合的并集。</p>
<p>11）<code>set.difference(set1)</code> 返回集合的差集。set有，set1没有的。=  set-set1</p>
<p>12）<code>set1 - set2</code> 返回集合的差集。</p>
<p>13）<code>set.difference_update(set1)</code> 集合的差集，直接在原来的集合中移除元素，没有返回值。</p>
<p>14）<code>set.symmetric_difference(set1)</code>返回集合的异或。去掉set和set1中都有的元素。=set^set1</p>
<p>15）<code>set1 ^ set2</code> 返回集合的异或。</p>
<p>16）<code>set.symmetric_difference_update(set1)</code>移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。没有返回值，直接更新原集合set。</p>
<p>17）<code>set.issubset(set1)</code>判断集合是不是被其他集合包含，如果是则返回 True，否则返回 False。</p>
<p>​        =  set &lt;= set1</p>
<p>18）<code>set1 &lt;= set2</code> 判断集合是不是被其他集合包含，如果是则返回 True，否则返回 False。</p>
<p>19）<code>set.issuperset(set1)</code>用于判断集合是不是包含其他集合，如果是则返回 True，否则返回 False。  =  set&gt;= set1</p>
<p>20）<code>set1 &gt;= set2</code> 判断集合是不是包含其他集合，如果是则返回 True，否则返回 False。</p>
<p>21）<code>set.isdisjoint(set)</code> 用于判断两个集合是不是不相交，如果是返回 True，否则返回 False。</p>
<p>5.不可变集合</p>
<p>frozenset，不能增加或删除元素。仍然可以进行集合操作，只是不能用带有update的方法。</p>
<p><code>frozenset([iterable])</code> 返回一个冻结的集合，冻结后集合不能再添加或删除任何元素。</p>
<p>6.练习题</p>
<p>1）怎么表示只包含⼀个数字1的元组。</p>
<p>a = (1,)</p>
<p>2）创建一个空集合，增加 {‘x’,‘y’,‘z’} 三个元素。</p>
<p>s = set()<br>s.add(‘x’)<br>s.add(‘y’)<br>s.add(‘z’)</p>
<p>3）列表[‘A’, ‘B’, ‘A’, ‘B’]去重。</p>
<p>l = [‘A’, ‘B’, ‘A’, ‘B’]<br>l = list(set(l))<br>print(l)    # [‘A’, ‘B’]</p>
<p>4）求两个集合{6, 7, 8}，{7, 8, 9}中不重复的元素（差集指的是两个集合交集外的部分）。</p>
<p>a = {6, 7, 8}<br>b = {7, 8, 9}<br>c = a^b</p>
<p>print(c)     # {9, 6}</p>
<p>5）求{‘A’, ‘B’, ‘C’}中元素在 {‘B’, ‘C’, ‘D’}中出现的次数。</p>
<p>a = {‘A’, ‘B’, ‘C’}<br>b = {‘B’, ‘C’, ‘D’,’B’}<br>c = a&amp;b<br>n = len(c)<br>print(c)    #{‘C’, ‘B’}<br>print(n)     # 2</p>
<p><strong>序列</strong></p>
<p>1.针对序列的内置函数</p>
<p>1）<code>list(sub)</code> 把一个可迭代对象转换为列表。</p>
<p>2）<code>tuple(sub)</code> 把一个可迭代对象转换为元组。</p>
<p>3）<code>str(obj)</code> 把obj对象转换为字符串</p>
<p>4）<code>len(s)</code> 返回对象（字符、列表、元组等）长度或元素个数。</p>
<p>5）<code>max(sub)</code>返回序列或者参数集合中的最大值</p>
<p>6）<code>min(sub)</code>返回序列或参数集合中的最小值</p>
<p>7）<code>sum(iterable[, start=0])</code> 返回序列<code>iterable</code>与可选参数<code>start</code>的总和。</p>
<p>8）<code>sorted(iterable, key=None, reverse=False)</code>对所有可迭代的对象进行排序操作。key为主要用来进行比较的元素，只有一个参数。reverse为排序规则，reverse=True降序，reverse=False升序（默认）。return返回重新排序的列表。</p>
<p>9）<code>reversed(seq)</code> 函数返回一个反转的迭代器。seq可以是tuple，string，list或range。返回的是一个reversed类型的对象，一般转为list使用。</p>
<p>10）enumerate(sequence, [start=0])。start参数为指定索引从start开始算。</p>
<p>11）zip(iter1 [,iter2 […]])。用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的对象。如果各个迭代器的元素个数不一致，则返回列表长度与最短的对象相同。</p>
<p>*zip()函数是zip()函数的逆过程，将zip对象变成原先组合前的数据。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">c = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line">zipped = zip(a, b)</span><br><span class="line">print(zipped)  <span class="comment"># &lt;zip object at 0x000000C5D89EDD88&gt;</span></span><br><span class="line">print(list(zipped))  <span class="comment"># [(1, 4), (2, 5), (3, 6)]</span></span><br><span class="line">zipped = zip(a, c)</span><br><span class="line">print(list(zipped))  <span class="comment"># [(1, 4), (2, 5), (3, 6)]</span></span><br><span class="line"></span><br><span class="line">a1, a2 = zip(*zip(a, b))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 变成原先组合前的数据</span></span><br><span class="line"></span><br><span class="line">print(*zip(a, b))   <span class="comment"># (1, 4) (2, 5) (3, 6)</span></span><br><span class="line">print(list(a1))  <span class="comment"># [1, 2, 3]</span></span><br><span class="line">print(list(a2))  <span class="comment"># [4, 5, 6]</span></span><br></pre></td></tr></table></figure>


<p>2.练习题</p>
<p>1）怎么找出序列中的最⼤、⼩值？</p>
<p>max()</p>
<p>2）sort() 和 sorted() 区别</p>
<p>sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。</p>
<p>list 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。</p>
<p>3）怎么快速求 1 到 100 所有整数相加之和？</p>
<p>sum([i for i in range(1,101)])</p>
<p>4）求列表 [2,3,4,5] 中每个元素的立方根。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">b = []</span><br><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> enumerate(a):</span><br><span class="line">    x = pow(v,<span class="number">1</span>/<span class="number">3</span>)</span><br><span class="line">    b.append(x)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure>
<p>[1.2599210498948732, 1.4422495703074083, 1.5874010519681994, 1.7099759466766968]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">s = [item <span class="keyword">for</span> item <span class="keyword">in</span> map(<span class="keyword">lambda</span> x:pow(x,<span class="number">1</span>/<span class="number">3</span>),a)]</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>
<p>[1.2599210498948732, 1.4422495703074083, 1.5874010519681994, 1.7099759466766968]</p>
<p>5）将[‘x’,‘y’,‘z’] 和 [1,2,3] 转成 [(‘x’,1),(‘y’,2),(‘z’,3)] 的形式。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>]</span><br><span class="line">b = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">c = zip(a,b)</span><br><span class="line">print(list(c))</span><br></pre></td></tr></table></figure>
<p>[(‘x’, 1), (‘y’, 2), (‘z’, 3)]</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/31/Python-Task05/" data-id="ckddxsxa20005twwc3h5kbizr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-NLP-Task04" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/27/NLP-Task04/" class="article-date">
  <time datetime="2020-07-27T15:33:02.000Z" itemprop="datePublished">2020-07-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/27/NLP-Task04/">NLP-Task04</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="零基础入门NLP-新闻文本分类-Task04"><a href="#零基础入门NLP-新闻文本分类-Task04" class="headerlink" title="零基础入门NLP - 新闻文本分类-Task04"></a>零基础入门NLP - 新闻文本分类-Task04</h1><h2 id="Task04-基于深度学习的文本分类1"><a href="#Task04-基于深度学习的文本分类1" class="headerlink" title="Task04:基于深度学习的文本分类1"></a>Task04:基于深度学习的文本分类1</h2><ol>
<li>FastText</li>
</ol>
<p>1)简介</p>
<p>fastText是一个快速文本分类算法，与基于神经网络的分类算法相比有两大优点：<br>1、fastText在保持高精度的情况下加快了训练速度和测试速度<br>2、fastText不需要预训练好的词向量，fastText会自己训练词向量<br>3、fastText两个重要的优化：Hierarchical Softmax、N-gram<br>2)模型架构</p>
<p>fastText模型架构和word2vec的CBOW模型架构非常相似。下面是fastText模型架构图：</p>
<p><img src="https://pic1.zhimg.com/80/v2-7f38f23e98ee89d21fd16e34d5f07d69_1440w.jpg" alt="img"></p>
<p>注意：此架构图没有展示词向量的训练过程。可以看到，和CBOW一样，fastText模型也只有三层：输入层、隐含层、输出层（Hierarchical Softmax），输入都是多个经向量表示的单词，输出都是一个特定的target，隐含层都是对多个词向量的叠加平均。不同的是，CBOW的输入是目标单词的上下文，fastText的输入是多个单词及其n-gram特征，这些特征用来表示单个文档；CBOW的输入单词被onehot编码过，fastText的输入特征是被embedding过；CBOW的输出是目标词汇，fastText的输出是文档对应的类标。</p>
<p>3）API</p>
<p><strong>train_unsupervised 参数 用来训练词向量模型</strong></p>
<p><strong><em>input</em></strong> :训练文件路径<br><strong><em>model</em></strong> :无监督训练使用的模型 {cbow 和 skip-gram} 默认为skip-gram<br><strong><em>lr</em></strong> :学习率 默认为0.05<br><strong><em>dim</em></strong> : 词向量维度 默认为100<br><strong><em>ws</em></strong> :（windows size） 窗口大小 默认为5<br><strong><em>epoch</em></strong> : 默认训练五轮<br><strong><em>minCount</em></strong> : 最小词数 默认为5 当数据集略小要记得调整<br><strong><em>minCountLabel</em></strong> :=0 因为是无监督。<br><strong><em>minn</em></strong> :最小char级别的3-gram（subword）<br><strong><em>maxn</em></strong> :最大char级别的6-gram （subword）<br><strong><em>neg</em></strong> :负例采样个数 默认为5<br><strong><em>wordNgrams</em></strong> :最大的词n-gram长度 默认为1<br><strong><em>loss</em></strong> :损失函数 {ns,hs,softmax,ova} 默认是ns 负采样 ， hs 是分层softmax<br><strong><em>bucket</em></strong> : 桶数默认为2000000<br><strong><em>thread</em></strong>：cpu线程数 默认为12<br><strong><em>lrUpdateRate</em></strong>：学习率更新，默认为100<br><strong><em>t</em></strong>：负采样阈值 默认0.0001<br><strong><em>verbose</em></strong>：=2</p>
<hr>
<p><strong>train_supervised 参数 用来训练分类模型</strong> 没有model参数√</p>
<p><strong><em>input</em></strong> :训练文件路径<br><strong><em>lr</em></strong> :学习率 默认为<strong>0.1</strong> √<br><strong><em>dim</em></strong> : 词向量维度 默认为100<br><strong><em>ws</em></strong> :（windows size） 窗口大小 默认为5<br><strong><em>minCount</em></strong> : 最小词数 默认为<strong>1</strong>√<br><strong><em>minCountLabel</em></strong> :=<strong>1</strong> √ 最小标签数<br><strong><em>minn</em></strong> :=<strong>0</strong>√<br><strong><em>maxn</em></strong> :=<strong>0</strong>√<br><strong><em>neg</em></strong> :负例采样个数 默认为5<br><strong><em>wordNgrams</em></strong> :最大的词n-gram长度 默认为1<br><strong><em>loss</em></strong> :损失函数 {ns,hs,softmax,ova} 默认是<strong>softmax</strong>√<br><strong><em>bucket</em></strong> : 桶数默认为2000000<br><strong><em>thread</em></strong>：cpu线程数 默认为12<br><strong><em>lrUpdateRate</em></strong>：学习率更新，默认为100<br><strong><em>t</em></strong>：负采样阈值 默认0.0001<br><strong><em>label</em></strong> :标签前缀 默认 ‘_ <em>label</em> _’√<br><strong><em>verbose</em></strong>：=2 控制打印输出 2显示每个epoch 1显示最后一个epoch<br><strong><em>pretrainedVectors</em></strong>:用于监督学习的预训练词向量（.vec文件），给出路径 ，默认为‘ ’</p>
<p>2.基于FastText的文本分类</p>
<ul>
<li>pip安装</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install fasttext</span><br></pre></td></tr></table></figure>

<ul>
<li>分类模型</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> f1_score</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转换为FastText需要的格式</span></span><br><span class="line"><span class="comment"># pandas读取训练集数据</span></span><br><span class="line">train_df = pd.read_csv(<span class="string">'D:/PycharmProjects/tianchiLab/input/train_set.csv'</span>, sep=<span class="string">'\t'</span>, nrows=<span class="number">30000</span>)</span><br><span class="line">print(train_df.head())</span><br><span class="line"><span class="comment"># 拼接'__label__'和label</span></span><br><span class="line">train_df[<span class="string">'label_ft'</span>] = <span class="string">'__label__'</span> + train_df[<span class="string">'label'</span>].astype(str)</span><br><span class="line"><span class="comment"># 取前面25000条数据作为训练集</span></span><br><span class="line">train_df[[<span class="string">'text'</span>,<span class="string">'label_ft'</span>]].iloc[:<span class="number">-5000</span>].to_csv(<span class="string">'train.csv'</span>, index=<span class="literal">None</span>, header=<span class="literal">None</span>, sep=<span class="string">'\t'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> fasttext</span><br><span class="line"><span class="comment"># wordNgrams代表将一个单词和其后面的词组合在一起，如FastText原理介绍中输入层使用的例子。</span></span><br><span class="line"><span class="comment"># lr :学习率 默认为0.1。wordNgrams :最大的词n-gram长度 默认为1。verbose：=2 控制打印输出 2显示每个epoch 1显示最后一个epoch。</span></span><br><span class="line"><span class="comment"># minCount : 最小词数 默认为1。loss :损失函数 &#123;ns,hs,softmax,ova&#125; 默认是softmax。epoch : 训练轮数，默认训练五轮。</span></span><br><span class="line">model = fasttext.train_supervised(<span class="string">'train.csv'</span>, lr=<span class="number">0.5</span>, wordNgrams=<span class="number">2</span>, </span><br><span class="line">                                  verbose=<span class="number">2</span>, minCount=<span class="number">1</span>, epoch=<span class="number">25</span>, loss=<span class="string">"hs"</span>)</span><br><span class="line"><span class="comment"># 后5000条做测试集</span></span><br><span class="line">val_pred = [model.predict(x)[<span class="number">0</span>][<span class="number">0</span>].split(<span class="string">'__'</span>)[<span class="number">-1</span>] <span class="keyword">for</span> x <span class="keyword">in</span> train_df.iloc[<span class="number">-5000</span>:][<span class="string">'text'</span>]]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印f1</span></span><br><span class="line">print(f1_score(train_df[<span class="string">'label'</span>].values[<span class="number">-5000</span>:].astype(str), val_pred, average=<span class="string">'macro'</span>))</span><br></pre></td></tr></table></figure>

<p>0.87332537480972</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/27/NLP-Task04/" data-id="ckddxsxa00003twwc8ojz6ioz" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Python-Task04" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/27/Python-Task04/" class="article-date">
  <time datetime="2020-07-27T07:59:12.000Z" itemprop="datePublished">2020-07-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/27/Python-Task04/">Python-Task04</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Python编程基础-Task04"><a href="#Python编程基础-Task04" class="headerlink" title="Python编程基础-Task04"></a>Python编程基础-Task04</h1><h2 id="Task-4-列表、元组、字符串"><a href="#Task-4-列表、元组、字符串" class="headerlink" title="Task 4:列表、元组、字符串"></a>Task 4:列表、元组、字符串</h2><p><strong>列表</strong></p>
<p>1.列表通过 matrix = [array] * 3创建时，只是创建3个指向array的引用，所以一旦array改变，matrix中3个list也会随之改变。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>lists = [[]] * <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lists</span><br><span class="line">[[], [], []]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lists[<span class="number">0</span>].append(<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>lists</span><br><span class="line">[[<span class="number">3</span>], [<span class="number">3</span>], [<span class="number">3</span>]]</span><br></pre></td></tr></table></figure>

<p>创建二维数组的方式：</p>
<p>方法1 直接定义</p>
<p>matrix = [[0,0,0]， [0,0,0]， [0,0,0]]</p>
<p>方法2 间接定义</p>
<p>matrix = [[0 for i in range(3)] for i in range(3)]</p>
<p>2.<code>remove</code> 和 <code>pop</code> 都可以删除元素，前者是指定具体要删除的元素，后者是指定一个索引，并返回该元素的值。</p>
<p><code>del var1[, var2 ……]</code> 删除单个或多个对象。</p>
<p>如果你要从列表中删除一个元素，且不再以任何方式使用它，就使用<code>del</code>语句；如果你要在删除元素后还能继续使用它，就使用方法<code>pop()</code>。</p>
<p>3.列表的常用操作符</p>
<p>等号==，只有成员、成员未知都相同时才返回True。</p>
<p>连接操作符+，extend() 作用相同。</p>
<p>重复操作符*。</p>
<p>成员关系操作符 in、not in。</p>
<p>4.练习题1</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 练习题1</span></span><br><span class="line">lst = [<span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">9</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在列表的末尾增加元素15</span></span><br><span class="line"></span><br><span class="line">lst.append(<span class="number">15</span>)</span><br><span class="line">print(lst)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在列表的中间位置插入元素20</span></span><br><span class="line"></span><br><span class="line">lst.insert(len(lst)//<span class="number">2</span>,<span class="number">20</span>)</span><br><span class="line">print(lst)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将列表[2, 5, 6]合并到lst中</span></span><br><span class="line"></span><br><span class="line">lst.extend([<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line">print(lst)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除列表中索引为3的元素</span></span><br><span class="line"></span><br><span class="line">lst.pop(<span class="number">3</span>)</span><br><span class="line">print(lst)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻转列表里的所有元素</span></span><br><span class="line"></span><br><span class="line">rslt = lst[::<span class="number">-1</span>]</span><br><span class="line">print(rslt)</span><br><span class="line">lst.reverse()</span><br><span class="line">print(lst)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对列表里的元素进行排序，从小到大一次，从大到小一次</span></span><br><span class="line"></span><br><span class="line">lst.sort()</span><br><span class="line">print(lst)</span><br><span class="line"></span><br><span class="line">lst.sort(reverse = <span class="literal">True</span>)</span><br><span class="line">print(lst)</span><br></pre></td></tr></table></figure>

<p>[2, 5, 6, 7, 8, 9, 2, 9, 9, 15]<br>[2, 5, 6, 7, 8, 20, 9, 2, 9, 9, 15]<br>[2, 5, 6, 7, 8, 20, 9, 2, 9, 9, 15, 2, 5, 6]<br>[2, 5, 6, 8, 20, 9, 2, 9, 9, 15, 2, 5, 6]<br>[6, 5, 2, 15, 9, 9, 2, 9, 20, 8, 6, 5, 2]<br>[6, 5, 2, 15, 9, 9, 2, 9, 20, 8, 6, 5, 2]<br>[2, 2, 2, 5, 5, 6, 6, 8, 9, 9, 9, 15, 20]<br>[20, 15, 9, 9, 9, 8, 6, 6, 5, 5, 2, 2, 2]</p>
<p>5.练习题2</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 练习题2</span></span><br><span class="line"><span class="comment"># 方法1</span></span><br><span class="line"></span><br><span class="line">lst = [<span class="number">1</span>,[<span class="number">4</span>,<span class="number">6</span>],<span class="literal">True</span>]</span><br><span class="line">lst[<span class="number">0</span>] = lst[<span class="number">0</span>]*<span class="number">2</span></span><br><span class="line">lst[<span class="number">1</span>] = [i*<span class="number">2</span> <span class="keyword">for</span> i <span class="keyword">in</span> lst[<span class="number">1</span>]]</span><br><span class="line">print(lst)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方法2</span></span><br><span class="line"></span><br><span class="line">lst = [<span class="number">1</span>,[<span class="number">4</span>,<span class="number">6</span>],<span class="literal">True</span>,&#123;<span class="number">1</span>&#125;]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double_num</span><span class="params">(lst)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i,x <span class="keyword">in</span> enumerate(lst):</span><br><span class="line">        <span class="keyword">if</span> isinstance(x,bool):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">elif</span> isinstance(x,(int,float)):</span><br><span class="line">            lst[i] *= <span class="number">2</span></span><br><span class="line">        <span class="keyword">elif</span> isinstance(x, list):</span><br><span class="line">            double_num(x)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"lst[%d]是："</span>%i, lst[i])</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">return</span> lst</span><br><span class="line"></span><br><span class="line">rslt = double_num(lst)</span><br><span class="line">print(rslt)</span><br></pre></td></tr></table></figure>

<p>[2, [8, 12], True]<br>lst[3]是： {1}<br>[2, [8, 12], True, {1}]</p>
<p>6.练习题3</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 练习题3</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">peakIndexInMountainArray</span><span class="params">(A)</span>:</span></span><br><span class="line"><span class="comment">#     for i in range(1,len(A)-1):</span></span><br><span class="line"><span class="comment">#         all() 函数用于判断给定的可迭代参数 iterable 中的所有元素是否都为 TRUE，如果是返回 True，否则返回 False。</span></span><br><span class="line"><span class="comment">#         if all(A[n]&lt;A[n+1] for n in range(i)) and all(A[n]&gt;A[n+1] for n in range(i,len(A)-2)):</span></span><br><span class="line"><span class="comment">#             return i</span></span><br><span class="line"><span class="comment">#         else:</span></span><br><span class="line"><span class="comment">#             continue</span></span><br><span class="line">    <span class="comment"># 因为所给数组是满足条件的数组，山峰一定是数组的最大值</span></span><br><span class="line">    <span class="keyword">return</span> A.index(max(A))</span><br><span class="line"></span><br><span class="line">A = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">0</span>]</span><br><span class="line">print(peakIndexInMountainArray(A))</span><br></pre></td></tr></table></figure>

<p>3</p>
<p><strong>元组</strong></p>
<p>1.元组与列表</p>
<p>不同：</p>
<ul>
<li>tuple被创建后就不能对其进行修改，类似字符串。列表可以修改。</li>
<li>元组使用小括号，列表使用方括号。</li>
</ul>
<p>相同：</p>
<ul>
<li>都是序列类型的容器对象，可以存放任何类型的数据，支持迭代。</li>
<li>用整数来进行索引 (indexing) 和切片 (slicing)。</li>
<li>tuple 一般用于存储异构(heterogeneous)数据，当做没有字段名的记录来用，比如用 tuple 来记录一个人的身高、体重、年龄。列表一般用于存储同构数据(homogenous)，同构数据就是具有相同意义的数据，比如都是字符串类型。</li>
</ul>
<p>namedtuple：因为 tuple 作为没有名字的记录来使用在某些场景有一定的局限性，所以又有了一个 namedtuple 类型的存在，namedtuple 可以指定字段名，用来当做一种轻量级的类来使用。namedtuple能够用来创建类似于元组的数据类型，除了能够用索引来访问数据，能够迭代，还能够方便的通过属性名来访问数据。</p>
<p>2.元组虽然有不可修改的性质，但是只要元组中的元素（比如列表）可更改 (mutable)，那么我们可以直接更改其元素，注意这跟赋值其元素不同。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">t1 = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">print(t1)  <span class="comment"># (1, 2, 3, [4, 5, 6])</span></span><br><span class="line"></span><br><span class="line">t1[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">9</span></span><br><span class="line">print(t1)  <span class="comment"># (1, 2, 3, [9, 5, 6])</span></span><br></pre></td></tr></table></figure>

<p>3.解压元组，用通配符[*]匹配解压元组的元素。[ *rest]   [ *_]</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span></span><br><span class="line">a, b, *rest, c = t</span><br><span class="line">print(a, b, c)  <span class="comment"># 1 2 5</span></span><br><span class="line">print(rest)  <span class="comment"># [3, 4]</span></span><br><span class="line"></span><br><span class="line">a, b, *_ = t</span><br><span class="line">print(a, b)  <span class="comment"># 1 2</span></span><br></pre></td></tr></table></figure>

<p>4.练习题1</p>
<p>(1,2,1,2)</p>
<p>(1,1)</p>
<p>2</p>
<p>5.练习题2</p>
<p>a, b = 1, 2  是拆包</p>
<p>拆包: 对于函数中的多个返回数据, 去掉元组, 列表 或者字典 直接获取里面数据的过程.</p>
<p><strong>字符串</strong></p>
<p>1.字符串中的常用内置方法：</p>
<p>capitalize()将字符串的第一个字符转换为大写。</p>
<p>lower()转换字符串中所有大写字符为小写。</p>
<p>upper()转换字符串中所有小写字符为大写。</p>
<p>swapcase()将字符串中大写转换为小写，小写转换为大写。</p>
<p>count(str,beg=0,end=len(string))返回str在string里面出现的次数，如果beg或者end指定则返回指定范围内str出现的次数。<strong>大小写敏感。</strong></p>
<p>endswith(suffix,beg=0,end=len(string))检查字符串是否以指定字符串suffix结束，如果是，返回True，否则返回False。如果beg或者end指定值，则在指定范围内检查。大小写敏感。</p>
<p>startswith(substr,beg=0,end=len(string))检查字符串是否以指定字符串substr结束，如果是，返回True，否则返回False。如果beg或者end指定值，则在指定范围内检查。大小写敏感。</p>
<p>find(str,beg=0,end=len(string))检查str是否包含在字符串中，如果指定范围beg和end，则检查是否包含在指定范围内，如果包含，返回开始的索引值，否则返回-1。大小写敏感。</p>
<p>rfind(str,beg=0,end=len(string))类似于find()函数，不过是从右边开始查找。但匹配str时，仍是按从左到右匹配。</p>
<p>isnumeric()如果字符串只包含数字字符，则返回True，否则返回False。</p>
<p>ljust(width[,fillchar])返回一个原字符串左对齐，并使用fillchar(默认空格)填充至长度width的新字符串。</p>
<p>rjust(width[,fillchar])返回一个原字符串右对齐，并使用fillchar(默认空格)填充至长度width的新字符串。</p>
<p>lstrip([chars])截掉字符串左边的空格或指定字符。</p>
<p>rstrip([chars])截掉字符串右边的空格或指定字符。</p>
<p>strip([chars])在字符串上执行lstrip([chars])和rstrip([chars])，即截掉右边和左边的空格或指定字符。</p>
<p>partition(sub)找到子字符串sub，把字符串分为一个三元组(pre_sub,sub,fol_sub)，如果字符串不包含sub则返回(‘原字符串’,’’,’’)。</p>
<p>rpartition(sub)类似于partition(sub)方法，不过是从右边开始查找。但匹配str时，仍是按从左到右匹配。</p>
<p>replace(old,new[,max])把字符串中的old替换成new，如果max指定，则替换不超过max次。</p>
<p>split(str=””,num)不带参数默认是以空格为分隔符切片字符串，如果num参数有设置，则仅分隔num个子字符串，返回切片后的子字符串拼接的列表。</p>
<p>splitlines([keepends])按照行(‘\r’,’\r\n’,’\n’)分隔，返回一个包含各行作为元素的列表，如果参数keepends为False，不包含换行符，如果为True，则保留换行符。</p>
<p>maketrans(intab,outtab)创建字符映射的转换表，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串，表示转换的目标。</p>
<p>translate(table,deletechars=””)根据参数table给出的表，转换字符串的字符，要过滤掉的字符放到deletechars参数中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">str7 = <span class="string">'this is string example....wow!!!'</span></span><br><span class="line">intab = <span class="string">'aeiou'</span></span><br><span class="line">outtab = <span class="string">'12345'</span></span><br><span class="line">transtab = str7.maketrans(intab, outtab)</span><br><span class="line">print(transtab)</span><br><span class="line">print(str7.translate(transtab))</span><br></pre></td></tr></table></figure>
<p>{97: 49, 101: 50, 105: 51, 111: 52, 117: 53}<br>th3s 3s str3ng 2x1mpl2….w4w!!!</p>
<p>2.字符串格式化符号</p>
<p>格式化操作符辅助指令  </p>
<p>m.n：m是显示的最小宽度，默认右对齐左侧补空格，n是小数点后的位数。- ：用作左对齐，右侧补空格。+：在正数前面显示加号。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'%5.1f'</span> % <span class="number">27.658</span>)  <span class="comment"># ' 27.7'</span></span><br><span class="line">print(<span class="string">'%.2e'</span> % <span class="number">27.658</span>)  <span class="comment"># 2.77e+01</span></span><br><span class="line">print(<span class="string">'%10d'</span> % <span class="number">10</span>)  <span class="comment"># '        10'</span></span><br><span class="line">print(<span class="string">'%-10d'</span> % <span class="number">10</span>)  <span class="comment"># '10        '</span></span><br><span class="line">print(<span class="string">'%+d'</span> % <span class="number">10</span>)  <span class="comment"># +10</span></span><br></pre></td></tr></table></figure>

<p>3.练习题1</p>
<p>批量替换字符串中的元素  replace(old,new)</p>
<p>按空格进行拆分 split(‘ ‘)</p>
<p>去除字符串首位的空格 lstrip()</p>
<p>4.练习题2</p>
<p>实现函数isdigit， 判断字符串里是否只包含数字0~9。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isdigit</span><span class="params">(string)</span>:</span></span><br><span class="line">num = <span class="string">'0123456789'</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> string:</span><br><span class="line">    <span class="keyword">if</span> num.find(i)&lt;<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">print(isdigit(<span class="string">'123'</span>))</span><br></pre></td></tr></table></figure>

<p>True</p>
<p>5.练习题3</p>
<p>给定一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。你可以假设 <code>s</code> 的最大长度为 1000。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span><span class="params">(self, s: str)</span> -&gt; str:</span></span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/27/Python-Task04/" data-id="ckddxsxa50008twwc2y554k5h" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Python-Task03" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/24/Python-Task03/" class="article-date">
  <time datetime="2020-07-24T06:10:42.000Z" itemprop="datePublished">2020-07-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/24/Python-Task03/">Python-Task03</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Python编程基础-Task03"><a href="#Python编程基础-Task03" class="headerlink" title="Python编程基础-Task03"></a>Python编程基础-Task03</h1><h2 id="Task-3-异常处理"><a href="#Task-3-异常处理" class="headerlink" title="Task 3:异常处理"></a>Task 3:异常处理</h2><p>1.语法错误</p>
<p>Python 的语法错误或者称之为解析错。</p>
<p>2.异常</p>
<p>即便 Python 程序的语法是正确的，在运行它的时候，也有可能发生错误。运行期检测到的错误被称为异常。</p>
<p>3.异常处理</p>
<p>1）try-except语句</p>
<p>2）try-except Exception as e 语句。<strong>Exception匹配了所有异常，把异常名称赋给了e</strong>。当然这里不一定非得是e，你可以取任何的变量名，只是约定俗称这样写罢了。</p>
<p>3）try-except语句 多个except子句</p>
<p>4）try-except -else语句</p>
<p>5）try-except -finally语句。finaly的作用是，无论except是否捕捉到异常，finally后面的代码都会执行，try获取了资源，finally释放资源，保证了收尾工作。</p>
<p>6）with语句</p>
<p>with…语句相当于try-finally语句的简写，可以替代try-finally的功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with open(&#39;poem.txt&#39;) as f:</span><br><span class="line">	print(f.read())</span><br><span class="line">print(f.closed)</span><br></pre></td></tr></table></figure>

<p>表达式open(‘poem.txt’)返回是一个_io.TextIOWrapper 类型的变量赋给f。在with语句块中就可以使用这个变量操作文件。执行with这个结构之后，f会自动关闭，相当于自带了一个finally。</p>
<p>​    Try的工作原理是，当开始一个try语句后，python就在当前程序的上下文中作标记，这样当异常出现时就可以回到这里，try子句先执行，接下来会发生什么依赖于执行时是否出现异常。</p>
<ol>
<li>首先，执行 try 子句（在关键字 try 和关键字 except 之间的语句）。</li>
<li>如果当try后的语句执行时发生异常，那么 try 子句余下的部分将被忽略。python就跳回到try并执行第一个匹配该异常的except子句，异常处理完毕，控制流就通过整个try语句（除非在处理异常时又引发新的异常）。</li>
<li>如果在try后的语句里发生了异常，却没有匹配的except子句，异常将被递交到上层的try，或者到程序的最上层（这样将结束程序，并打印缺省的出错信息）。</li>
<li>如果在try子句执行时没有发生异常，忽略 except 子句，python将执行else语句后的语句（如果有else的话），然后控制流通过整个try语句。</li>
</ol>
<p>4.抛出异常</p>
<p>raise语句   raise [Exception [, args [, traceback]]]</p>
<p>使用<code>raise</code>语句抛出一个指定的异常。</p>
<p>raise 唯一的一个参数指定了要被抛出的异常。它必须是一个异常的实例或者是异常的类（也就是 Exception 的子类）。</p>
<p>如果你只想知道这是否抛出了一个异常，并不想去处理它，那么一个简单的 raise 语句就可以再次把它抛出。</p>
<p>5.用户自定义异常</p>
<p>可以通过创建一个新的异常类来拥有自己的异常。异常类继承自 Exception 类，可以直接继承，或者间接继承，例如:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, value)</span>:</span></span><br><span class="line">		self.value = value</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">		<span class="keyword">return</span> repr(self.value)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">	<span class="keyword">raise</span> MyError(<span class="number">2</span>*<span class="number">2</span>)</span><br><span class="line"><span class="keyword">except</span> MyError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">'My exception occurred, value:'</span>, e.value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># My exception occurred, value: 4</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">raise</span> MyError(<span class="string">'oops!'</span>)</span><br><span class="line"><span class="comment">#Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#File "&lt;stdin&gt;", line 1, **in** ?</span></span><br><span class="line"><span class="comment">#__main__.MyError: 'oops!'</span></span><br></pre></td></tr></table></figure>

<p>在这个例子中，类 Exception 默认的 <strong>init</strong>() 被覆盖。</p>
<p>6.总结如下：</p>
<p>1)except语句不是必须的，finally语句也不是必须的，但是二者必须要有一个，否则就没有try的意义了。</p>
<p>2)except语句可以有多个，Python会按except语句的顺序依次匹配你指定的异常，如果异常已经处理就不会再进入后面的except语句。也就是说最多只有一个分支被执行。</p>
<p>3)except语句可以以元组形式同时指定多个异常。</p>
<p>4)except语句后面如果不指定异常类型，则默认捕获所有异常，你可以通过logging或者sys模块获取当前异常。</p>
<p>5)如果要捕获异常后要重复抛出，请使用raise，后面不要带任何参数或信息。</p>
<p>6)不建议捕获并抛出同一个异常，请考虑重构你的代码。</p>
<p>7)不建议在不清楚逻辑的情况下捕获所有异常，有可能你隐藏了很严重的问题。</p>
<p>8)尽量使用内置的异常处理语句来 替换try/except语句，比如with语句，getattr()方法。</p>
<p>7.练习题：猜数字游戏</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">print(<span class="string">"猜测一个0到100之间的整数。"</span>)</span><br><span class="line">x = random.randint(<span class="number">0</span>, <span class="number">100</span>)</span><br><span class="line">i = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a = int(input(<span class="string">"第%d次猜，请输入一个整形数字:"</span> %i))</span><br><span class="line">        <span class="keyword">if</span> a &lt; x:</span><br><span class="line">            print(<span class="string">"太小"</span>)</span><br><span class="line">        <span class="keyword">elif</span> a &gt; x:</span><br><span class="line">            print(<span class="string">"太大"</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">"恭喜你猜到了这个数是"</span>, a)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        print(<span class="string">"输入无效"</span>)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        i += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>猜测一个0到100之间的整数。<br>第1次猜，请输入一个整形数字:5.5<br>输入无效<br>第2次猜，请输入一个整形数字:5<br>太小<br>第3次猜，请输入一个整形数字:50<br>太大<br>第4次猜，请输入一个整形数字:30<br>太大<br>第5次猜，请输入一个整形数字:20<br>太大<br>第6次猜，请输入一个整形数字:10<br>太小<br>第7次猜，请输入一个整形数字:15<br>太大<br>第8次猜，请输入一个整形数字:13<br>恭喜你猜到了这个数是 13</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/24/Python-Task03/" data-id="ckddxsxa40007twwc54m0cln2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-NLP-Task03" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/23/NLP-Task03/" class="article-date">
  <time datetime="2020-07-23T14:32:49.000Z" itemprop="datePublished">2020-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/23/NLP-Task03/">NLP-Task03</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="零基础入门NLP-新闻文本分类-Task03"><a href="#零基础入门NLP-新闻文本分类-Task03" class="headerlink" title="零基础入门NLP - 新闻文本分类-Task03"></a>零基础入门NLP - 新闻文本分类-Task03</h1><h2 id="Task03-基于机器学习的文本分类"><a href="#Task03-基于机器学习的文本分类" class="headerlink" title="Task03:基于机器学习的文本分类"></a>Task03:基于机器学习的文本分类</h2><ol>
<li>思路1：Count Vectors + RidgeClassifier</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> CountVectorizer</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> RidgeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> f1_score</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># pandas读取训练集数据</span></span><br><span class="line">train_df = pd.read_csv(<span class="string">'D:/PycharmProjects/tianchiLab/input/train_set.csv'</span>, sep=<span class="string">'\t'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#将文本中的词语转换为词频矩阵, 矩阵元素a[i][j] 表示j词在i文本下的词频</span></span><br><span class="line"><span class="comment"># vectorizer = CountVectorizer(max_feature=3000)</span></span><br><span class="line">vectorizer = CountVectorizer()</span><br><span class="line">train_test = vectorizer.fit_transform(train_df[<span class="string">'text'</span>])</span><br><span class="line"><span class="comment"># 调用岭回归分类器，用前10000条数据做训练</span></span><br><span class="line">clf = RidgeClassifier()</span><br><span class="line">clf.fit(train_test[:<span class="number">10000</span>], train_df[<span class="string">'label'</span>].values[:<span class="number">10000</span>])</span><br><span class="line"><span class="comment"># 10000条后面的数据做预测</span></span><br><span class="line">val_pred = clf.predict(train_test[<span class="number">10000</span>:])</span><br><span class="line"><span class="comment"># 计算f1分数</span></span><br><span class="line"><span class="comment"># average : string,[None, ‘binary’(default), ‘micro’, ‘macro’, ‘samples’, ‘weighted’]</span></span><br><span class="line"><span class="comment"># 这里需要注意，如果是二分类问题则选择参数‘binary’；如果考虑类别的不平衡性，需要计算类别的加权平均，则使用‘weighted’；如果不考虑类别的不平衡性，计算宏平均，则使用‘macro’。</span></span><br><span class="line">print(f1_score(train_df[<span class="string">'label'</span>].values[<span class="number">10000</span>:], val_pred, average=<span class="string">'macro'</span>))</span><br></pre></td></tr></table></figure>

<p>0.6605229808023886</p>
<p>2.思路2：TF-IDF + RidgeClassifier</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sklearn.feature_extraction.text <span class="keyword">import</span> TfidfVectorizer</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> RidgeClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> f1_score</span><br><span class="line"></span><br><span class="line"><span class="comment"># pandas读取训练集数据</span></span><br><span class="line">train_df = pd.read_csv(<span class="string">'D:/PycharmProjects/tianchiLab/input/train_set.csv'</span>, sep=<span class="string">'\t'</span>, nrows=<span class="number">15000</span>)</span><br><span class="line"><span class="comment"># 统计每个词语的tf-idf权值   </span></span><br><span class="line"><span class="comment"># ngram_range:要提取的n-gram的n-values的下限和上限范围，在min_n &lt;= n &lt;= max_n区间的n的全部值</span></span><br><span class="line">tfidf = TfidfVectorizer(max_df=<span class="number">0.8</span>, ngram_range=(<span class="number">1</span>,<span class="number">3</span>), max_features=<span class="number">3000</span>)</span><br><span class="line">train_test = tfidf.fit_transform(train_df[<span class="string">'text'</span>])</span><br><span class="line"><span class="comment"># 调用岭回归分类器，用前10000条数据做训练</span></span><br><span class="line">clf = RidgeClassifier()</span><br><span class="line">clf.fit(train_test[:<span class="number">10000</span>], train_df[<span class="string">'label'</span>].values[:<span class="number">10000</span>])</span><br><span class="line"><span class="comment"># 10000条后面的数据做预测</span></span><br><span class="line">val_pred = clf.predict(train_test[<span class="number">10000</span>:])</span><br><span class="line">print(f1_score(train_df[<span class="string">'label'</span>].values[<span class="number">10000</span>:], val_pred, average=<span class="string">'macro'</span>))</span><br></pre></td></tr></table></figure>

<p>0.8719</p>
<p>由此可见，TF-IDF效果更好。</p>
<p>3.思路3：尝试SVM、LR、XGBoost、LightGBM做分类器</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/23/NLP-Task03/" data-id="ckddxsx9t0000twwc3kjc9din" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Python-Task02" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/23/Python-Task02/" class="article-date">
  <time datetime="2020-07-23T08:05:01.000Z" itemprop="datePublished">2020-07-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/07/23/Python-Task02/">Python-Task02</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Python编程基础-Task02"><a href="#Python编程基础-Task02" class="headerlink" title="Python编程基础-Task02"></a>Python编程基础-Task02</h1><h2 id="Task-2-条件循环结构"><a href="#Task-2-条件循环结构" class="headerlink" title="Task 2: 条件循环结构"></a>Task 2: 条件循环结构</h2><p>1.assert关键词</p>
<p>Python assert（断言）用于判断一个表达式，在表达式条件为 false 的时候触发异常。</p>
<p>断言可以在条件不满足程序运行的情况下直接返回错误，而不必等待程序运行后出现崩溃的情况，例如我们的代码只能在 Linux 系统下运行，可以先判断当前系统是否符合条件。</p>
<p>语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert expression</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if not expression:</span><br><span class="line">    raise AssertionError</span><br></pre></td></tr></table></figure>

<p>assert 后面也可以紧跟参数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assert expression [, arguments]</span><br></pre></td></tr></table></figure>

<p>等价于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> expression:</span><br><span class="line">    <span class="keyword">raise</span> AssertionError(arguments)</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span> <span class="number">1</span>==<span class="number">2</span>, <span class="string">'1 不等于 2'</span></span><br></pre></td></tr></table></figure>
<p>Traceback (most recent call last):<br> File “<stdin>“, line 1, <strong>in</strong> <module><br>AssertionError: 1 不等于 2</p>
<p>2.enumerate()函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">enumerate(sequence, [start&#x3D;0])</span><br></pre></td></tr></table></figure>

<ul>
<li>sequence – 一个序列、迭代器或其他支持迭代对象。</li>
<li>start – 下标起始位置。</li>
<li>返回 enumerate(枚举) 对象</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">seasons = [<span class="string">'Spring'</span>, <span class="string">'Summer'</span>, <span class="string">'Fall'</span>, <span class="string">'Winter'</span>]</span><br><span class="line">lst = list(enumerate(seasons))</span><br><span class="line">print(lst)</span><br><span class="line"><span class="comment"># [(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]</span></span><br><span class="line">lst = list(enumerate(seasons, start=<span class="number">1</span>))  <span class="comment"># 下标从 1 开始</span></span><br><span class="line">print(lst)</span><br><span class="line"><span class="comment"># [(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]</span></span><br></pre></td></tr></table></figure>

<p>3.练习题1</p>
<p>编写一个Python程序来查找那些既可以被7整除又可以被5整除的数字，介于1500和2700之间。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1501</span>,<span class="number">2700</span>) <span class="keyword">if</span> i%<span class="number">5</span> == <span class="number">0</span> <span class="keyword">and</span> i%<span class="number">7</span> == <span class="number">0</span>]</span><br><span class="line">print(s)</span><br></pre></td></tr></table></figure>

<p>[1505, 1540, 1575, 1610, 1645, 1680, 1715, 1750, 1785, 1820, 1855, 1890, 1925, 1960, 1995, 2030, 2065, 2100, 2135, 2170, 2205, 2240, 2275, 2310, 2345, 2380, 2415, 2450, 2485, 2520, 2555, 2590, 2625, 2660, 2695]</p>
<p>4.练习题2    龟兔赛跑</p>
<p>输入格式<br>　　输入只有一行，包含用空格隔开的五个正整数v1，v2，t，s，l，其中(v1,v2&lt;=100;t&lt;=300;s&lt;=10;l&lt;=10000且为v1,v2的公倍数)<br>输出格式<br>　　输出包含两行，第一行输出比赛结果——一个大写字母“T”或“R”或“D”，分别表示乌龟获胜，兔子获胜，或者两者同时到达终点。<br>　　第二行输出一个正整数，表示获胜者（或者双方同时）到达终点所耗费的时间（秒数）。</p>
<p>方法1     </p>
<p>该算法需要先满足7个条件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">v1,v2,t,s,l = map(int,input().split())</span><br><span class="line"><span class="keyword">if</span> v1&lt;=<span class="number">100</span> <span class="keyword">and</span> v2&lt;=<span class="number">100</span> <span class="keyword">and</span> t&lt;=<span class="number">300</span> <span class="keyword">and</span> s&lt;=<span class="number">10</span> <span class="keyword">and</span> l&lt;=<span class="number">10000</span> <span class="keyword">and</span> l%v1==<span class="number">0</span> <span class="keyword">and</span> l%v2==<span class="number">0</span>:</span><br><span class="line">    s1,s2 = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    i1 = i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> s1&lt;l <span class="keyword">and</span> s2&lt;l:</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">        s1 = s1+v1</span><br><span class="line">        s2 = s2+v2</span><br><span class="line">        <span class="keyword">if</span> s1==l <span class="keyword">or</span> s2==l:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">elif</span> s1-s2&gt;=t:</span><br><span class="line">            s2 = s2+s*v2</span><br><span class="line">            i += s</span><br><span class="line">    <span class="keyword">if</span> s1&gt;s2:</span><br><span class="line">        print(<span class="string">'R'</span>)</span><br><span class="line">    <span class="keyword">if</span> s1==s2:</span><br><span class="line">        print(<span class="string">'D'</span>)</span><br><span class="line">    <span class="keyword">if</span> s1&lt;s2:</span><br><span class="line">        print(<span class="string">'T'</span>)</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>

<p>方法2</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line">v1,v2,t,s,l = map(int,input().split())</span><br><span class="line">s1,s2 = <span class="number">0</span>,<span class="number">0</span></span><br><span class="line">i = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间加一秒，或加1+s秒（兔子落后大于等于t米）</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">if</span> s1-s2&gt;=t:</span><br><span class="line">        s2 += s*v2</span><br><span class="line">        i += s</span><br><span class="line">    <span class="comment"># 根据当前已走距离，分别计算剩余距离所需时间</span></span><br><span class="line">    dt1 = i+(l-s1)/v1</span><br><span class="line">    dt2 = i+(l-s2)/v2</span><br><span class="line">    <span class="comment"># 计算如果加上当前1秒后的s1和s2</span></span><br><span class="line">    s1 = s1+v1</span><br><span class="line">    s2 = s2+v2</span><br><span class="line">    i += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 加上当前1秒后，如果s1或s2大于等于l总路程</span></span><br><span class="line">    <span class="keyword">if</span> s1&gt;=l <span class="keyword">or</span> s2&gt;=l:</span><br><span class="line">        <span class="comment"># 如果1所需时间大于2所需时间，则2赢，取2的时间向上取整</span></span><br><span class="line">        <span class="keyword">if</span> dt1&gt;dt2:</span><br><span class="line">            print(<span class="string">'T'</span>)</span><br><span class="line">            print(math.ceil(dt2))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="comment"># 如果1所需时间不大于2所需时间，则取1的时间向上取整</span></span><br><span class="line">        <span class="keyword">elif</span> dt1 == dt2:</span><br><span class="line">            print(<span class="string">'D'</span>)</span><br><span class="line">            print(math.ceil(dt1))</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">'R'</span>)</span><br><span class="line">            print(math.ceil(dt1))</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>



<p>待看：</p>
<p>Python多线程有趣的例子——龟兔赛跑   <a href="https://blog.csdn.net/qiao39gs/article/details/84503458" target="_blank" rel="noopener">https://blog.csdn.net/qiao39gs/article/details/84503458</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/23/Python-Task02/" data-id="ckddxsxa30006twwcedzh1s1n" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/08/05/Python-Task07/">Python-Task07</a>
          </li>
        
          <li>
            <a href="/2020/08/04/NLP-Task06/">NLP-Task06</a>
          </li>
        
          <li>
            <a href="/2020/08/04/NLP-Task05/">NLP-Task05</a>
          </li>
        
          <li>
            <a href="/2020/08/02/Python-Task06/">Python-Task06</a>
          </li>
        
          <li>
            <a href="/2020/07/31/Python-Task05/">Python-Task05</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>